{"version":3,"file":"node-polyglot-DlDlDF9m.js","sources":["../../node_modules/.pnpm/node-polyglot@2.6.0/node_modules/node-polyglot/index.js"],"sourcesContent":["//     (c) 2012-2018 Airbnb, Inc.\n//\n//     polyglot.js may be freely distributed under the terms of the BSD\n//     license. For all licensing information, details, and documentation:\n//     http://airbnb.github.com/polyglot.js\n//\n//\n// Polyglot.js is an I18n helper library written in JavaScript, made to\n// work both in the browser and in Node. It provides a simple solution for\n// interpolation and pluralization, based off of Airbnb's\n// experience adding I18n functionality to its Backbone.js and Node apps.\n//\n// Polylglot is agnostic to your translation backend. It doesn't perform any\n// translation; it simply gives you a way to manage translated phrases from\n// your client- or server-side JavaScript application.\n//\n\n'use strict';\n\nvar entries = require('object.entries');\nvar warning = require('warning');\nvar has = require('hasown');\n\nvar warn = function warn(message) {\n  warning(false, message);\n};\n\nvar defaultReplace = String.prototype.replace;\nvar split = String.prototype.split;\n\n// #### Pluralization methods\n// The string that separates the different phrase possibilities.\nvar delimiter = '||||';\n\nvar russianPluralGroups = function (n) {\n  var lastTwo = n % 100;\n  var end = lastTwo % 10;\n  if (lastTwo !== 11 && end === 1) {\n    return 0;\n  }\n  if (2 <= end && end <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {\n    return 1;\n  }\n  return 2;\n};\n\nvar defaultPluralRules = {\n  // Mapping from pluralization group plural logic.\n  pluralTypes: {\n    arabic: function (n) {\n      // http://www.arabeyes.org/Plural_Forms\n      if (n < 3) { return n; }\n      var lastTwo = n % 100;\n      if (lastTwo >= 3 && lastTwo <= 10) return 3;\n      return lastTwo >= 11 ? 4 : 5;\n    },\n    bosnian_serbian: russianPluralGroups,\n    chinese: function () { return 0; },\n    croatian: russianPluralGroups,\n    french: function (n) { return n >= 2 ? 1 : 0; },\n    german: function (n) { return n !== 1 ? 1 : 0; },\n    russian: russianPluralGroups,\n    lithuanian: function (n) {\n      if (n % 10 === 1 && n % 100 !== 11) { return 0; }\n      return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;\n    },\n    czech: function (n) {\n      if (n === 1) { return 0; }\n      return (n >= 2 && n <= 4) ? 1 : 2;\n    },\n    polish: function (n) {\n      if (n === 1) { return 0; }\n      var end = n % 10;\n      return 2 <= end && end <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    icelandic: function (n) { return (n % 10 !== 1 || n % 100 === 11) ? 1 : 0; },\n    slovenian: function (n) {\n      var lastTwo = n % 100;\n      if (lastTwo === 1) {\n        return 0;\n      }\n      if (lastTwo === 2) {\n        return 1;\n      }\n      if (lastTwo === 3 || lastTwo === 4) {\n        return 2;\n      }\n      return 3;\n    },\n    romanian: function (n) {\n      if (n === 1) { return 0; }\n      var lastTwo = n % 100;\n      if (n === 0 || (lastTwo >= 2 && lastTwo <= 19)) { return 1; }\n      return 2;\n    },\n    ukrainian: russianPluralGroups\n  },\n\n  // Mapping from pluralization group to individual language codes/locales.\n  // Will look up based on exact match, if not found and it's a locale will parse the locale\n  // for language code, and if that does not exist will default to 'en'\n  pluralTypeToLanguages: {\n    arabic: ['ar'],\n    bosnian_serbian: ['bs-Latn-BA', 'bs-Cyrl-BA', 'srl-RS', 'sr-RS'],\n    chinese: ['id', 'id-ID', 'ja', 'ko', 'ko-KR', 'lo', 'ms', 'th', 'th-TH', 'zh'],\n    croatian: ['hr', 'hr-HR'],\n    german: ['fa', 'da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hi-IN', 'hu', 'hu-HU', 'it', 'nl', 'no', 'pt', 'sv', 'tr'],\n    french: ['fr', 'tl', 'pt-br'],\n    russian: ['ru', 'ru-RU'],\n    lithuanian: ['lt'],\n    czech: ['cs', 'cs-CZ', 'sk'],\n    polish: ['pl'],\n    icelandic: ['is', 'mk'],\n    slovenian: ['sl-SL'],\n    romanian: ['ro'],\n    ukrainian: ['uk', 'ua']\n  }\n};\n\nfunction langToTypeMap(mapping) {\n  var ret = {};\n  var mappingEntries = entries(mapping);\n  for (var i = 0; i < mappingEntries.length; i += 1) {\n    var type = mappingEntries[i][0];\n    var langs = mappingEntries[i][1];\n    for (var j = 0; j < langs.length; j += 1) {\n      ret[langs[j]] = type;\n    }\n  }\n  return ret;\n}\n\nfunction pluralTypeName(pluralRules, locale) {\n  var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);\n  return langToPluralType[locale]\n    || langToPluralType[split.call(locale, /-/, 1)[0]]\n    || langToPluralType.en;\n}\n\nfunction pluralTypeIndex(pluralRules, pluralType, count) {\n  return pluralRules.pluralTypes[pluralType](count);\n}\n\nfunction createMemoizedPluralTypeNameSelector() {\n  var localePluralTypeStorage = {};\n\n  return function (pluralRules, locale) {\n    var pluralType = localePluralTypeStorage[locale];\n\n    if (pluralType && !pluralRules.pluralTypes[pluralType]) {\n      pluralType = null;\n      localePluralTypeStorage[locale] = pluralType;\n    }\n\n    if (!pluralType) {\n      pluralType = pluralTypeName(pluralRules, locale);\n\n      if (pluralType) {\n        localePluralTypeStorage[locale] = pluralType;\n      }\n    }\n\n    return pluralType;\n  };\n}\n\nfunction escape(token) {\n  return token.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction constructTokenRegex(opts) {\n  var prefix = (opts && opts.prefix) || '%{';\n  var suffix = (opts && opts.suffix) || '}';\n\n  if (prefix === delimiter || suffix === delimiter) {\n    throw new RangeError('\"' + delimiter + '\" token is reserved for pluralization');\n  }\n\n  return new RegExp(escape(prefix) + '(.*?)' + escape(suffix), 'g');\n}\n\nvar memoizedPluralTypeName = createMemoizedPluralTypeNameSelector();\n\nvar defaultTokenRegex = /%\\{(.*?)\\}/g;\n\n// ### transformPhrase(phrase, substitutions, locale)\n//\n// Takes a phrase string and transforms it by choosing the correct\n// plural form and interpolating it.\n//\n//     transformPhrase('Hello, %{name}!', {name: 'Spike'});\n//     // \"Hello, Spike!\"\n//\n// The correct plural form is selected if substitutions.smart_count\n// is set. You can pass in a number instead of an Object as `substitutions`\n// as a shortcut for `smart_count`.\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');\n//     // \"1 new message\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');\n//     // \"2 new messages\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');\n//     // \"5 new messages\"\n//\n// You should pass in a third argument, the locale, to specify the correct plural type.\n// It defaults to `'en'` with 2 plural forms.\nfunction transformPhrase(\n  phrase,\n  substitutions,\n  locale,\n  tokenRegex,\n  pluralRules,\n  replaceImplementation\n) {\n  if (typeof phrase !== 'string') {\n    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');\n  }\n\n  if (substitutions == null) {\n    return phrase;\n  }\n\n  var result = phrase;\n  var interpolationRegex = tokenRegex || defaultTokenRegex;\n  var replace = replaceImplementation || defaultReplace;\n\n  // allow number as a pluralization shortcut\n  var options = typeof substitutions === 'number' ? { smart_count: substitutions } : substitutions;\n\n  // Select plural form: based on a phrase text that contains `n`\n  // plural forms separated by `delimiter`, a `locale`, and a `substitutions.smart_count`,\n  // choose the correct plural form. This is only done if `count` is set.\n  if (options.smart_count != null && phrase) {\n    var pluralRulesOrDefault = pluralRules || defaultPluralRules;\n    var texts = split.call(phrase, delimiter);\n    var bestLocale = locale || 'en';\n    var pluralType = memoizedPluralTypeName(pluralRulesOrDefault, bestLocale);\n    var pluralTypeWithCount = pluralTypeIndex(\n      pluralRulesOrDefault,\n      pluralType,\n      options.smart_count\n    );\n\n    result = defaultReplace.call(texts[pluralTypeWithCount] || texts[0], /^[^\\S]*|[^\\S]*$/g, '');\n  }\n\n  // Interpolate: Creates a `RegExp` object for each interpolation placeholder.\n  result = replace.call(result, interpolationRegex, function (expression, argument) {\n    if (!has(options, argument) || options[argument] == null) { return expression; }\n    return options[argument];\n  });\n\n  return result;\n}\n\n// ### Polyglot class constructor\nfunction Polyglot(options) {\n  var opts = options || {};\n  this.phrases = {};\n  this.extend(opts.phrases || {});\n  this.currentLocale = opts.locale || 'en';\n  var allowMissing = opts.allowMissing ? transformPhrase : null;\n  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;\n  this.warn = opts.warn || warn;\n  this.replaceImplementation = opts.replace || defaultReplace;\n  this.tokenRegex = constructTokenRegex(opts.interpolation);\n  this.pluralRules = opts.pluralRules || defaultPluralRules;\n}\n\n// ### polyglot.locale([locale])\n//\n// Get or set locale. Internally, Polyglot only uses locale for pluralization.\nPolyglot.prototype.locale = function (newLocale) {\n  if (newLocale) this.currentLocale = newLocale;\n  return this.currentLocale;\n};\n\n// ### polyglot.extend(phrases)\n//\n// Use `extend` to tell Polyglot how to translate a given key.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The key can be any string.  Feel free to call `extend` multiple times;\n// it will override any phrases with the same key, but leave existing phrases\n// untouched.\n//\n// It is also possible to pass nested phrase objects, which get flattened\n// into an object with the nested keys concatenated using dot notation.\n//\n//     polyglot.extend({\n//       \"nav\": {\n//         \"hello\": \"Hello\",\n//         \"hello_name\": \"Hello, %{name}\",\n//         \"sidebar\": {\n//           \"welcome\": \"Welcome\"\n//         }\n//       }\n//     });\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}',\n//     //   'nav.sidebar.welcome': 'Welcome'\n//     // }\n//\n// `extend` accepts an optional second argument, `prefix`, which can be used\n// to prefix every key in the phrases object with some string, using dot\n// notation.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     }, \"nav\");\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}'\n//     // }\n//\n// This feature is used internally to support nested phrase objects.\nPolyglot.prototype.extend = function (morePhrases, prefix) {\n  var phraseEntries = entries(morePhrases || {});\n  for (var i = 0; i < phraseEntries.length; i += 1) {\n    var key = phraseEntries[i][0];\n    var phrase = phraseEntries[i][1];\n    var prefixedKey = prefix ? prefix + '.' + key : key;\n    if (typeof phrase === 'object') {\n      this.extend(phrase, prefixedKey);\n    } else {\n      this.phrases[prefixedKey] = phrase;\n    }\n  }\n};\n\n// ### polyglot.unset(phrases)\n// Use `unset` to selectively remove keys from a polyglot instance.\n//\n//     polyglot.unset(\"some_key\");\n//     polyglot.unset({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The unset method can take either a string (for the key), or an object hash with\n// the keys that you would like to unset.\nPolyglot.prototype.unset = function (morePhrases, prefix) {\n  if (typeof morePhrases === 'string') {\n    delete this.phrases[morePhrases];\n  } else {\n    var phraseEntries = entries(morePhrases || {});\n    for (var i = 0; i < phraseEntries.length; i += 1) {\n      var key = phraseEntries[i][0];\n      var phrase = phraseEntries[i][1];\n      var prefixedKey = prefix ? prefix + '.' + key : key;\n      if (typeof phrase === 'object') {\n        this.unset(phrase, prefixedKey);\n      } else {\n        delete this.phrases[prefixedKey];\n      }\n    }\n  }\n};\n\n// ### polyglot.clear()\n//\n// Clears all phrases. Useful for special cases, such as freeing\n// up memory if you have lots of phrases but no longer need to\n// perform any translation. Also used internally by `replace`.\nPolyglot.prototype.clear = function () {\n  this.phrases = {};\n};\n\n// ### polyglot.replace(phrases)\n//\n// Completely replace the existing phrases with a new set of phrases.\n// Normally, just use `extend` to add more phrases, but under certain\n// circumstances, you may want to make sure no old phrases are lying around.\nPolyglot.prototype.replace = function (newPhrases) {\n  this.clear();\n  this.extend(newPhrases);\n};\n\n// ### polyglot.t(key, options)\n//\n// The most-used method. Provide a key, and `t` will return the\n// phrase.\n//\n//     polyglot.t(\"hello\");\n//     => \"Hello\"\n//\n// The phrase value is provided first by a call to `polyglot.extend()` or\n// `polyglot.replace()`.\n//\n// Pass in an object as the second argument to perform interpolation.\n//\n//     polyglot.t(\"hello_name\", {name: \"Spike\"});\n//     => \"Hello, Spike\"\n//\n// If you like, you can provide a default value in case the phrase is missing.\n// Use the special option key \"_\" to specify a default.\n//\n//     polyglot.t(\"i_like_to_write_in_language\", {\n//       _: \"I like to write in %{language}.\",\n//       language: \"JavaScript\"\n//     });\n//     => \"I like to write in JavaScript.\"\n//\nPolyglot.prototype.t = function (key, options) {\n  var phrase, result;\n  var opts = options == null ? {} : options;\n  if (typeof this.phrases[key] === 'string') {\n    phrase = this.phrases[key];\n  } else if (typeof opts._ === 'string') {\n    phrase = opts._;\n  } else if (this.onMissingKey) {\n    var onMissingKey = this.onMissingKey;\n    result = onMissingKey(\n      key,\n      opts,\n      this.currentLocale,\n      this.tokenRegex,\n      this.pluralRules,\n      this.replaceImplementation\n    );\n  } else {\n    this.warn('Missing translation for key: \"' + key + '\"');\n    result = key;\n  }\n  if (typeof phrase === 'string') {\n    result = transformPhrase(\n      phrase,\n      opts,\n      this.currentLocale,\n      this.tokenRegex,\n      this.pluralRules,\n      this.replaceImplementation\n    );\n  }\n  return result;\n};\n\n// ### polyglot.has(key)\n//\n// Check if polyglot has a translation for given key\nPolyglot.prototype.has = function (key) {\n  return has(this.phrases, key);\n};\n\n// export transformPhrase\nPolyglot.transformPhrase = function transform(phrase, substitutions, locale) {\n  return transformPhrase(phrase, substitutions, locale);\n};\n\nmodule.exports = Polyglot;\n"],"names":["entries","require$$0","warning","require$$1","has","requireHasown","warn","message","defaultReplace","String","prototype","replace","split","delimiter","russianPluralGroups","n","lastTwo","end","defaultPluralRules","pluralTypes","arabic","bosnian_serbian","chinese","croatian","french","german","russian","lithuanian","czech","polish","icelandic","slovenian","romanian","ukrainian","pluralTypeToLanguages","pluralTypeName","pluralRules","locale","langToPluralType","mapping","ret","mappingEntries","i","length","type","langs","j","langToTypeMap","call","en","escape","token","localePluralTypeStorage","memoizedPluralTypeName","pluralType","defaultTokenRegex","transformPhrase","phrase","substitutions","tokenRegex","replaceImplementation","TypeError","result","interpolationRegex","options","smart_count","pluralRulesOrDefault","texts","pluralTypeWithCount","count","pluralTypeIndex","expression","argument","Polyglot","opts","this","phrases","extend","currentLocale","allowMissing","onMissingKey","prefix","suffix","RangeError","RegExp","constructTokenRegex","interpolation","newLocale","morePhrases","phraseEntries","key","prefixedKey","unset","clear","newPhrases","t","_"],"mappings":"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","x_google_ignoreList":[0]}