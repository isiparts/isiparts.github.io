{"version":3,"file":"replay-yt77ihwD.js","sources":["../../../node_modules/.pnpm/@sentry-internal+replay@9.22.0/node_modules/@sentry-internal/replay/build/npm/esm/index.js"],"sourcesContent":["import { GLOBAL_OBJ, normalize, fill, htmlTreeAsString, browserPerformanceTimeOrigin, logger as logger$1, severityLevelFromString, captureException, addBreadcrumb, uuid4, getClient, getLocationHref, getCurrentScope, getActiveSpan, getDynamicSamplingContextFromSpan, isSentryRequestUrl, stringMatchesSomePattern, addEventProcessor, createEnvelope, createEventEnvelopeHeaders, getSdkMetadataForEnvelopeHeader, prepareEvent, getIsolationScope, resolvedSyncPromise, updateRateLimits, isRateLimited, setContext, getRootSpan, spanToJSON, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, isBrowser, parseSampleRate, consoleSandbox } from '@sentry/core';\nimport { setTimeout as setTimeout$3, addPerformanceInstrumentationHandler, addLcpInstrumentationHandler, addClsInstrumentationHandler, addFidInstrumentationHandler, addInpInstrumentationHandler, serializeFormData, getFetchRequestArgBody, getBodyString, SENTRY_XHR_DATA_KEY, addClickKeypressInstrumentationHandler, addHistoryInstrumentationHandler } from '@sentry-internal/browser-utils';\n\n// exporting a separate copy of `WINDOW` rather than exporting the one from `@sentry/browser`\n// prevents the browser package from being bundled in the CDN bundle, and avoids a\n// circular dependency between the browser and replay packages should `@sentry/browser` import\n// from `@sentry/replay` in the future\nconst WINDOW = GLOBAL_OBJ ;\n\nconst REPLAY_SESSION_KEY = 'sentryReplaySession';\nconst REPLAY_EVENT_NAME = 'replay_event';\nconst UNABLE_TO_SEND_REPLAY = 'Unable to send Replay';\n\n// The idle limit for a session after which recording is paused.\nconst SESSION_IDLE_PAUSE_DURATION = 300000; // 5 minutes in ms\n\n// The idle limit for a session after which the session expires.\nconst SESSION_IDLE_EXPIRE_DURATION = 900000; // 15 minutes in ms\n\n/** Default flush delays */\nconst DEFAULT_FLUSH_MIN_DELAY = 5000;\n// XXX: Temp fix for our debounce logic where `maxWait` would never occur if it\n// was the same as `wait`\nconst DEFAULT_FLUSH_MAX_DELAY = 5500;\n\n/* How long to wait for error checkouts */\nconst BUFFER_CHECKOUT_TIME = 60000;\n\nconst RETRY_BASE_INTERVAL = 5000;\nconst RETRY_MAX_COUNT = 3;\n\n/* The max (uncompressed) size in bytes of a network body. Any body larger than this will be truncated. */\nconst NETWORK_BODY_MAX_SIZE = 150000;\n\n/* The max size of a single console arg that is captured. Any arg larger than this will be truncated. */\nconst CONSOLE_ARG_MAX_SIZE = 5000;\n\n/* Min. time to wait before we consider something a slow click. */\nconst SLOW_CLICK_THRESHOLD = 3000;\n/* For scroll actions after a click, we only look for a very short time period to detect programmatic scrolling. */\nconst SLOW_CLICK_SCROLL_TIMEOUT = 300;\n\n/** When encountering a total segment size exceeding this size, stop the replay (as we cannot properly ingest it). */\nconst REPLAY_MAX_EVENT_BUFFER_SIZE = 20000000; // ~20MB\n\n/** Replays must be min. 5s long before we send them. */\nconst MIN_REPLAY_DURATION = 4999;\n/* The max. allowed value that the minReplayDuration can be set to. */\nconst MIN_REPLAY_DURATION_LIMIT = 15000;\n\n/** The max. length of a replay. */\nconst MAX_REPLAY_DURATION = 3600000; // 60 minutes in ms;\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar NodeType$2 = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType$2 || {});\nfunction isElement$1(n2) {\n  return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n  const host = n2?.host;\n  return Boolean(host?.shadowRoot === n2);\n}\nfunction isNativeShadowDom(shadowRoot) {\n  return Object.prototype.toString.call(shadowRoot) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n  if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n    cssText = cssText.replace(\n      /\\sbackground-clip:\\s*text;/g,\n      \" -webkit-background-clip: text; background-clip: text;\"\n    );\n  }\n  return cssText;\n}\nfunction escapeImportStatement(rule) {\n  const { cssText } = rule;\n  if (cssText.split('\"').length < 3) return cssText;\n  const statement = [\"@import\", `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === \"\") {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s2) {\n  try {\n    const rules2 = s2.rules || s2.cssRules;\n    return rules2 ? fixBrowserCompatibilityIssuesInCSS(\n      Array.from(rules2, stringifyRule).join(\"\")\n    ) : null;\n  } catch (error) {\n    return null;\n  }\n}\nfunction fixAllCssProperty(rule) {\n  let styles = \"\";\n  for (let i2 = 0; i2 < rule.style.length; i2++) {\n    const styleDeclaration = rule.style;\n    const attribute = styleDeclaration[i2];\n    const isImportant = styleDeclaration.getPropertyPriority(attribute);\n    styles += `${attribute}:${styleDeclaration.getPropertyValue(attribute)}${isImportant ? ` !important` : \"\"};`;\n  }\n  return `${rule.selectorText} { ${styles} }`;\n}\nfunction stringifyRule(rule) {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified = // for same-origin stylesheets,\n      // we can access the imported stylesheet rules directly\n      stringifyStylesheet(rule.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n      escapeImportStatement(rule);\n    } catch (error) {\n    }\n  } else if (isCSSStyleRule(rule)) {\n    let cssText = rule.cssText;\n    const needsSafariColonFix = rule.selectorText.includes(\":\");\n    const needsAllFix = typeof rule.style[\"all\"] === \"string\" && rule.style[\"all\"];\n    if (needsAllFix) {\n      cssText = fixAllCssProperty(rule);\n    }\n    if (needsSafariColonFix) {\n      cssText = fixSafariColons(cssText);\n    }\n    if (needsSafariColonFix || needsAllFix) {\n      return cssText;\n    }\n  }\n  return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule) {\n  return \"styleSheet\" in rule;\n}\nfunction isCSSStyleRule(rule) {\n  return \"selectorText\" in rule;\n}\nclass Mirror {\n  constructor() {\n    __publicField$1(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction createMirror$2() {\n  return new Mirror();\n}\nfunction shouldMaskInput({\n  maskInputOptions,\n  tagName,\n  type\n}) {\n  if (tagName === \"OPTION\") {\n    tagName = \"SELECT\";\n  }\n  return Boolean(\n    maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === \"password\" || // Default to \"text\" option for inputs without a \"type\" attribute defined\n    tagName === \"INPUT\" && !type && maskInputOptions[\"text\"]\n  );\n}\nfunction maskInputValue({\n  isMasked,\n  element,\n  value,\n  maskInputFn\n}) {\n  let text = value || \"\";\n  if (!isMasked) {\n    return text;\n  }\n  if (maskInputFn) {\n    text = maskInputFn(text, element);\n  }\n  return \"*\".repeat(text.length);\n}\nfunction toLowerCase(str) {\n  return str.toLowerCase();\n}\nfunction toUpperCase(str) {\n  return str.toUpperCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return true;\n  const chunkSize = 50;\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData;\n      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n      const pixelBuffer = new Uint32Array(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y)\n        ).data.buffer\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\nfunction getInputType(element) {\n  const type = element.type;\n  return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type)\n  ) : null;\n}\nfunction getInputValue(el, tagName, type) {\n  if (tagName === \"INPUT\" && (type === \"radio\" || type === \"checkbox\")) {\n    return el.getAttribute(\"value\") || \"\";\n  }\n  return el.value;\n}\nfunction extractFileExtension(path, baseURL) {\n  let url;\n  try {\n    url = new URL(path, baseURL ?? window.location.href);\n  } catch (err) {\n    return null;\n  }\n  const regex = /\\.([0-9a-z]+)(?:$)/i;\n  const match = url.pathname.match(regex);\n  return match?.[1] ?? null;\n}\nconst cachedImplementations$1 = {};\nfunction getImplementation$1(name) {\n  const cached = cachedImplementations$1[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations$1[name] = impl.bind(\n    window\n  );\n}\nfunction setTimeout$2(...rest) {\n  return getImplementation$1(\"setTimeout\")(...rest);\n}\nfunction clearTimeout$1(...rest) {\n  return getImplementation$1(\"clearTimeout\")(...rest);\n}\nfunction getIframeContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nconst IGNORED_NODE = -2;\nfunction genId() {\n  return _id++;\n}\nfunction getValidTagName$1(element) {\n  if (element instanceof HTMLFormElement) {\n    return \"form\";\n  }\n  const processedTagName = toLowerCase(element.tagName);\n  if (tagNameRegex.test(processedTagName)) {\n    return \"div\";\n  }\n  return processedTagName;\n}\nfunction extractOrigin(url) {\n  let origin = \"\";\n  if (url.indexOf(\"//\") > -1) {\n    origin = url.split(\"/\").slice(0, 3).join(\"/\");\n  } else {\n    origin = url.split(\"/\")[0];\n  }\n  origin = origin.split(\"?\")[0];\n  return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n  return (cssText || \"\").replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || \"\";\n      if (!filePath) {\n        return origin;\n      }\n      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === \"/\") {\n        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n      }\n      const stack = href.split(\"/\");\n      const parts = filePath.split(\"/\");\n      stack.pop();\n      for (const part of parts) {\n        if (part === \".\") {\n          continue;\n        } else if (part === \"..\") {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join(\"/\")}${maybeQuote})`;\n    }\n  );\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n  if (attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  let pos = 0;\n  function collectCharacters(regEx) {\n    let chars2;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars2 = match[0];\n      pos += chars2.length;\n      return chars2;\n    }\n    return \"\";\n  }\n  const output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === \",\") {\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      output.push(url);\n    } else {\n      let descriptorsStr = \"\";\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        const c2 = attributeValue.charAt(pos);\n        if (c2 === \"\") {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c2 === \",\") {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (c2 === \"(\") {\n            inParens = true;\n          }\n        } else {\n          if (c2 === \")\") {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c2;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(\", \");\n}\nconst cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n  if (!attributeValue || attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n  return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n  let a2 = cachedDocument.get(doc);\n  if (!a2) {\n    a2 = doc.createElement(\"a\");\n    cachedDocument.set(doc, a2);\n  }\n  if (!customHref) {\n    customHref = \"\";\n  } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n    return customHref;\n  }\n  a2.setAttribute(\"href\", customHref);\n  return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\n  if (!value) {\n    return value;\n  }\n  if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"srcset\") {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === \"style\") {\n    return absoluteToStylesheet(value, getHref(doc));\n  } else if (tagName === \"object\" && name === \"data\") {\n    return absoluteToDoc(doc, value);\n  }\n  if (typeof maskAttributeFn === \"function\") {\n    return maskAttributeFn(name, value, element);\n  }\n  return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n  return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\n  try {\n    if (unblockSelector && element.matches(unblockSelector)) {\n      return false;\n    }\n    if (typeof blockClass === \"string\") {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--; ) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e2) {\n  }\n  return false;\n}\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--; ) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return (node) => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === \"string\") {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  };\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    if (el === null) return false;\n    if (el.tagName === \"INPUT\") {\n      const autocomplete = el.getAttribute(\"autocomplete\");\n      const disallowedAutocompleteValues = [\n        \"current-password\",\n        \"new-password\",\n        \"cc-number\",\n        \"cc-exp\",\n        \"cc-exp-month\",\n        \"cc-exp-year\",\n        \"cc-csc\"\n      ];\n      if (disallowedAutocompleteValues.includes(autocomplete)) {\n        return true;\n      }\n    }\n    let maskDistance = -1;\n    let unmaskDistance = -1;\n    if (maskAllText) {\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector)\n      );\n      if (unmaskDistance < 0) {\n        return true;\n      }\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector),\n        unmaskDistance >= 0 ? unmaskDistance : Infinity\n      );\n    } else {\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector)\n      );\n      if (maskDistance < 0) {\n        return false;\n      }\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector),\n        maskDistance >= 0 ? maskDistance : Infinity\n      );\n    }\n    return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;\n  } catch (e2) {\n  }\n  return !!maskAllText;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  let fired = false;\n  let readyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== \"complete\") {\n    const timer = setTimeout$2(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener(\"load\", () => {\n      clearTimeout$1(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  const blankUrl = \"about:blank\";\n  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n    setTimeout$2(listener, 0);\n    return iframeEl.addEventListener(\"load\", listener);\n  }\n  iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n  let fired = false;\n  let styleSheetLoaded;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n  if (styleSheetLoaded) return;\n  const timer = setTimeout$2(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n  link.addEventListener(\"load\", () => {\n    clearTimeout$1(timer);\n    fired = true;\n    listener();\n  });\n}\nfunction serializeNode(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskAttributeFn,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false\n  } = options;\n  const rootId = getRootId(doc, mirror2);\n  switch (n2.nodeType) {\n    case n2.DOCUMENT_NODE:\n      if (n2.compatMode !== \"CSS1Compat\") {\n        return {\n          type: NodeType$2.Document,\n          childNodes: [],\n          compatMode: n2.compatMode\n          // probably \"BackCompat\"\n        };\n      } else {\n        return {\n          type: NodeType$2.Document,\n          childNodes: []\n        };\n      }\n    case n2.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType$2.DocumentType,\n        name: n2.name,\n        publicId: n2.publicId,\n        systemId: n2.systemId,\n        rootId\n      };\n    case n2.ELEMENT_NODE:\n      return serializeElementNode(n2, {\n        doc,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        inlineStylesheet,\n        maskAttributeFn,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector\n      });\n    case n2.TEXT_NODE:\n      return serializeTextNode(n2, {\n        doc,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskTextFn,\n        maskInputOptions,\n        maskInputFn,\n        rootId\n      });\n    case n2.CDATA_SECTION_NODE:\n      return {\n        type: NodeType$2.CDATA,\n        textContent: \"\",\n        rootId\n      };\n    case n2.COMMENT_NODE:\n      return {\n        type: NodeType$2.Comment,\n        textContent: n2.textContent || \"\",\n        rootId\n      };\n    default:\n      return false;\n  }\n}\nfunction getRootId(doc, mirror2) {\n  if (!mirror2.hasNode(doc)) return void 0;\n  const docId = mirror2.getId(doc);\n  return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n  const {\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    maskTextFn,\n    maskInputOptions,\n    maskInputFn,\n    rootId\n  } = options;\n  const parentTagName = n2.parentNode && n2.parentNode.tagName;\n  let textContent = n2.textContent;\n  const isStyle = parentTagName === \"STYLE\" ? true : void 0;\n  const isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n  const isTextarea = parentTagName === \"TEXTAREA\" ? true : void 0;\n  if (isStyle && textContent) {\n    try {\n      if (n2.nextSibling || n2.previousSibling) {\n      } else if (n2.parentNode.sheet?.cssRules) {\n        textContent = stringifyStylesheet(\n          n2.parentNode.sheet\n        );\n      }\n    } catch (err) {\n      console.warn(\n        `Cannot get CSS styles from text's parentNode. Error: ${err}`,\n        n2\n      );\n    }\n    textContent = absoluteToStylesheet(textContent, getHref(options.doc));\n  }\n  if (isScript) {\n    textContent = \"SCRIPT_PLACEHOLDER\";\n  }\n  const forceMask = needMaskingText(\n    n2,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextClass,\n    unmaskTextSelector,\n    maskAllText\n  );\n  if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\n    textContent = maskTextFn ? maskTextFn(textContent, n2.parentElement) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\n    textContent = maskInputFn ? maskInputFn(textContent, n2.parentNode) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (parentTagName === \"OPTION\" && textContent) {\n    const isInputMasked = shouldMaskInput({\n      type: null,\n      tagName: parentTagName,\n      maskInputOptions\n    });\n    textContent = maskInputValue({\n      isMasked: needMaskingText(\n        n2,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        isInputMasked\n      ),\n      element: n2,\n      value: textContent,\n      maskInputFn\n    });\n  }\n  return {\n    type: NodeType$2.Text,\n    textContent: textContent || \"\",\n    isStyle,\n    rootId\n  };\n}\nfunction serializeElementNode(n2, options) {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector\n  } = options;\n  const needBlock = _isBlockedElement(\n    n2,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  );\n  const tagName = getValidTagName$1(n2);\n  let attributes2 = {};\n  const len = n2.attributes.length;\n  for (let i2 = 0; i2 < len; i2++) {\n    const attr = n2.attributes[i2];\n    if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes2[attr.name] = transformAttribute(\n        doc,\n        tagName,\n        toLowerCase(attr.name),\n        attr.value,\n        n2,\n        maskAttributeFn\n      );\n    }\n  }\n  if (tagName === \"link\" && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find((s2) => {\n      return s2.href === n2.href;\n    });\n    let cssText = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      attributes2.rel = null;\n      attributes2.href = null;\n      attributes2.crossorigin = null;\n      attributes2._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n    }\n  }\n  if (tagName === \"style\" && n2.sheet && // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n  !(n2.innerText || n2.textContent || \"\").trim().length) {\n    const cssText = stringifyStylesheet(\n      n2.sheet\n    );\n    if (cssText) {\n      attributes2._cssText = absoluteToStylesheet(cssText, getHref(doc));\n    }\n  }\n  if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\" || tagName === \"option\") {\n    const el = n2;\n    const type = getInputType(el);\n    const value = getInputValue(el, toUpperCase(tagName), type);\n    const checked = el.checked;\n    if (type !== \"submit\" && type !== \"button\" && value) {\n      const forceMask = needMaskingText(\n        el,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        shouldMaskInput({\n          type,\n          tagName: toUpperCase(tagName),\n          maskInputOptions\n        })\n      );\n      attributes2.value = maskInputValue({\n        isMasked: forceMask,\n        element: el,\n        value,\n        maskInputFn\n      });\n    }\n    if (checked) {\n      attributes2.checked = checked;\n    }\n  }\n  if (tagName === \"option\") {\n    if (n2.selected && !maskInputOptions[\"select\"]) {\n      attributes2.selected = true;\n    } else {\n      delete attributes2.selected;\n    }\n  }\n  if (tagName === \"canvas\" && recordCanvas) {\n    if (n2.__context === \"2d\") {\n      if (!is2DCanvasBlank(n2)) {\n        attributes2.rr_dataURL = n2.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      }\n    } else if (!(\"__context\" in n2)) {\n      const canvasDataURL = n2.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      const blankCanvas = doc.createElement(\"canvas\");\n      blankCanvas.width = n2.width;\n      blankCanvas.height = n2.height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes2.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  if (tagName === \"img\" && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement(\"canvas\");\n      canvasCtx = canvasService.getContext(\"2d\");\n    }\n    const image = n2;\n    const imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n    const priorCrossOrigin = image.crossOrigin;\n    const recordInlineImage = () => {\n      image.removeEventListener(\"load\", recordInlineImage);\n      try {\n        canvasService.width = image.naturalWidth;\n        canvasService.height = image.naturalHeight;\n        canvasCtx.drawImage(image, 0, 0);\n        attributes2.rr_dataURL = canvasService.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      } catch (err) {\n        if (image.crossOrigin !== \"anonymous\") {\n          image.crossOrigin = \"anonymous\";\n          if (image.complete && image.naturalWidth !== 0)\n            recordInlineImage();\n          else image.addEventListener(\"load\", recordInlineImage);\n          return;\n        } else {\n          console.warn(\n            `Cannot inline img src=${imageSrc}! Error: ${err}`\n          );\n        }\n      }\n      if (image.crossOrigin === \"anonymous\") {\n        priorCrossOrigin ? attributes2.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n      }\n    };\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n    else image.addEventListener(\"load\", recordInlineImage);\n  }\n  if (tagName === \"audio\" || tagName === \"video\") {\n    attributes2.rr_mediaState = n2.paused ? \"paused\" : \"played\";\n    attributes2.rr_mediaCurrentTime = n2.currentTime;\n  }\n  if (!newlyAddedElement) {\n    if (n2.scrollLeft) {\n      attributes2.rr_scrollLeft = n2.scrollLeft;\n    }\n    if (n2.scrollTop) {\n      attributes2.rr_scrollTop = n2.scrollTop;\n    }\n  }\n  if (needBlock) {\n    const { width, height } = n2.getBoundingClientRect();\n    attributes2 = {\n      class: attributes2.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`\n    };\n  }\n  if (tagName === \"iframe\" && !keepIframeSrcFn(attributes2.src)) {\n    if (!needBlock && !getIframeContentDocument(n2)) {\n      attributes2.rr_src = attributes2.src;\n    }\n    delete attributes2.src;\n  }\n  let isCustomElement;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e2) {\n  }\n  return {\n    type: NodeType$2.Element,\n    tagName,\n    attributes: attributes2,\n    childNodes: [],\n    isSVG: isSVGElement(n2) || void 0,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement\n  };\n}\nfunction lowerIfExists(maybeAttr) {\n  if (maybeAttr === void 0 || maybeAttr === null) {\n    return \"\";\n  } else {\n    return maybeAttr.toLowerCase();\n  }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n  if (slimDOMOptions.comment && sn.type === NodeType$2.Comment) {\n    return true;\n  } else if (sn.type === NodeType$2.Element) {\n    if (slimDOMOptions.script && // script tag\n    (sn.tagName === \"script\" || // (module)preload link\n    sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") || // prefetch link\n    sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n      return true;\n    } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(\n      /^msapplication-tile(image|color)$/\n    ) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n      return true;\n    } else if (sn.tagName === \"meta\") {\n      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n        return true;\n      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n        return true;\n      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n        return true;\n      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction serializeNodeWithId(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5e3,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5e3,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n2, {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    maskAllText,\n    unblockSelector,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement\n  });\n  if (!_serializedNode) {\n    console.warn(n2, \"not serialized\");\n    return null;\n  }\n  let id;\n  if (mirror2.hasNode(n2)) {\n    id = mirror2.getId(n2);\n  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$2.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode2 = Object.assign(_serializedNode, { id });\n  mirror2.add(n2, serializedNode2);\n  if (id === IGNORED_NODE) {\n    return null;\n  }\n  if (onSerialize) {\n    onSerialize(n2);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode2.type === NodeType$2.Element) {\n    recordChild = recordChild && !serializedNode2.needBlock;\n    delete serializedNode2.needBlock;\n    const shadowRoot = n2.shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot))\n      serializedNode2.isShadowHost = true;\n  }\n  if ((serializedNode2.type === NodeType$2.Document || serializedNode2.type === NodeType$2.Element) && recordChild) {\n    if (slimDOMOptions.headWhitespace && serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"head\") {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror: mirror2,\n      blockClass,\n      blockSelector,\n      maskAllText,\n      unblockSelector,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn\n    };\n    for (const childN of Array.from(n2.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode2.childNodes.push(serializedChildNode);\n      }\n    }\n    if (isElement$1(n2) && n2.shadowRoot) {\n      for (const childN of Array.from(n2.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n2.shadowRoot) && (serializedChildNode.isShadow = true);\n          serializedNode2.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n  if (n2.parentNode && isShadowRoot(n2.parentNode) && isNativeShadowDom(n2.parentNode)) {\n    serializedNode2.isShadow = true;\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"iframe\" && !_isBlockedElement(\n    n2,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  )) {\n    onceIframeLoaded(\n      n2,\n      () => {\n        const iframeDoc = getIframeContentDocument(n2);\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedIframeNode) {\n            onIframeLoad(\n              n2,\n              serializedIframeNode\n            );\n          }\n        }\n      },\n      iframeLoadTimeout\n    );\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"link\" && typeof serializedNode2.attributes.rel === \"string\" && (serializedNode2.attributes.rel === \"stylesheet\" || serializedNode2.attributes.rel === \"preload\" && typeof serializedNode2.attributes.href === \"string\" && extractFileExtension(serializedNode2.attributes.href) === \"css\")) {\n    onceStylesheetLoaded(\n      n2,\n      () => {\n        if (onStylesheetLoad) {\n          const serializedLinkNode = serializeNodeWithId(n2, {\n            doc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedLinkNode) {\n            onStylesheetLoad(\n              n2,\n              serializedLinkNode\n            );\n          }\n        }\n      },\n      stylesheetLoadTimeout\n    );\n  }\n  return serializedNode2;\n}\nfunction snapshot(n2, options) {\n  const {\n    mirror: mirror2 = new Mirror(),\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false\n  } = options || {};\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true\n  } : maskAllInputs === false ? {} : maskAllInputs;\n  const slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? (\n    // if true: set of sensible options that should not throw away any information\n    {\n      script: true,\n      comment: true,\n      headFavicon: true,\n      headWhitespace: true,\n      headMetaDescKeywords: slimDOM === \"all\",\n      // destructive\n      headMetaSocial: true,\n      headMetaRobots: true,\n      headMetaHttpEquiv: true,\n      headMetaAuthorship: true,\n      headMetaVerification: true\n    }\n  ) : slimDOM === false ? {} : slimDOM;\n  return serializeNodeWithId(n2, {\n    doc: n2,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false\n  });\n}\nfunction on(type, fn, target = document) {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nlet _mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === \"map\") {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction throttle$1(func, wait, options = {}) {\n  let timeout = null;\n  let previous = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    const context = this;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout$2(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout$1(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked ? d : {\n      set(value) {\n        setTimeout$1(() => {\n          d.set.call(this, value);\n        }, 0);\n        if (original && original.set) {\n          original.set.call(this, value);\n        }\n      }\n    }\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {\n      };\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === \"function\") {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {\n    };\n  }\n}\nlet nowTimestamp = Date.now;\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {\n  nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();\n}\nfunction getWindowScroll(win) {\n  const doc = win.document;\n  return {\n    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc?.documentElement.scrollLeft || doc?.body?.parentElement?.scrollLeft || doc?.body?.scrollLeft || 0,\n    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : doc?.documentElement.scrollTop || doc?.body?.parentElement?.scrollTop || doc?.body?.scrollTop || 0\n  };\n}\nfunction getWindowHeight() {\n  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node) {\n  if (!node) {\n    return null;\n  }\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n  } catch (error) {\n    return null;\n  }\n}\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n  if (!node) {\n    return false;\n  }\n  const el = closestElementOfNode(node);\n  if (!el) {\n    return false;\n  }\n  const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n  if (!checkAncestors) {\n    const isUnblocked = unblockSelector && el.matches(unblockSelector);\n    return blockedPredicate(el) && !isUnblocked;\n  }\n  const blockDistance = distanceToMatch(el, blockedPredicate);\n  let unblockDistance = -1;\n  if (blockDistance < 0) {\n    return false;\n  }\n  if (unblockSelector) {\n    unblockDistance = distanceToMatch(\n      el,\n      createMatchPredicate(null, unblockSelector)\n    );\n  }\n  if (blockDistance > -1 && unblockDistance < 0) {\n    return true;\n  }\n  return blockDistance < unblockDistance;\n}\nfunction isSerialized(n2, mirror2) {\n  return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2) {\n  return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror2.getId(target);\n  if (!mirror2.has(id)) {\n    return true;\n  }\n  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n    return false;\n  }\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved(target.parentNode, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n  return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win = window) {\n  if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = (...args) => {\n      let node = args[0];\n      if (!(0 in args)) {\n        throw new TypeError(\"1 argument is required\");\n      }\n      do {\n        if (this === node) {\n          return true;\n        }\n      } while (node = node && node.parentNode);\n      return false;\n    };\n  }\n}\nfunction isSerializedIframe(n2, mirror2) {\n  return Boolean(n2.nodeName === \"IFRAME\" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n  return Boolean(\n    n2.nodeName === \"LINK\" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n2)\n  );\n}\nfunction hasShadowRoot(n2) {\n  return Boolean(n2?.shadowRoot);\n}\nclass StyleSheetMirror {\n  constructor() {\n    this.id = 1;\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n  }\n  getId(stylesheet) {\n    return this.styleIDMap.get(stylesheet) ?? -1;\n  }\n  has(stylesheet) {\n    return this.styleIDMap.has(stylesheet);\n  }\n  /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */\n  add(stylesheet, id) {\n    if (this.has(stylesheet)) return this.getId(stylesheet);\n    let newId;\n    if (id === void 0) {\n      newId = this.id++;\n    } else newId = id;\n    this.styleIDMap.set(stylesheet, newId);\n    this.idStyleMap.set(newId, stylesheet);\n    return newId;\n  }\n  getStyle(id) {\n    return this.idStyleMap.get(id) || null;\n  }\n  reset() {\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n    this.id = 1;\n  }\n  generateId() {\n    return this.id++;\n  }\n}\nfunction getShadowHost(n2) {\n  let shadowHost = null;\n  if (n2.getRootNode?.()?.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n2.getRootNode().host)\n    shadowHost = n2.getRootNode().host;\n  return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n  let rootShadowHost = n2;\n  let shadowHost;\n  while (shadowHost = getShadowHost(rootShadowHost))\n    rootShadowHost = shadowHost;\n  return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  const shadowHost = getRootShadowHost(n2);\n  return doc.contains(shadowHost);\n}\nfunction inDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  return doc.contains(n2) || shadowHostInDom(n2);\n}\nconst cachedImplementations = {};\nfunction getImplementation(name) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations[name] = impl.bind(\n    window\n  );\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getImplementation(\"requestAnimationFrame\")(...rest);\n}\nfunction setTimeout$1(...rest) {\n  return getImplementation(\"setTimeout\")(...rest);\n}\nfunction clearTimeout$2(...rest) {\n  return getImplementation(\"clearTimeout\")(...rest);\n}\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {\n  MediaInteractions2[MediaInteractions2[\"Play\"] = 0] = \"Play\";\n  MediaInteractions2[MediaInteractions2[\"Pause\"] = 1] = \"Pause\";\n  MediaInteractions2[MediaInteractions2[\"Seeked\"] = 2] = \"Seeked\";\n  MediaInteractions2[MediaInteractions2[\"VolumeChange\"] = 3] = \"VolumeChange\";\n  MediaInteractions2[MediaInteractions2[\"RateChange\"] = 4] = \"RateChange\";\n  return MediaInteractions2;\n})(MediaInteractions || {});\nfunction getIFrameContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nfunction getIFrameContentWindow(iframe) {\n  try {\n    return iframe.contentWindow;\n  } catch (e2) {\n  }\n}\nfunction isNodeInLinkedList(n2) {\n  return \"__ln\" in n2;\n}\nclass DoubleLinkedList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n  }\n  get(position) {\n    if (position >= this.length) {\n      throw new Error(\"Position outside of list range\");\n    }\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n  addNode(n2) {\n    const node = {\n      value: n2,\n      previous: null,\n      next: null\n    };\n    n2.__ln = node;\n    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n      const current = n2.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n2.previousSibling.__ln;\n      n2.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n      const current = n2.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n2.nextSibling.__ln;\n      n2.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    if (node.next === null) {\n      this.tail = node;\n    }\n    this.length++;\n  }\n  removeNode(n2) {\n    const current = n2.__ln;\n    if (!this.head) {\n      return;\n    }\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      } else {\n        this.tail = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      } else {\n        this.tail = current.previous;\n      }\n    }\n    if (n2.__ln) {\n      delete n2.__ln;\n    }\n    this.length--;\n  }\n}\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\nclass MutationBuffer {\n  constructor() {\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.attributeMap = /* @__PURE__ */ new WeakMap();\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = /* @__PURE__ */ new Set();\n    this.movedSet = /* @__PURE__ */ new Set();\n    this.droppedSet = /* @__PURE__ */ new Set();\n    this.processMutations = (mutations) => {\n      mutations.forEach(this.processMutation);\n      this.emit();\n    };\n    this.emit = () => {\n      if (this.frozen || this.locked) {\n        return;\n      }\n      const adds = [];\n      const addedIds = /* @__PURE__ */ new Set();\n      const addList = new DoubleLinkedList();\n      const getNextId = (n2) => {\n        let ns = n2;\n        let nextId = IGNORED_NODE;\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && this.mirror.getId(ns);\n        }\n        return nextId;\n      };\n      const pushAdd = (n2) => {\n        if (!n2.parentNode || !inDom(n2)) {\n          return;\n        }\n        const parentId = isShadowRoot(n2.parentNode) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(n2.parentNode);\n        const nextId = getNextId(n2);\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n2);\n        }\n        const sn = serializeNodeWithId(n2, {\n          doc: this.doc,\n          mirror: this.mirror,\n          blockClass: this.blockClass,\n          blockSelector: this.blockSelector,\n          maskAllText: this.maskAllText,\n          unblockSelector: this.unblockSelector,\n          maskTextClass: this.maskTextClass,\n          unmaskTextClass: this.unmaskTextClass,\n          maskTextSelector: this.maskTextSelector,\n          unmaskTextSelector: this.unmaskTextSelector,\n          skipChild: true,\n          newlyAddedElement: true,\n          inlineStylesheet: this.inlineStylesheet,\n          maskInputOptions: this.maskInputOptions,\n          maskAttributeFn: this.maskAttributeFn,\n          maskTextFn: this.maskTextFn,\n          maskInputFn: this.maskInputFn,\n          slimDOMOptions: this.slimDOMOptions,\n          dataURLOptions: this.dataURLOptions,\n          recordCanvas: this.recordCanvas,\n          inlineImages: this.inlineImages,\n          onSerialize: (currentN) => {\n            if (isSerializedIframe(currentN, this.mirror) && !isBlocked(\n              currentN,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              this.iframeManager.addIframe(currentN);\n            }\n            if (isSerializedStylesheet(currentN, this.mirror)) {\n              this.stylesheetManager.trackLinkElement(\n                currentN\n              );\n            }\n            if (hasShadowRoot(n2)) {\n              this.shadowDomManager.addShadowRoot(n2.shadowRoot, this.doc);\n            }\n          },\n          onIframeLoad: (iframe, childSn) => {\n            if (isBlocked(\n              iframe,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              return;\n            }\n            this.iframeManager.attachIframe(iframe, childSn);\n            if (iframe.contentWindow) {\n              this.canvasManager.addWindow(iframe.contentWindow);\n            }\n            this.shadowDomManager.observeAttachShadow(iframe);\n          },\n          onStylesheetLoad: (link, childSn) => {\n            this.stylesheetManager.attachLinkElement(link, childSn);\n          }\n        });\n        if (sn) {\n          adds.push({\n            parentId,\n            nextId,\n            node: sn\n          });\n          addedIds.add(sn.id);\n        }\n      };\n      while (this.mapRemoves.length) {\n        this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n      }\n      for (const n2 of this.movedSet) {\n        if (isParentRemoved(this.removes, n2, this.mirror) && !this.movedSet.has(n2.parentNode)) {\n          continue;\n        }\n        pushAdd(n2);\n      }\n      for (const n2 of this.addedSet) {\n        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removes, n2, this.mirror)) {\n          pushAdd(n2);\n        } else if (isAncestorInSet(this.movedSet, n2)) {\n          pushAdd(n2);\n        } else {\n          this.droppedSet.add(n2);\n        }\n      }\n      let candidate = null;\n      while (addList.length) {\n        let node = null;\n        if (candidate) {\n          const parentId = this.mirror.getId(candidate.value.parentNode);\n          const nextId = getNextId(candidate.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n        if (!node) {\n          let tailNode = addList.tail;\n          while (tailNode) {\n            const _node = tailNode;\n            tailNode = tailNode.previous;\n            if (_node) {\n              const parentId = this.mirror.getId(_node.value.parentNode);\n              const nextId = getNextId(_node.value);\n              if (nextId === -1) continue;\n              else if (parentId !== -1) {\n                node = _node;\n                break;\n              } else {\n                const unhandledNode = _node.value;\n                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                  const shadowHost = unhandledNode.parentNode.host;\n                  const parentId2 = this.mirror.getId(shadowHost);\n                  if (parentId2 !== -1) {\n                    node = _node;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n          break;\n        }\n        candidate = node.previous;\n        addList.removeNode(node.value);\n        pushAdd(node.value);\n      }\n      const payload = {\n        texts: this.texts.map((text) => ({\n          id: this.mirror.getId(text.node),\n          value: text.value\n        })).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),\n        attributes: this.attributes.map((attribute) => {\n          const { attributes } = attribute;\n          if (typeof attributes.style === \"string\") {\n            const diffAsStr = JSON.stringify(attribute.styleDiff);\n            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n            if (diffAsStr.length < attributes.style.length) {\n              if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                attributes.style = attribute.styleDiff;\n              }\n            }\n          }\n          return {\n            id: this.mirror.getId(attribute.node),\n            attributes\n          };\n        }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),\n        removes: this.removes,\n        adds\n      };\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n      this.texts = [];\n      this.attributes = [];\n      this.attributeMap = /* @__PURE__ */ new WeakMap();\n      this.removes = [];\n      this.addedSet = /* @__PURE__ */ new Set();\n      this.movedSet = /* @__PURE__ */ new Set();\n      this.droppedSet = /* @__PURE__ */ new Set();\n      this.movedMap = {};\n      this.mutationCb(payload);\n    };\n    this.processMutation = (m) => {\n      if (isIgnored(m.target, this.mirror)) {\n        return;\n      }\n      switch (m.type) {\n        case \"characterData\": {\n          const value = m.target.textContent;\n          if (!isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) && value !== m.oldValue) {\n            this.texts.push({\n              value: needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n                this.unmaskTextClass,\n                this.unmaskTextSelector,\n                this.maskAllText\n              ) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n              node: m.target\n            });\n          }\n          break;\n        }\n        case \"attributes\": {\n          const target = m.target;\n          let attributeName = m.attributeName;\n          let value = m.target.getAttribute(attributeName);\n          if (attributeName === \"value\") {\n            const type = getInputType(target);\n            const tagName = target.tagName;\n            value = getInputValue(target, tagName, type);\n            const isInputMasked = shouldMaskInput({\n              maskInputOptions: this.maskInputOptions,\n              tagName,\n              type\n            });\n            const forceMask = needMaskingText(\n              m.target,\n              this.maskTextClass,\n              this.maskTextSelector,\n              this.unmaskTextClass,\n              this.unmaskTextSelector,\n              isInputMasked\n            );\n            value = maskInputValue({\n              isMasked: forceMask,\n              element: target,\n              value,\n              maskInputFn: this.maskInputFn\n            });\n          }\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) || value === m.oldValue) {\n            return;\n          }\n          let item = this.attributeMap.get(m.target);\n          if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !this.keepIframeSrcFn(value)) {\n            const iframeDoc = getIFrameContentDocument(\n              target\n            );\n            if (!iframeDoc) {\n              attributeName = \"rr_src\";\n            } else {\n              return;\n            }\n          }\n          if (!item) {\n            item = {\n              node: m.target,\n              attributes: {},\n              styleDiff: {},\n              _unchangedStyles: {}\n            };\n            this.attributes.push(item);\n            this.attributeMap.set(m.target, item);\n          }\n          if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n            target.setAttribute(\"data-rr-is-password\", \"true\");\n          }\n          if (!ignoreAttribute(target.tagName, attributeName)) {\n            item.attributes[attributeName] = transformAttribute(\n              this.doc,\n              toLowerCase(target.tagName),\n              toLowerCase(attributeName),\n              value,\n              target,\n              this.maskAttributeFn\n            );\n            if (attributeName === \"style\") {\n              if (!this.unattachedDoc) {\n                try {\n                  this.unattachedDoc = document.implementation.createHTMLDocument();\n                } catch (e2) {\n                  this.unattachedDoc = this.doc;\n                }\n              }\n              const old = this.unattachedDoc.createElement(\"span\");\n              if (m.oldValue) {\n                old.setAttribute(\"style\", m.oldValue);\n              }\n              for (const pname of Array.from(target.style)) {\n                const newValue = target.style.getPropertyValue(pname);\n                const newPriority = target.style.getPropertyPriority(pname);\n                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                  if (newPriority === \"\") {\n                    item.styleDiff[pname] = newValue;\n                  } else {\n                    item.styleDiff[pname] = [newValue, newPriority];\n                  }\n                } else {\n                  item._unchangedStyles[pname] = [newValue, newPriority];\n                }\n              }\n              for (const pname of Array.from(old.style)) {\n                if (target.style.getPropertyValue(pname) === \"\") {\n                  item.styleDiff[pname] = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n        case \"childList\": {\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            true\n          )) {\n            return;\n          }\n          m.addedNodes.forEach((n2) => this.genAdds(n2, m.target));\n          m.removedNodes.forEach((n2) => {\n            const nodeId = this.mirror.getId(n2);\n            const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n            if (isBlocked(\n              m.target,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            ) || isIgnored(n2, this.mirror) || !isSerialized(n2, this.mirror)) {\n              return;\n            }\n            if (this.addedSet.has(n2)) {\n              deepDelete(this.addedSet, n2);\n              this.droppedSet.add(n2);\n            } else if (this.addedSet.has(m.target) && nodeId === -1) ;\n            else if (isAncestorRemoved(m.target, this.mirror)) ;\n            else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {\n              deepDelete(this.movedSet, n2);\n            } else {\n              this.removes.push({\n                parentId,\n                id: nodeId,\n                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n              });\n            }\n            this.mapRemoves.push(n2);\n          });\n          break;\n        }\n      }\n    };\n    this.genAdds = (n2, target) => {\n      if (this.processedNodeManager.inOtherBuffer(n2, this)) return;\n      if (this.addedSet.has(n2) || this.movedSet.has(n2)) return;\n      if (this.mirror.hasNode(n2)) {\n        if (isIgnored(n2, this.mirror)) {\n          return;\n        }\n        this.movedSet.add(n2);\n        let targetId = null;\n        if (target && this.mirror.hasNode(target)) {\n          targetId = this.mirror.getId(target);\n        }\n        if (targetId && targetId !== -1) {\n          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;\n        }\n      } else {\n        this.addedSet.add(n2);\n        this.droppedSet.delete(n2);\n      }\n      if (!isBlocked(\n        n2,\n        this.blockClass,\n        this.blockSelector,\n        this.unblockSelector,\n        false\n      )) {\n        n2.childNodes.forEach((childN) => this.genAdds(childN));\n        if (hasShadowRoot(n2)) {\n          n2.shadowRoot.childNodes.forEach((childN) => {\n            this.processedNodeManager.add(childN, this);\n            this.genAdds(childN, n2);\n          });\n        }\n      }\n    };\n  }\n  init(options) {\n    [\n      \"mutationCb\",\n      \"blockClass\",\n      \"blockSelector\",\n      \"unblockSelector\",\n      \"maskAllText\",\n      \"maskTextClass\",\n      \"unmaskTextClass\",\n      \"maskTextSelector\",\n      \"unmaskTextSelector\",\n      \"inlineStylesheet\",\n      \"maskInputOptions\",\n      \"maskAttributeFn\",\n      \"maskTextFn\",\n      \"maskInputFn\",\n      \"keepIframeSrcFn\",\n      \"recordCanvas\",\n      \"inlineImages\",\n      \"slimDOMOptions\",\n      \"dataURLOptions\",\n      \"doc\",\n      \"mirror\",\n      \"iframeManager\",\n      \"stylesheetManager\",\n      \"shadowDomManager\",\n      \"canvasManager\",\n      \"processedNodeManager\"\n    ].forEach((key) => {\n      this[key] = options[key];\n    });\n  }\n  freeze() {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  }\n  unfreeze() {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  }\n  isFrozen() {\n    return this.frozen;\n  }\n  lock() {\n    this.locked = true;\n    this.canvasManager.lock();\n  }\n  unlock() {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  }\n  reset() {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  }\n}\nfunction deepDelete(addsSet, n2) {\n  addsSet.delete(n2);\n  n2.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n  if (removes.length === 0) return false;\n  return _isParentRemoved(removes, n2, mirror2);\n}\nfunction _isParentRemoved(removes, n2, mirror2) {\n  let node = n2.parentNode;\n  while (node) {\n    const parentId = mirror2.getId(node);\n    if (removes.some((r2) => r2.id === parentId)) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\nfunction isAncestorInSet(set, n2) {\n  if (set.size === 0) return false;\n  return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n  const { parentNode } = n2;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return _isAncestorInSet(set, parentNode);\n}\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n  errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n  errorHandler = void 0;\n}\nconst callbackWrapper = (cb) => {\n  if (!errorHandler) {\n    return cb;\n  }\n  const rrwebWrapped = (...rest) => {\n    try {\n      return cb(...rest);\n    } catch (error) {\n      if (errorHandler && errorHandler(error) === true) {\n        return () => {\n        };\n      }\n      throw error;\n    }\n  };\n  return rrwebWrapped;\n};\nconst mutationBuffers = [];\nfunction getEventTarget(event) {\n  try {\n    if (\"composedPath\" in event) {\n      const path = event.composedPath();\n      if (path.length) {\n        return path[0];\n      }\n    } else if (\"path\" in event && event.path.length) {\n      return event.path[0];\n    }\n  } catch {\n  }\n  return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  mutationBuffer.init(options);\n  let mutationObserverCtor = window.MutationObserver || /**\n  * Some websites may disable MutationObserver by removing it from the window object.\n  * If someone is using rrweb to build a browser extention or things like it, they\n  * could not change the website's code but can have an opportunity to inject some\n  * code before the website executing its JS logic.\n  * Then they can do this to store the native MutationObserver:\n  * window.__rrMutationObserver = MutationObserver\n  */\n  window.__rrMutationObserver;\n  const angularZoneSymbol = window?.Zone?.__symbol__?.(\"MutationObserver\");\n  if (angularZoneSymbol && window[angularZoneSymbol]) {\n    mutationObserverCtor = window[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    callbackWrapper((mutations) => {\n      if (options.onMutation && options.onMutation(mutations) === false) {\n        return;\n      }\n      mutationBuffer.processMutations.bind(mutationBuffer)(mutations);\n    })\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nfunction initMoveObserver({\n  mousemoveCb,\n  sampling,\n  doc,\n  mirror: mirror2\n}) {\n  if (sampling.mousemove === false) {\n    return () => {\n    };\n  }\n  const threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n  const callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n  let positions = [];\n  let timeBaseline;\n  const wrappedCb = throttle$1(\n    callbackWrapper(\n      (source) => {\n        const totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(\n          positions.map((p) => {\n            p.timeOffset -= totalOffset;\n            return p;\n          }),\n          source\n        );\n        positions = [];\n        timeBaseline = null;\n      }\n    ),\n    callbackThreshold\n  );\n  const updatePosition = callbackWrapper(\n    throttle$1(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n        if (!timeBaseline) {\n          timeBaseline = nowTimestamp();\n        }\n        positions.push({\n          x: clientX,\n          y: clientY,\n          id: mirror2.getId(target),\n          timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(\n          typeof DragEvent !== \"undefined\" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove\n        );\n      }),\n      threshold,\n      {\n        trailing: false\n      }\n    )\n  );\n  const handlers = [\n    on(\"mousemove\", updatePosition, doc),\n    on(\"touchmove\", updatePosition, doc),\n    on(\"drag\", updatePosition, doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initMouseInteractionObserver({\n  mouseInteractionCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  if (sampling.mouseInteraction === false) {\n    return () => {\n    };\n  }\n  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n  const handlers = [];\n  let currentPointerType = null;\n  const getHandler = (eventKey) => {\n    return (event) => {\n      const target = getEventTarget(event);\n      if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      let pointerType = null;\n      let thisEventKey = eventKey;\n      if (\"pointerType\" in event) {\n        switch (event.pointerType) {\n          case \"mouse\":\n            pointerType = PointerTypes.Mouse;\n            break;\n          case \"touch\":\n            pointerType = PointerTypes.Touch;\n            break;\n          case \"pen\":\n            pointerType = PointerTypes.Pen;\n            break;\n        }\n        if (pointerType === PointerTypes.Touch) {\n          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n            thisEventKey = \"TouchStart\";\n          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n            thisEventKey = \"TouchEnd\";\n          }\n        } else if (pointerType === PointerTypes.Pen) ;\n      } else if (legacy_isTouchEvent(event)) {\n        pointerType = PointerTypes.Touch;\n      }\n      if (pointerType !== null) {\n        currentPointerType = pointerType;\n        if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n          pointerType = null;\n        }\n      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n        pointerType = currentPointerType;\n        currentPointerType = null;\n      }\n      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e2) {\n        return;\n      }\n      const id = mirror2.getId(target);\n      const { clientX, clientY } = e2;\n      callbackWrapper(mouseInteractionCb)({\n        type: MouseInteractions[thisEventKey],\n        id,\n        x: clientX,\n        y: clientY,\n        ...pointerType !== null && { pointerType }\n      });\n    };\n  };\n  Object.keys(MouseInteractions).filter(\n    (key) => Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false\n  ).forEach((eventKey) => {\n    let eventName = toLowerCase(eventKey);\n    const handler = getHandler(eventKey);\n    if (window.PointerEvent) {\n      switch (MouseInteractions[eventKey]) {\n        case MouseInteractions.MouseDown:\n        case MouseInteractions.MouseUp:\n          eventName = eventName.replace(\n            \"mouse\",\n            \"pointer\"\n          );\n          break;\n        case MouseInteractions.TouchStart:\n        case MouseInteractions.TouchEnd:\n          return;\n      }\n    }\n    handlers.push(on(eventName, handler, doc));\n  });\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initScrollObserver({\n  scrollCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  const updatePosition = callbackWrapper(\n    throttle$1(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const id = mirror2.getId(target);\n        if (target === doc && doc.defaultView) {\n          const scrollLeftTop = getWindowScroll(doc.defaultView);\n          scrollCb({\n            id,\n            x: scrollLeftTop.left,\n            y: scrollLeftTop.top\n          });\n        } else {\n          scrollCb({\n            id,\n            x: target.scrollLeft,\n            y: target.scrollTop\n          });\n        }\n      }),\n      sampling.scroll || 100\n    )\n  );\n  return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = callbackWrapper(\n    throttle$1(\n      callbackWrapper(() => {\n        const height = getWindowHeight();\n        const width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n          viewportResizeCb({\n            width: Number(width),\n            height: Number(height)\n          });\n          lastH = height;\n          lastW = width;\n        }\n      }),\n      200\n    )\n  );\n  return on(\"resize\", updateDimension, win);\n}\nconst INPUT_TAGS = [\"INPUT\", \"TEXTAREA\", \"SELECT\"];\nconst lastInputValueMap = /* @__PURE__ */ new WeakMap();\nfunction initInputObserver({\n  inputCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  ignoreClass,\n  ignoreSelector,\n  maskInputOptions,\n  maskInputFn,\n  sampling,\n  userTriggeredOnInput,\n  maskTextClass,\n  unmaskTextClass,\n  maskTextSelector,\n  unmaskTextSelector\n}) {\n  function eventHandler(event) {\n    let target = getEventTarget(event);\n    const userTriggered = event.isTrusted;\n    const tagName = target && toUpperCase(target.tagName);\n    if (tagName === \"OPTION\") target = target.parentElement;\n    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(\n      target,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      true\n    )) {\n      return;\n    }\n    const el = target;\n    if (el.classList.contains(ignoreClass) || ignoreSelector && el.matches(ignoreSelector)) {\n      return;\n    }\n    const type = getInputType(target);\n    let text = getInputValue(el, tagName, type);\n    let isChecked = false;\n    const isInputMasked = shouldMaskInput({\n      maskInputOptions,\n      tagName,\n      type\n    });\n    const forceMask = needMaskingText(\n      target,\n      maskTextClass,\n      maskTextSelector,\n      unmaskTextClass,\n      unmaskTextSelector,\n      isInputMasked\n    );\n    if (type === \"radio\" || type === \"checkbox\") {\n      isChecked = target.checked;\n    }\n    text = maskInputValue({\n      isMasked: forceMask,\n      element: target,\n      value: text,\n      maskInputFn\n    });\n    cbWithDedup(\n      target,\n      userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked }\n    );\n    const name = target.name;\n    if (type === \"radio\" && name && isChecked) {\n      doc.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`).forEach((el2) => {\n        if (el2 !== target) {\n          const text2 = maskInputValue({\n            // share mask behavior of `target`\n            isMasked: forceMask,\n            element: el2,\n            value: getInputValue(el2, tagName, type),\n            maskInputFn\n          });\n          cbWithDedup(\n            el2,\n            userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked }\n          );\n        }\n      });\n    }\n  }\n  function cbWithDedup(target, v2) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n      lastInputValueMap.set(target, v2);\n      const id = mirror2.getId(target);\n      callbackWrapper(inputCb)({\n        ...v2,\n        id\n      });\n    }\n  }\n  const events = sampling.input === \"last\" ? [\"change\"] : [\"input\", \"change\"];\n  const handlers = events.map(\n    (eventName) => on(eventName, callbackWrapper(eventHandler), doc)\n  );\n  const currentWindow = doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  }\n  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(\n    currentWindow.HTMLInputElement.prototype,\n    \"value\"\n  );\n  const hookProperties = [\n    [currentWindow.HTMLInputElement.prototype, \"value\"],\n    [currentWindow.HTMLInputElement.prototype, \"checked\"],\n    [currentWindow.HTMLSelectElement.prototype, \"value\"],\n    [currentWindow.HTMLTextAreaElement.prototype, \"value\"],\n    // Some UI library use selectedIndex to set select value\n    [currentWindow.HTMLSelectElement.prototype, \"selectedIndex\"],\n    [currentWindow.HTMLOptionElement.prototype, \"selected\"]\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map(\n        (p) => hookSetter(\n          p[0],\n          p[1],\n          {\n            set() {\n              callbackWrapper(eventHandler)({\n                target: this,\n                isTrusted: false\n                // userTriggered to false as this could well be programmatic\n              });\n            }\n          },\n          false,\n          currentWindow\n        )\n      )\n    );\n  }\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction getNestedCSSRulePositions(rule) {\n  const positions = [];\n  function recurse(childRule, pos) {\n    if (hasNestedCSSRule(\"CSSGroupingRule\") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule(\"CSSMediaRule\") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule(\"CSSSupportsRule\") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule(\"CSSConditionRule\") && childRule.parentRule instanceof CSSConditionRule) {\n      const rules2 = Array.from(\n        childRule.parentRule.cssRules\n      );\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    } else if (childRule.parentStyleSheet) {\n      const rules2 = Array.from(childRule.parentStyleSheet.cssRules);\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    }\n    return pos;\n  }\n  return recurse(rule, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n  let id, styleId;\n  if (!sheet) return {};\n  if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);\n  else styleId = styleMirror.getId(sheet);\n  return {\n    styleId,\n    id\n  };\n}\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {\n  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n    return () => {\n    };\n  }\n  const insertRule = win.CSSStyleSheet.prototype.insertRule;\n  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [rule, index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            adds: [{ rule, index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            removes: [{ index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  let replace;\n  if (win.CSSStyleSheet.prototype.replace) {\n    replace = win.CSSStyleSheet.prototype.replace;\n    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replace: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  let replaceSync;\n  if (win.CSSStyleSheet.prototype.replaceSync) {\n    replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replaceSync: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  const supportedNestedCSSRuleTypes = {};\n  if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n  const unmodifiedFunctions = {};\n  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n    unmodifiedFunctions[typeKey] = {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      insertRule: type.prototype.insertRule,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      deleteRule: type.prototype.deleteRule\n    };\n    type.prototype.insertRule = new Proxy(\n      unmodifiedFunctions[typeKey].insertRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [rule, index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                adds: [\n                  {\n                    rule,\n                    index: [\n                      ...getNestedCSSRulePositions(thisArg),\n                      index || 0\n                      // defaults to 0\n                    ]\n                  }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n    type.prototype.deleteRule = new Proxy(\n      unmodifiedFunctions[typeKey].deleteRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                removes: [\n                  { index: [...getNestedCSSRulePositions(thisArg), index] }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    replace && (win.CSSStyleSheet.prototype.replace = replace);\n    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  });\n}\nfunction initAdoptedStyleSheetObserver({\n  mirror: mirror2,\n  stylesheetManager\n}, host) {\n  let hostId = null;\n  if (host.nodeName === \"#document\") hostId = mirror2.getId(host);\n  else hostId = mirror2.getId(host.host);\n  const patchTarget = host.nodeName === \"#document\" ? host.defaultView?.Document : host.ownerDocument?.defaultView?.ShadowRoot;\n  const originalPropertyDescriptor = patchTarget?.prototype ? Object.getOwnPropertyDescriptor(\n    patchTarget?.prototype,\n    \"adoptedStyleSheets\"\n  ) : void 0;\n  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)\n    return () => {\n    };\n  Object.defineProperty(host, \"adoptedStyleSheets\", {\n    configurable: originalPropertyDescriptor.configurable,\n    enumerable: originalPropertyDescriptor.enumerable,\n    get() {\n      return originalPropertyDescriptor.get?.call(this);\n    },\n    set(sheets) {\n      const result = originalPropertyDescriptor.set?.call(this, sheets);\n      if (hostId !== null && hostId !== -1) {\n        try {\n          stylesheetManager.adoptStyleSheets(sheets, hostId);\n        } catch (e2) {\n        }\n      }\n      return result;\n    }\n  });\n  return callbackWrapper(() => {\n    Object.defineProperty(host, \"adoptedStyleSheets\", {\n      configurable: originalPropertyDescriptor.configurable,\n      enumerable: originalPropertyDescriptor.enumerable,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      get: originalPropertyDescriptor.get,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      set: originalPropertyDescriptor.set\n    });\n  });\n}\nfunction initStyleDeclarationObserver({\n  styleDeclarationCb,\n  mirror: mirror2,\n  ignoreCSSAttributes,\n  stylesheetManager\n}, { win }) {\n  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property, value, priority] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return setProperty.apply(thisArg, [property, value, priority]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            set: {\n              property,\n              value,\n              priority\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return removeProperty.apply(thisArg, [property]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            remove: {\n              property\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  });\n}\nfunction initMediaInteractionObserver({\n  mediaInteractionCb,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  mirror: mirror2,\n  sampling,\n  doc\n}) {\n  const handler = callbackWrapper(\n    (type) => throttle$1(\n      callbackWrapper((event) => {\n        const target = getEventTarget(event);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const { currentTime, volume, muted, playbackRate } = target;\n        mediaInteractionCb({\n          type,\n          id: mirror2.getId(target),\n          currentTime,\n          volume,\n          muted,\n          playbackRate\n        });\n      }),\n      sampling.media || 500\n    )\n  );\n  const handlers = [\n    on(\"play\", handler(MediaInteractions.Play), doc),\n    on(\"pause\", handler(MediaInteractions.Pause), doc),\n    on(\"seeked\", handler(MediaInteractions.Seeked), doc),\n    on(\"volumechange\", handler(MediaInteractions.VolumeChange), doc),\n    on(\"ratechange\", handler(MediaInteractions.RateChange), doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initFontObserver({ fontCb, doc }) {\n  const win = doc.defaultView;\n  if (!win) {\n    return () => {\n    };\n  }\n  const handlers = [];\n  const fontMap = /* @__PURE__ */ new WeakMap();\n  const originalFontFace = win.FontFace;\n  win.FontFace = function FontFace2(family, source, descriptors) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== \"string\",\n      descriptors,\n      fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n    });\n    return fontFace;\n  };\n  const restoreHandler = patch(\n    doc.fonts,\n    \"add\",\n    function(original) {\n      return function(fontFace) {\n        setTimeout$1(\n          callbackWrapper(() => {\n            const p = fontMap.get(fontFace);\n            if (p) {\n              fontCb(p);\n              fontMap.delete(fontFace);\n            }\n          }),\n          0\n        );\n        return original.apply(this, [fontFace]);\n      };\n    }\n  );\n  handlers.push(() => {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initSelectionObserver(param) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    selectionCb\n  } = param;\n  let collapsed = true;\n  const updateSelection = callbackWrapper(() => {\n    const selection = doc.getSelection();\n    if (!selection || collapsed && selection?.isCollapsed) return;\n    collapsed = selection.isCollapsed || false;\n    const ranges = [];\n    const count = selection.rangeCount || 0;\n    for (let i2 = 0; i2 < count; i2++) {\n      const range = selection.getRangeAt(i2);\n      const { startContainer, startOffset, endContainer, endOffset } = range;\n      const blocked = isBlocked(\n        startContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      ) || isBlocked(\n        endContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      );\n      if (blocked) continue;\n      ranges.push({\n        start: mirror2.getId(startContainer),\n        startOffset,\n        end: mirror2.getId(endContainer),\n        endOffset\n      });\n    }\n    selectionCb({ ranges });\n  });\n  updateSelection();\n  return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver({\n  doc,\n  customElementCb\n}) {\n  const win = doc.defaultView;\n  if (!win || !win.customElements) return () => {\n  };\n  const restoreHandler = patch(\n    win.customElements,\n    \"define\",\n    function(original) {\n      return function(name, constructor, options) {\n        try {\n          customElementCb({\n            define: {\n              name\n            }\n          });\n        } catch (e2) {\n        }\n        return original.apply(this, [name, constructor, options]);\n      };\n    }\n  );\n  return restoreHandler;\n}\nfunction initObservers(o2, _hooks = {}) {\n  const currentWindow = o2.doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n    };\n  }\n  let mutationObserver;\n  if (o2.recordDOM) {\n    mutationObserver = initMutationObserver(o2, o2.doc);\n  }\n  const mousemoveHandler = initMoveObserver(o2);\n  const mouseInteractionHandler = initMouseInteractionObserver(o2);\n  const scrollHandler = initScrollObserver(o2);\n  const viewportResizeHandler = initViewportResizeObserver(o2, {\n    win: currentWindow\n  });\n  const inputHandler = initInputObserver(o2);\n  const mediaInteractionHandler = initMediaInteractionObserver(o2);\n  let styleSheetObserver = () => {\n  };\n  let adoptedStyleSheetObserver = () => {\n  };\n  let styleDeclarationObserver = () => {\n  };\n  let fontObserver = () => {\n  };\n  if (o2.recordDOM) {\n    styleSheetObserver = initStyleSheetObserver(o2, { win: currentWindow });\n    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n    styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n      win: currentWindow\n    });\n    if (o2.collectFonts) {\n      fontObserver = initFontObserver(o2);\n    }\n  }\n  const selectionObserver = initSelectionObserver(o2);\n  const customElementObserver = initCustomElementObserver(o2);\n  const pluginHandlers = [];\n  for (const plugin of o2.plugins) {\n    pluginHandlers.push(\n      plugin.observer(plugin.callback, currentWindow, plugin.options)\n    );\n  }\n  return callbackWrapper(() => {\n    mutationBuffers.forEach((b) => b.reset());\n    mutationObserver?.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    adoptedStyleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    selectionObserver();\n    customElementObserver();\n    pluginHandlers.forEach((h) => h());\n  });\n}\nfunction hasNestedCSSRule(prop) {\n  return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n  return Boolean(\n    typeof window[prop] !== \"undefined\" && // Note: Generally, this check _shouldn't_ be necessary\n    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n    window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype\n  );\n}\nclass CrossOriginIframeMirror {\n  constructor(generateIdFn) {\n    this.generateIdFn = generateIdFn;\n    this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n    this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n    let id = idToRemoteIdMap.get(remoteId);\n    if (!id) {\n      id = this.generateIdFn();\n      idToRemoteIdMap.set(remoteId, id);\n      remoteIdToIdMap.set(id, remoteId);\n    }\n    return id;\n  }\n  getIds(iframe, remoteId) {\n    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return remoteId.map(\n      (id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap)\n    );\n  }\n  getRemoteId(iframe, id, map) {\n    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n    if (typeof id !== \"number\") return id;\n    const remoteId = remoteIdToIdMap.get(id);\n    if (!remoteId) return -1;\n    return remoteId;\n  }\n  getRemoteIds(iframe, ids) {\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\n  }\n  reset(iframe) {\n    if (!iframe) {\n      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n      return;\n    }\n    this.iframeIdToRemoteIdMap.delete(iframe);\n    this.iframeRemoteIdToIdMap.delete(iframe);\n  }\n  getIdToRemoteIdMap(iframe) {\n    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n    if (!idToRemoteIdMap) {\n      idToRemoteIdMap = /* @__PURE__ */ new Map();\n      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n    }\n    return idToRemoteIdMap;\n  }\n  getRemoteIdToIdMap(iframe) {\n    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n    if (!remoteIdToIdMap) {\n      remoteIdToIdMap = /* @__PURE__ */ new Map();\n      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n    }\n    return remoteIdToIdMap;\n  }\n}\nclass IframeManagerNoop {\n  constructor() {\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  addIframe() {\n  }\n  addLoadListener() {\n  }\n  attachIframe() {\n  }\n}\nclass IframeManager {\n  constructor(options) {\n    this.iframes = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n    this.mutationCb = options.mutationCb;\n    this.wrappedEmit = options.wrappedEmit;\n    this.stylesheetManager = options.stylesheetManager;\n    this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(\n      this.stylesheetManager.styleMirror.generateId.bind(\n        this.stylesheetManager.styleMirror\n      )\n    );\n    this.mirror = options.mirror;\n    if (this.recordCrossOriginIframes) {\n      window.addEventListener(\"message\", this.handleMessage.bind(this));\n    }\n  }\n  addIframe(iframeEl) {\n    this.iframes.set(iframeEl, true);\n    if (iframeEl.contentWindow)\n      this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n  }\n  addLoadListener(cb) {\n    this.loadListener = cb;\n  }\n  attachIframe(iframeEl, childSn) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: this.mirror.getId(iframeEl),\n          nextId: null,\n          node: childSn\n        }\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true\n    });\n    if (this.recordCrossOriginIframes)\n      iframeEl.contentWindow?.addEventListener(\n        \"message\",\n        this.handleMessage.bind(this)\n      );\n    this.loadListener?.(iframeEl);\n    const iframeDoc = getIFrameContentDocument(iframeEl);\n    if (iframeDoc && iframeDoc.adoptedStyleSheets && iframeDoc.adoptedStyleSheets.length > 0)\n      this.stylesheetManager.adoptStyleSheets(\n        iframeDoc.adoptedStyleSheets,\n        this.mirror.getId(iframeDoc)\n      );\n  }\n  handleMessage(message) {\n    const crossOriginMessageEvent = message;\n    if (crossOriginMessageEvent.data.type !== \"rrweb\" || // To filter out the rrweb messages which are forwarded by some sites.\n    crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\n      return;\n    const iframeSourceWindow = message.source;\n    if (!iframeSourceWindow) return;\n    const iframeEl = this.crossOriginIframeMap.get(message.source);\n    if (!iframeEl) return;\n    const transformedEvent = this.transformCrossOriginEvent(\n      iframeEl,\n      crossOriginMessageEvent.data.event\n    );\n    if (transformedEvent)\n      this.wrappedEmit(\n        transformedEvent,\n        crossOriginMessageEvent.data.isCheckout\n      );\n  }\n  transformCrossOriginEvent(iframeEl, e2) {\n    switch (e2.type) {\n      case EventType.FullSnapshot: {\n        this.crossOriginIframeMirror.reset(iframeEl);\n        this.crossOriginIframeStyleMirror.reset(iframeEl);\n        this.replaceIdOnNode(e2.data.node, iframeEl);\n        const rootId = e2.data.node.id;\n        this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n        this.patchRootIdOnNode(e2.data.node, rootId);\n        return {\n          timestamp: e2.timestamp,\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.Mutation,\n            adds: [\n              {\n                parentId: this.mirror.getId(iframeEl),\n                nextId: null,\n                node: e2.data.node\n              }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n          }\n        };\n      }\n      case EventType.Meta:\n      case EventType.Load:\n      case EventType.DomContentLoaded: {\n        return false;\n      }\n      case EventType.Plugin: {\n        return e2;\n      }\n      case EventType.Custom: {\n        this.replaceIds(\n          e2.data.payload,\n          iframeEl,\n          [\"id\", \"parentId\", \"previousId\", \"nextId\"]\n        );\n        return e2;\n      }\n      case EventType.IncrementalSnapshot: {\n        switch (e2.data.source) {\n          case IncrementalSource.Mutation: {\n            e2.data.adds.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\n                \"parentId\",\n                \"nextId\",\n                \"previousId\"\n              ]);\n              this.replaceIdOnNode(n2.node, iframeEl);\n              const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n              rootId && this.patchRootIdOnNode(n2.node, rootId);\n            });\n            e2.data.removes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"parentId\", \"id\"]);\n            });\n            e2.data.attributes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"id\"]);\n            });\n            e2.data.texts.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"id\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.Drag:\n          case IncrementalSource.TouchMove:\n          case IncrementalSource.MouseMove: {\n            e2.data.positions.forEach((p) => {\n              this.replaceIds(p, iframeEl, [\"id\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.ViewportResize: {\n            return false;\n          }\n          case IncrementalSource.MediaInteraction:\n          case IncrementalSource.MouseInteraction:\n          case IncrementalSource.Scroll:\n          case IncrementalSource.CanvasMutation:\n          case IncrementalSource.Input: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            return e2;\n          }\n          case IncrementalSource.StyleSheetRule:\n          case IncrementalSource.StyleDeclaration: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            this.replaceStyleIds(e2.data, iframeEl, [\"styleId\"]);\n            return e2;\n          }\n          case IncrementalSource.Font: {\n            return e2;\n          }\n          case IncrementalSource.Selection: {\n            e2.data.ranges.forEach((range) => {\n              this.replaceIds(range, iframeEl, [\"start\", \"end\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.AdoptedStyleSheet: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            this.replaceStyleIds(e2.data, iframeEl, [\"styleIds\"]);\n            e2.data.styles?.forEach((style) => {\n              this.replaceStyleIds(style, iframeEl, [\"styleId\"]);\n            });\n            return e2;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  replace(iframeMirror, obj, iframeEl, keys) {\n    for (const key of keys) {\n      if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n      if (Array.isArray(obj[key])) {\n        obj[key] = iframeMirror.getIds(\n          iframeEl,\n          obj[key]\n        );\n      } else {\n        obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n      }\n    }\n    return obj;\n  }\n  replaceIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n  }\n  replaceStyleIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n  }\n  replaceIdOnNode(node, iframeEl) {\n    this.replaceIds(node, iframeEl, [\"id\", \"rootId\"]);\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach((child) => {\n        this.replaceIdOnNode(child, iframeEl);\n      });\n    }\n  }\n  patchRootIdOnNode(node, rootId) {\n    if (node.type !== NodeType$2.Document && !node.rootId) node.rootId = rootId;\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach((child) => {\n        this.patchRootIdOnNode(child, rootId);\n      });\n    }\n  }\n}\nclass ShadowDomManagerNoop {\n  init() {\n  }\n  addShadowRoot() {\n  }\n  observeAttachShadow() {\n  }\n  reset() {\n  }\n}\nclass ShadowDomManager {\n  constructor(options) {\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.restoreHandlers = [];\n    this.mutationCb = options.mutationCb;\n    this.scrollCb = options.scrollCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n    this.init();\n  }\n  init() {\n    this.reset();\n    this.patchAttachShadow(Element, document);\n  }\n  addShadowRoot(shadowRoot, doc) {\n    if (!isNativeShadowDom(shadowRoot)) return;\n    if (this.shadowDoms.has(shadowRoot)) return;\n    this.shadowDoms.add(shadowRoot);\n    this.bypassOptions.canvasManager.addShadowRoot(shadowRoot);\n    const observer = initMutationObserver(\n      {\n        ...this.bypassOptions,\n        doc,\n        mutationCb: this.mutationCb,\n        mirror: this.mirror,\n        shadowDomManager: this\n      },\n      shadowRoot\n    );\n    this.restoreHandlers.push(() => observer.disconnect());\n    this.restoreHandlers.push(\n      initScrollObserver({\n        ...this.bypassOptions,\n        scrollCb: this.scrollCb,\n        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n        // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n        doc: shadowRoot,\n        mirror: this.mirror\n      })\n    );\n    setTimeout$1(() => {\n      if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0)\n        this.bypassOptions.stylesheetManager.adoptStyleSheets(\n          shadowRoot.adoptedStyleSheets,\n          this.mirror.getId(shadowRoot.host)\n        );\n      this.restoreHandlers.push(\n        initAdoptedStyleSheetObserver(\n          {\n            mirror: this.mirror,\n            stylesheetManager: this.bypassOptions.stylesheetManager\n          },\n          shadowRoot\n        )\n      );\n    }, 0);\n  }\n  /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */\n  observeAttachShadow(iframeElement) {\n    const iframeDoc = getIFrameContentDocument(iframeElement);\n    const iframeWindow = getIFrameContentWindow(iframeElement);\n    if (!iframeDoc || !iframeWindow) return;\n    this.patchAttachShadow(\n      iframeWindow.Element,\n      iframeDoc\n    );\n  }\n  /**\n   * Patch 'attachShadow' to observe newly added shadow doms.\n   */\n  patchAttachShadow(element, doc) {\n    const manager = this;\n    this.restoreHandlers.push(\n      patch(\n        element.prototype,\n        \"attachShadow\",\n        function(original) {\n          return function(option) {\n            const shadowRoot = original.call(this, option);\n            if (this.shadowRoot && inDom(this))\n              manager.addShadowRoot(this.shadowRoot, doc);\n            return shadowRoot;\n          };\n        }\n      )\n    );\n  }\n  reset() {\n    this.restoreHandlers.forEach((handler) => {\n      try {\n        handler();\n      } catch (e2) {\n      }\n    });\n    this.restoreHandlers = [];\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.bypassOptions.canvasManager.resetShadowRoots();\n  }\n}\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$1 = 0; i$1 < chars.length; i$1++) {\n  lookup[chars.charCodeAt(i$1)] = i$1;\n}\nclass CanvasManagerNoop {\n  reset() {\n  }\n  freeze() {\n  }\n  unfreeze() {\n  }\n  lock() {\n  }\n  unlock() {\n  }\n  snapshot() {\n  }\n  addWindow() {\n  }\n  addShadowRoot() {\n  }\n  resetShadowRoots() {\n  }\n}\nclass StylesheetManager {\n  constructor(options) {\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    this.styleMirror = new StyleSheetMirror();\n    this.mutationCb = options.mutationCb;\n    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n  }\n  attachLinkElement(linkEl, childSn) {\n    if (\"_cssText\" in childSn.attributes)\n      this.mutationCb({\n        adds: [],\n        removes: [],\n        texts: [],\n        attributes: [\n          {\n            id: childSn.id,\n            attributes: childSn.attributes\n          }\n        ]\n      });\n    this.trackLinkElement(linkEl);\n  }\n  trackLinkElement(linkEl) {\n    if (this.trackedLinkElements.has(linkEl)) return;\n    this.trackedLinkElements.add(linkEl);\n    this.trackStylesheetInLinkElement(linkEl);\n  }\n  adoptStyleSheets(sheets, hostId) {\n    if (sheets.length === 0) return;\n    const adoptedStyleSheetData = {\n      id: hostId,\n      styleIds: []\n    };\n    const styles = [];\n    for (const sheet of sheets) {\n      let styleId;\n      if (!this.styleMirror.has(sheet)) {\n        styleId = this.styleMirror.add(sheet);\n        styles.push({\n          styleId,\n          rules: Array.from(sheet.rules || CSSRule, (r2, index) => ({\n            rule: stringifyRule(r2),\n            index\n          }))\n        });\n      } else styleId = this.styleMirror.getId(sheet);\n      adoptedStyleSheetData.styleIds.push(styleId);\n    }\n    if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n    this.adoptedStyleSheetCb(adoptedStyleSheetData);\n  }\n  reset() {\n    this.styleMirror.reset();\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n  }\n  // TODO: take snapshot on stylesheet reload by applying event listener\n  trackStylesheetInLinkElement(_linkEl) {\n  }\n}\nclass ProcessedNodeManager {\n  constructor() {\n    this.nodeMap = /* @__PURE__ */ new WeakMap();\n    this.active = false;\n  }\n  inOtherBuffer(node, thisBuffer) {\n    const buffers = this.nodeMap.get(node);\n    return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);\n  }\n  add(node, buffer) {\n    if (!this.active) {\n      this.active = true;\n      onRequestAnimationFrame(() => {\n        this.nodeMap = /* @__PURE__ */ new WeakMap();\n        this.active = false;\n      });\n    }\n    this.nodeMap.set(node, (this.nodeMap.get(node) || /* @__PURE__ */ new Set()).add(buffer));\n  }\n  destroy() {\n  }\n}\nlet wrappedEmit;\nlet _takeFullSnapshot;\ntry {\n  if (Array.from([1], (x) => x * 2)[0] !== 2) {\n    const cleanFrame = document.createElement(\"iframe\");\n    document.body.appendChild(cleanFrame);\n    Array.from = cleanFrame.contentWindow?.Array.from || Array.from;\n    document.body.removeChild(cleanFrame);\n  }\n} catch (err) {\n  console.debug(\"Unable to override Array.from\", err);\n}\nconst mirror = createMirror$2();\nfunction record(options = {}) {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    ignoreClass = \"rr-ignore\",\n    ignoreSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskAttributeFn,\n    maskInputFn,\n    maskTextFn,\n    maxCanvasSize = null,\n    packFn,\n    sampling = {},\n    dataURLOptions = {},\n    mousemoveWait,\n    recordDOM = true,\n    recordCanvas = false,\n    recordCrossOriginIframes = false,\n    recordAfter = options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\",\n    userTriggeredOnInput = false,\n    collectFonts = false,\n    inlineImages = false,\n    plugins,\n    keepIframeSrcFn = () => false,\n    ignoreCSSAttributes = /* @__PURE__ */ new Set([]),\n    errorHandler: errorHandler2,\n    onMutation,\n    getCanvasManager\n  } = options;\n  registerErrorHandler(errorHandler2);\n  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n  let passEmitsToParent = false;\n  if (!inEmittingFrame) {\n    try {\n      if (window.parent.document) {\n        passEmitsToParent = false;\n      }\n    } catch (e2) {\n      passEmitsToParent = true;\n    }\n  }\n  if (inEmittingFrame && !emit) {\n    throw new Error(\"emit function is required\");\n  }\n  if (!inEmittingFrame && !passEmitsToParent) {\n    return () => {\n    };\n  }\n  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n    sampling.mousemove = mousemoveWait;\n  }\n  mirror.reset();\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true,\n    radio: true,\n    checkbox: true\n  } : _maskInputOptions !== void 0 ? _maskInputOptions : {};\n  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaVerification: true,\n    // the following are off for slimDOMOptions === true,\n    // as they destroy some (hidden) info:\n    headMetaAuthorship: _slimDOMOptions === \"all\",\n    headMetaDescKeywords: _slimDOMOptions === \"all\"\n  } : _slimDOMOptions ? _slimDOMOptions : {};\n  polyfill$1();\n  let lastFullSnapshotEvent;\n  let incrementalSnapshotCount = 0;\n  const eventProcessor = (e2) => {\n    for (const plugin of plugins || []) {\n      if (plugin.eventProcessor) {\n        e2 = plugin.eventProcessor(e2);\n      }\n    }\n    if (packFn && // Disable packing events which will be emitted to parent frames.\n    !passEmitsToParent) {\n      e2 = packFn(e2);\n    }\n    return e2;\n  };\n  wrappedEmit = (r2, isCheckout) => {\n    const e2 = r2;\n    e2.timestamp = nowTimestamp();\n    if (mutationBuffers[0]?.isFrozen() && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n    if (inEmittingFrame) {\n      emit?.(eventProcessor(e2), isCheckout);\n    } else if (passEmitsToParent) {\n      const message = {\n        type: \"rrweb\",\n        event: eventProcessor(e2),\n        origin: window.location.origin,\n        isCheckout\n      };\n      window.parent.postMessage(message, \"*\");\n    }\n    if (e2.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e2;\n      incrementalSnapshotCount = 0;\n    } else if (e2.type === EventType.IncrementalSnapshot) {\n      if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n        return;\n      }\n      incrementalSnapshotCount++;\n      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime = checkoutEveryNms && lastFullSnapshotEvent && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot2(true);\n      }\n    }\n  };\n  const wrappedMutationEmit = (m) => {\n    wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.Mutation,\n        ...m\n      }\n    });\n  };\n  const wrappedScrollEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.Scroll,\n      ...p\n    }\n  });\n  const wrappedCanvasMutationEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.CanvasMutation,\n      ...p\n    }\n  });\n  const wrappedAdoptedStyleSheetEmit = (a2) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.AdoptedStyleSheet,\n      ...a2\n    }\n  });\n  const stylesheetManager = new StylesheetManager({\n    mutationCb: wrappedMutationEmit,\n    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n  });\n  const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === \"boolean\" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({\n    mirror,\n    mutationCb: wrappedMutationEmit,\n    stylesheetManager,\n    recordCrossOriginIframes,\n    wrappedEmit\n  });\n  for (const plugin of plugins || []) {\n    if (plugin.getMirror)\n      plugin.getMirror({\n        nodeMirror: mirror,\n        crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n        crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n      });\n  }\n  const processedNodeManager = new ProcessedNodeManager();\n  const canvasManager = _getCanvasManager(\n    getCanvasManager,\n    {\n      mirror,\n      win: window,\n      mutationCb: (p) => wrappedEmit({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.CanvasMutation,\n          ...p\n        }\n      }),\n      recordCanvas,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      sampling: sampling[\"canvas\"],\n      dataURLOptions,\n      errorHandler: errorHandler2\n    }\n  );\n  const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === \"boolean\" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    scrollCb: wrappedScrollEmit,\n    bypassOptions: {\n      onMutation,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      dataURLOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      recordCanvas,\n      inlineImages,\n      sampling,\n      slimDOMOptions,\n      iframeManager,\n      stylesheetManager,\n      canvasManager,\n      keepIframeSrcFn,\n      processedNodeManager\n    },\n    mirror\n  });\n  const takeFullSnapshot2 = (isCheckout = false) => {\n    if (!recordDOM) {\n      return;\n    }\n    wrappedEmit(\n      {\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight()\n        }\n      },\n      isCheckout\n    );\n    stylesheetManager.reset();\n    shadowDomManager.init();\n    mutationBuffers.forEach((buf) => buf.lock());\n    const node = snapshot(document, {\n      mirror,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskAttributeFn,\n      maskInputFn,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      dataURLOptions,\n      recordCanvas,\n      inlineImages,\n      onSerialize: (n2) => {\n        if (isSerializedIframe(n2, mirror)) {\n          iframeManager.addIframe(n2);\n        }\n        if (isSerializedStylesheet(n2, mirror)) {\n          stylesheetManager.trackLinkElement(n2);\n        }\n        if (hasShadowRoot(n2)) {\n          shadowDomManager.addShadowRoot(n2.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n        if (iframe.contentWindow) {\n          canvasManager.addWindow(iframe.contentWindow);\n        }\n        shadowDomManager.observeAttachShadow(iframe);\n      },\n      onStylesheetLoad: (linkEl, childSn) => {\n        stylesheetManager.attachLinkElement(linkEl, childSn);\n      },\n      keepIframeSrcFn\n    });\n    if (!node) {\n      return console.warn(\"Failed to snapshot the document\");\n    }\n    wrappedEmit({\n      type: EventType.FullSnapshot,\n      data: {\n        node,\n        initialOffset: getWindowScroll(window)\n      }\n    });\n    mutationBuffers.forEach((buf) => buf.unlock());\n    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\n      stylesheetManager.adoptStyleSheets(\n        document.adoptedStyleSheets,\n        mirror.getId(document)\n      );\n  };\n  _takeFullSnapshot = takeFullSnapshot2;\n  try {\n    const handlers = [];\n    const observe = (doc) => {\n      return callbackWrapper(initObservers)(\n        {\n          onMutation,\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source,\n              positions\n            }\n          }),\n          mouseInteractionCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MouseInteraction,\n              ...d\n            }\n          }),\n          scrollCb: wrappedScrollEmit,\n          viewportResizeCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.ViewportResize,\n              ...d\n            }\n          }),\n          inputCb: (v2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Input,\n              ...v2\n            }\n          }),\n          mediaInteractionCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MediaInteraction,\n              ...p\n            }\n          }),\n          styleSheetRuleCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleSheetRule,\n              ...r2\n            }\n          }),\n          styleDeclarationCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleDeclaration,\n              ...r2\n            }\n          }),\n          canvasMutationCb: wrappedCanvasMutationEmit,\n          fontCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Font,\n              ...p\n            }\n          }),\n          selectionCb: (p) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.Selection,\n                ...p\n              }\n            });\n          },\n          customElementCb: (c2) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.CustomElement,\n                ...c2\n              }\n            });\n          },\n          blockClass,\n          ignoreClass,\n          ignoreSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordDOM,\n          recordCanvas,\n          inlineImages,\n          userTriggeredOnInput,\n          collectFonts,\n          doc,\n          maskAttributeFn,\n          maskInputFn,\n          maskTextFn,\n          keepIframeSrcFn,\n          blockSelector,\n          unblockSelector,\n          slimDOMOptions,\n          dataURLOptions,\n          mirror,\n          iframeManager,\n          stylesheetManager,\n          shadowDomManager,\n          processedNodeManager,\n          canvasManager,\n          ignoreCSSAttributes,\n          plugins: plugins?.filter((p) => p.observer)?.map((p) => ({\n            observer: p.observer,\n            options: p.options,\n            callback: (payload) => wrappedEmit({\n              type: EventType.Plugin,\n              data: {\n                plugin: p.name,\n                payload\n              }\n            })\n          })) || []\n        },\n        {}\n      );\n    };\n    iframeManager.addLoadListener((iframeEl) => {\n      try {\n        handlers.push(observe(iframeEl.contentDocument));\n      } catch (error) {\n        console.warn(error);\n      }\n    });\n    const init = () => {\n      takeFullSnapshot2();\n      handlers.push(observe(document));\n    };\n    if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n      init();\n    } else {\n      handlers.push(\n        on(\"DOMContentLoaded\", () => {\n          wrappedEmit({\n            type: EventType.DomContentLoaded,\n            data: {}\n          });\n          if (recordAfter === \"DOMContentLoaded\") init();\n        })\n      );\n      handlers.push(\n        on(\n          \"load\",\n          () => {\n            wrappedEmit({\n              type: EventType.Load,\n              data: {}\n            });\n            if (recordAfter === \"load\") init();\n          },\n          window\n        )\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n      processedNodeManager.destroy();\n      _takeFullSnapshot = void 0;\n      unregisterErrorHandler();\n    };\n  } catch (error) {\n    console.warn(error);\n  }\n}\nfunction takeFullSnapshot(isCheckout) {\n  if (!_takeFullSnapshot) {\n    throw new Error(\"please take full snapshot after start recording\");\n  }\n  _takeFullSnapshot(isCheckout);\n}\nrecord.mirror = mirror;\nrecord.takeFullSnapshot = takeFullSnapshot;\nfunction _getCanvasManager(getCanvasManagerFn, options) {\n  try {\n    return getCanvasManagerFn ? getCanvasManagerFn(options) : new CanvasManagerNoop();\n  } catch {\n    console.warn(\"Unable to initialize CanvasManager\");\n    return new CanvasManagerNoop();\n  }\n}\nvar n;\n!function(t2) {\n  t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\n\nconst ReplayEventTypeIncrementalSnapshot = 3;\nconst ReplayEventTypeCustom = 5;\n\n/**\n * Converts a timestamp to ms, if it was in s, or keeps it as ms.\n */\nfunction timestampToMs(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp : timestamp * 1000;\n}\n\n/**\n * Converts a timestamp to s, if it was in ms, or keeps it as s.\n */\nfunction timestampToS(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Add a breadcrumb event to replay.\n */\nfunction addBreadcrumbEvent(replay, breadcrumb) {\n  if (breadcrumb.category === 'sentry.transaction') {\n    return;\n  }\n\n  if (['ui.click', 'ui.input'].includes(breadcrumb.category )) {\n    replay.triggerUserActivity();\n  } else {\n    replay.checkAndHandleExpiredSession();\n  }\n\n  replay.addUpdate(() => {\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      // TODO: We were converting from ms to seconds for breadcrumbs, spans,\n      // but maybe we should just keep them as milliseconds\n      timestamp: (breadcrumb.timestamp || 0) * 1000,\n      data: {\n        tag: 'breadcrumb',\n        // normalize to max. 10 depth and 1_000 properties per object\n        payload: normalize(breadcrumb, 10, 1000),\n      },\n    });\n\n    // Do not flush after console log messages\n    return breadcrumb.category === 'console';\n  });\n}\n\nconst INTERACTIVE_SELECTOR = 'button,a';\n\n/** Get the closest interactive parent element, or else return the given element. */\nfunction getClosestInteractive(element) {\n  const closestInteractive = element.closest(INTERACTIVE_SELECTOR);\n  return closestInteractive || element;\n}\n\n/**\n * For clicks, we check if the target is inside of a button or link\n * If so, we use this as the target instead\n * This is useful because if you click on the image in <button><img></button>,\n * The target will be the image, not the button, which we don't want here\n */\nfunction getClickTargetNode(event) {\n  const target = getTargetNode(event);\n\n  if (!target || !(target instanceof Element)) {\n    return target;\n  }\n\n  return getClosestInteractive(target);\n}\n\n/** Get the event target node. */\nfunction getTargetNode(event) {\n  if (isEventWithTarget(event)) {\n    return event.target ;\n  }\n\n  return event;\n}\n\nfunction isEventWithTarget(event) {\n  return typeof event === 'object' && !!event && 'target' in event;\n}\n\nlet handlers;\n\n/**\n * Register a handler to be called when `window.open()` is called.\n * Returns a cleanup function.\n */\nfunction onWindowOpen(cb) {\n  // Ensure to only register this once\n  if (!handlers) {\n    handlers = [];\n    monkeyPatchWindowOpen();\n  }\n\n  handlers.push(cb);\n\n  return () => {\n    const pos = handlers ? handlers.indexOf(cb) : -1;\n    if (pos > -1) {\n      (handlers ).splice(pos, 1);\n    }\n  };\n}\n\nfunction monkeyPatchWindowOpen() {\n  fill(WINDOW, 'open', function (originalWindowOpen) {\n    return function (...args) {\n      if (handlers) {\n        try {\n          handlers.forEach(handler => handler());\n        } catch (e) {\n          // ignore errors in here\n        }\n      }\n\n      return originalWindowOpen.apply(WINDOW, args);\n    };\n  });\n}\n\n/** Any IncrementalSource for rrweb that we interpret as a kind of mutation. */\nconst IncrementalMutationSources = new Set([\n  IncrementalSource.Mutation,\n  IncrementalSource.StyleSheetRule,\n  IncrementalSource.StyleDeclaration,\n  IncrementalSource.AdoptedStyleSheet,\n  IncrementalSource.CanvasMutation,\n  IncrementalSource.Selection,\n  IncrementalSource.MediaInteraction,\n]);\n\n/** Handle a click. */\nfunction handleClick(clickDetector, clickBreadcrumb, node) {\n  clickDetector.handleClick(clickBreadcrumb, node);\n}\n\n/** A click detector class that can be used to detect slow or rage clicks on elements. */\nclass ClickDetector  {\n  // protected for testing\n\n   constructor(\n    replay,\n    slowClickConfig,\n    // Just for easier testing\n    _addBreadcrumbEvent = addBreadcrumbEvent,\n  ) {\n    this._lastMutation = 0;\n    this._lastScroll = 0;\n    this._clicks = [];\n\n    // We want everything in s, but options are in ms\n    this._timeout = slowClickConfig.timeout / 1000;\n    this._threshold = slowClickConfig.threshold / 1000;\n    this._scrollTimeout = slowClickConfig.scrollTimeout / 1000;\n    this._replay = replay;\n    this._ignoreSelector = slowClickConfig.ignoreSelector;\n    this._addBreadcrumbEvent = _addBreadcrumbEvent;\n  }\n\n  /** Register click detection handlers on mutation or scroll. */\n   addListeners() {\n    const cleanupWindowOpen = onWindowOpen(() => {\n      // Treat window.open as mutation\n      this._lastMutation = nowInSeconds();\n    });\n\n    this._teardown = () => {\n      cleanupWindowOpen();\n\n      this._clicks = [];\n      this._lastMutation = 0;\n      this._lastScroll = 0;\n    };\n  }\n\n  /** Clean up listeners. */\n   removeListeners() {\n    if (this._teardown) {\n      this._teardown();\n    }\n\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n  }\n\n  /** @inheritDoc */\n   handleClick(breadcrumb, node) {\n    if (ignoreElement(node, this._ignoreSelector) || !isClickBreadcrumb(breadcrumb)) {\n      return;\n    }\n\n    const newClick = {\n      timestamp: timestampToS(breadcrumb.timestamp),\n      clickBreadcrumb: breadcrumb,\n      // Set this to 0 so we know it originates from the click breadcrumb\n      clickCount: 0,\n      node,\n    };\n\n    // If there was a click in the last 1s on the same element, ignore it - only keep a single reference per second\n    if (\n      this._clicks.some(click => click.node === newClick.node && Math.abs(click.timestamp - newClick.timestamp) < 1)\n    ) {\n      return;\n    }\n\n    this._clicks.push(newClick);\n\n    // If this is the first new click, set a timeout to check for multi clicks\n    if (this._clicks.length === 1) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** @inheritDoc */\n   registerMutation(timestamp = Date.now()) {\n    this._lastMutation = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n   registerScroll(timestamp = Date.now()) {\n    this._lastScroll = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n   registerClick(element) {\n    const node = getClosestInteractive(element);\n    this._handleMultiClick(node );\n  }\n\n  /** Count multiple clicks on elements. */\n   _handleMultiClick(node) {\n    this._getClicks(node).forEach(click => {\n      click.clickCount++;\n    });\n  }\n\n  /** Get all pending clicks for a given node. */\n   _getClicks(node) {\n    return this._clicks.filter(click => click.node === node);\n  }\n\n  /** Check the clicks that happened. */\n   _checkClicks() {\n    const timedOutClicks = [];\n\n    const now = nowInSeconds();\n\n    this._clicks.forEach(click => {\n      if (!click.mutationAfter && this._lastMutation) {\n        click.mutationAfter = click.timestamp <= this._lastMutation ? this._lastMutation - click.timestamp : undefined;\n      }\n      if (!click.scrollAfter && this._lastScroll) {\n        click.scrollAfter = click.timestamp <= this._lastScroll ? this._lastScroll - click.timestamp : undefined;\n      }\n\n      // All of these are in seconds!\n      if (click.timestamp + this._timeout <= now) {\n        timedOutClicks.push(click);\n      }\n    });\n\n    // Remove \"old\" clicks\n    for (const click of timedOutClicks) {\n      const pos = this._clicks.indexOf(click);\n\n      if (pos > -1) {\n        this._generateBreadcrumbs(click);\n        this._clicks.splice(pos, 1);\n      }\n    }\n\n    // Trigger new check, unless no clicks left\n    if (this._clicks.length) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** Generate matching breadcrumb(s) for the click. */\n   _generateBreadcrumbs(click) {\n    const replay = this._replay;\n    const hadScroll = click.scrollAfter && click.scrollAfter <= this._scrollTimeout;\n    const hadMutation = click.mutationAfter && click.mutationAfter <= this._threshold;\n\n    const isSlowClick = !hadScroll && !hadMutation;\n    const { clickCount, clickBreadcrumb } = click;\n\n    // Slow click\n    if (isSlowClick) {\n      // If `mutationAfter` is set, it means a mutation happened after the threshold, but before the timeout\n      // If not, it means we just timed out without scroll & mutation\n      const timeAfterClickMs = Math.min(click.mutationAfter || this._timeout, this._timeout) * 1000;\n      const endReason = timeAfterClickMs < this._timeout * 1000 ? 'mutation' : 'timeout';\n\n      const breadcrumb = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.slowClickDetected',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          timeAfterClickMs,\n          endReason,\n          // If clickCount === 0, it means multiClick was not correctly captured here\n          // - we still want to send 1 in this case\n          clickCount: clickCount || 1,\n        },\n      };\n\n      this._addBreadcrumbEvent(replay, breadcrumb);\n      return;\n    }\n\n    // Multi click\n    if (clickCount > 1) {\n      const breadcrumb = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.multiClick',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          clickCount,\n          metric: true,\n        },\n      };\n\n      this._addBreadcrumbEvent(replay, breadcrumb);\n    }\n  }\n\n  /** Schedule to check current clicks. */\n   _scheduleCheckClicks() {\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n\n    this._checkClickTimeout = setTimeout$3(() => this._checkClicks(), 1000);\n  }\n}\n\nconst SLOW_CLICK_TAGS = ['A', 'BUTTON', 'INPUT'];\n\n/** exported for tests only */\nfunction ignoreElement(node, ignoreSelector) {\n  if (!SLOW_CLICK_TAGS.includes(node.tagName)) {\n    return true;\n  }\n\n  // If <input> tag, we only want to consider input[type='submit'] & input[type='button']\n  if (node.tagName === 'INPUT' && !['submit', 'button'].includes(node.getAttribute('type') || '')) {\n    return true;\n  }\n\n  // If <a> tag, detect special variants that may not lead to an action\n  // If target !== _self, we may open the link somewhere else, which would lead to no action\n  // Also, when downloading a file, we may not leave the page, but still not trigger an action\n  if (\n    node.tagName === 'A' &&\n    (node.hasAttribute('download') || (node.hasAttribute('target') && node.getAttribute('target') !== '_self'))\n  ) {\n    return true;\n  }\n\n  if (ignoreSelector && node.matches(ignoreSelector)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isClickBreadcrumb(breadcrumb) {\n  return !!(breadcrumb.data && typeof breadcrumb.data.nodeId === 'number' && breadcrumb.timestamp);\n}\n\n// This is good enough for us, and is easier to test/mock than `timestampInSeconds`\nfunction nowInSeconds() {\n  return Date.now() / 1000;\n}\n\n/** Update the click detector based on a recording event of rrweb. */\nfunction updateClickDetectorForRecordingEvent(clickDetector, event) {\n  try {\n    // note: We only consider incremental snapshots here\n    // This means that any full snapshot is ignored for mutation detection - the reason is that we simply cannot know if a mutation happened here.\n    // E.g. think that we are buffering, an error happens and we take a full snapshot because we switched to session mode -\n    // in this scenario, we would not know if a dead click happened because of the error, which is a key dead click scenario.\n    // Instead, by ignoring full snapshots, we have the risk that we generate a false positive\n    // (if a mutation _did_ happen but was \"swallowed\" by the full snapshot)\n    // But this should be more unlikely as we'd generally capture the incremental snapshot right away\n\n    if (!isIncrementalEvent(event)) {\n      return;\n    }\n\n    const { source } = event.data;\n    if (IncrementalMutationSources.has(source)) {\n      clickDetector.registerMutation(event.timestamp);\n    }\n\n    if (source === IncrementalSource.Scroll) {\n      clickDetector.registerScroll(event.timestamp);\n    }\n\n    if (isIncrementalMouseInteraction(event)) {\n      const { type, id } = event.data;\n      const node = record.mirror.getNode(id);\n\n      if (node instanceof HTMLElement && type === MouseInteractions.Click) {\n        clickDetector.registerClick(node);\n      }\n    }\n  } catch {\n    // ignore errors here, e.g. if accessing something that does not exist\n  }\n}\n\nfunction isIncrementalEvent(event) {\n  return event.type === ReplayEventTypeIncrementalSnapshot;\n}\n\nfunction isIncrementalMouseInteraction(\n  event,\n) {\n  return event.data.source === IncrementalSource.MouseInteraction;\n}\n\n/**\n * Create a breadcrumb for a replay.\n */\nfunction createBreadcrumb(\n  breadcrumb,\n) {\n  return {\n    timestamp: Date.now() / 1000,\n    type: 'default',\n    ...breadcrumb,\n  };\n}\n\nvar NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType || {});\n\n// Note that these are the serialized attributes and not attributes directly on\n// the DOM Node. Attributes we are interested in:\nconst ATTRIBUTES_TO_RECORD = new Set([\n  'id',\n  'class',\n  'aria-label',\n  'role',\n  'name',\n  'alt',\n  'title',\n  'data-test-id',\n  'data-testid',\n  'disabled',\n  'aria-disabled',\n  'data-sentry-component',\n]);\n\n/**\n * Inclusion list of attributes that we want to record from the DOM element\n */\nfunction getAttributesToRecord(attributes) {\n  const obj = {};\n  if (!attributes['data-sentry-component'] && attributes['data-sentry-element']) {\n    attributes['data-sentry-component'] = attributes['data-sentry-element'];\n  }\n  for (const key in attributes) {\n    if (ATTRIBUTES_TO_RECORD.has(key)) {\n      let normalizedKey = key;\n\n      if (key === 'data-testid' || key === 'data-test-id') {\n        normalizedKey = 'testId';\n      }\n\n      obj[normalizedKey] = attributes[key];\n    }\n  }\n\n  return obj;\n}\n\nconst handleDomListener = (\n  replay,\n) => {\n  return (handlerData) => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleDom(handlerData);\n\n    if (!result) {\n      return;\n    }\n\n    const isClick = handlerData.name === 'click';\n    const event = isClick ? (handlerData.event ) : undefined;\n    // Ignore clicks if ctrl/alt/meta/shift keys are held down as they alter behavior of clicks (e.g. open in new tab)\n    if (\n      isClick &&\n      replay.clickDetector &&\n      event &&\n      event.target &&\n      !event.altKey &&\n      !event.metaKey &&\n      !event.ctrlKey &&\n      !event.shiftKey\n    ) {\n      handleClick(\n        replay.clickDetector,\n        result ,\n        getClickTargetNode(handlerData.event ) ,\n      );\n    }\n\n    addBreadcrumbEvent(replay, result);\n  };\n};\n\n/** Get the base DOM breadcrumb. */\nfunction getBaseDomBreadcrumb(target, message) {\n  const nodeId = record.mirror.getId(target);\n  const node = nodeId && record.mirror.getNode(nodeId);\n  const meta = node && record.mirror.getMeta(node);\n  const element = meta && isElement(meta) ? meta : null;\n\n  return {\n    message,\n    data: element\n      ? {\n          nodeId,\n          node: {\n            id: nodeId,\n            tagName: element.tagName,\n            textContent: Array.from(element.childNodes)\n              .map((node) => node.type === NodeType.Text && node.textContent)\n              .filter(Boolean) // filter out empty values\n              .map(text => (text ).trim())\n              .join(''),\n            attributes: getAttributesToRecord(element.attributes),\n          },\n        }\n      : {},\n  };\n}\n\n/**\n * An event handler to react to DOM events.\n * Exported for tests.\n */\nfunction handleDom(handlerData) {\n  const { target, message } = getDomTarget(handlerData);\n\n  return createBreadcrumb({\n    category: `ui.${handlerData.name}`,\n    ...getBaseDomBreadcrumb(target, message),\n  });\n}\n\nfunction getDomTarget(handlerData) {\n  const isClick = handlerData.name === 'click';\n\n  let message;\n  let target = null;\n\n  // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n  try {\n    target = isClick ? getClickTargetNode(handlerData.event ) : getTargetNode(handlerData.event );\n    message = htmlTreeAsString(target, { maxStringLength: 200 }) || '<unknown>';\n  } catch (e) {\n    message = '<unknown>';\n  }\n\n  return { target, message };\n}\n\nfunction isElement(node) {\n  return node.type === NodeType.Element;\n}\n\n/** Handle keyboard events & create breadcrumbs. */\nfunction handleKeyboardEvent(replay, event) {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  // Update user activity, but do not restart recording as it can create\n  // noisy/low-value replays (e.g. user comes back from idle, hits alt-tab, new\n  // session with a single \"keydown\" breadcrumb is created)\n  replay.updateUserActivity();\n\n  const breadcrumb = getKeyboardBreadcrumb(event);\n\n  if (!breadcrumb) {\n    return;\n  }\n\n  addBreadcrumbEvent(replay, breadcrumb);\n}\n\n/** exported only for tests */\nfunction getKeyboardBreadcrumb(event) {\n  const { metaKey, shiftKey, ctrlKey, altKey, key, target } = event;\n\n  // never capture for input fields\n  if (!target || isInputElement(target ) || !key) {\n    return null;\n  }\n\n  // Note: We do not consider shift here, as that means \"uppercase\"\n  const hasModifierKey = metaKey || ctrlKey || altKey;\n  const isCharacterKey = key.length === 1; // other keys like Escape, Tab, etc have a longer length\n\n  // Do not capture breadcrumb if only a word key is pressed\n  // This could leak e.g. user input\n  if (!hasModifierKey && isCharacterKey) {\n    return null;\n  }\n\n  const message = htmlTreeAsString(target, { maxStringLength: 200 }) || '<unknown>';\n  const baseBreadcrumb = getBaseDomBreadcrumb(target , message);\n\n  return createBreadcrumb({\n    category: 'ui.keyDown',\n    message,\n    data: {\n      ...baseBreadcrumb.data,\n      metaKey,\n      shiftKey,\n      ctrlKey,\n      altKey,\n      key,\n    },\n  });\n}\n\nfunction isInputElement(target) {\n  return target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;\n}\n\n// Map entryType -> function to normalize data for event\nconst ENTRY_TYPES\n\n = {\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  resource: createResourceEntry,\n  paint: createPaintEntry,\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  navigation: createNavigationEntry,\n};\n\n/**\n * Handler creater for web vitals\n */\nfunction webVitalHandler(\n  getter,\n  replay,\n) {\n  return ({ metric }) => void replay.replayPerformanceEntries.push(getter(metric));\n}\n\n/**\n * Create replay performance entries from the browser performance entries.\n */\nfunction createPerformanceEntries(\n  entries,\n) {\n  return entries.map(createPerformanceEntry).filter(Boolean) ;\n}\n\nfunction createPerformanceEntry(entry) {\n  const entryType = ENTRY_TYPES[entry.entryType];\n  if (!entryType) {\n    return null;\n  }\n\n  return entryType(entry);\n}\n\nfunction getAbsoluteTime(time) {\n  // browserPerformanceTimeOrigin can be undefined if `performance` or\n  // `performance.now` doesn't exist, but this is already checked by this integration\n  return ((browserPerformanceTimeOrigin() || WINDOW.performance.timeOrigin) + time) / 1000;\n}\n\nfunction createPaintEntry(entry) {\n  const { duration, entryType, name, startTime } = entry;\n\n  const start = getAbsoluteTime(startTime);\n  return {\n    type: entryType,\n    name,\n    start,\n    end: start + duration,\n    data: undefined,\n  };\n}\n\nfunction createNavigationEntry(entry) {\n  const {\n    entryType,\n    name,\n    decodedBodySize,\n    duration,\n    domComplete,\n    encodedBodySize,\n    domContentLoadedEventStart,\n    domContentLoadedEventEnd,\n    domInteractive,\n    loadEventStart,\n    loadEventEnd,\n    redirectCount,\n    startTime,\n    transferSize,\n    type,\n  } = entry;\n\n  // Ignore entries with no duration, they do not seem to be useful and cause dupes\n  if (duration === 0) {\n    return null;\n  }\n\n  return {\n    type: `${entryType}.${type}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(domComplete),\n    name,\n    data: {\n      size: transferSize,\n      decodedBodySize,\n      encodedBodySize,\n      duration,\n      domInteractive,\n      domContentLoadedEventStart,\n      domContentLoadedEventEnd,\n      loadEventStart,\n      loadEventEnd,\n      domComplete,\n      redirectCount,\n    },\n  };\n}\n\nfunction createResourceEntry(\n  entry,\n) {\n  const {\n    entryType,\n    initiatorType,\n    name,\n    responseEnd,\n    startTime,\n    decodedBodySize,\n    encodedBodySize,\n    responseStatus,\n    transferSize,\n  } = entry;\n\n  // Core SDK handles these\n  if (['fetch', 'xmlhttprequest'].includes(initiatorType)) {\n    return null;\n  }\n\n  return {\n    type: `${entryType}.${initiatorType}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(responseEnd),\n    name,\n    data: {\n      size: transferSize,\n      statusCode: responseStatus,\n      decodedBodySize,\n      encodedBodySize,\n    },\n  };\n}\n\n/**\n * Add a LCP event to the replay based on a LCP metric.\n */\nfunction getLargestContentfulPaint(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1] ;\n  const node = lastEntry?.element ? [lastEntry.element] : undefined;\n  return getWebVital(metric, 'largest-contentful-paint', node);\n}\n\nfunction isLayoutShift(entry) {\n  return (entry ).sources !== undefined;\n}\n\n/**\n * Add a CLS event to the replay based on a CLS metric.\n */\nfunction getCumulativeLayoutShift(metric) {\n  const layoutShifts = [];\n  const nodes = [];\n  for (const entry of metric.entries) {\n    if (isLayoutShift(entry)) {\n      const nodeIds = [];\n      for (const source of entry.sources) {\n        if (source.node) {\n          nodes.push(source.node);\n          const nodeId = record.mirror.getId(source.node);\n          if (nodeId) {\n            nodeIds.push(nodeId);\n          }\n        }\n      }\n      layoutShifts.push({ value: entry.value, nodeIds: nodeIds.length ? nodeIds : undefined });\n    }\n  }\n\n  return getWebVital(metric, 'cumulative-layout-shift', nodes, layoutShifts);\n}\n\n/**\n * Add a FID event to the replay based on a FID metric.\n */\nfunction getFirstInputDelay(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1] ;\n  const node = lastEntry?.target ? [lastEntry.target] : undefined;\n  return getWebVital(metric, 'first-input-delay', node);\n}\n\n/**\n * Add an INP event to the replay based on an INP metric.\n */\nfunction getInteractionToNextPaint(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1] ;\n  const node = lastEntry?.target ? [lastEntry.target] : undefined;\n  return getWebVital(metric, 'interaction-to-next-paint', node);\n}\n\n/**\n * Add an web vital event to the replay based on the web vital metric.\n */\nfunction getWebVital(\n  metric,\n  name,\n  nodes,\n  attributions,\n) {\n  const value = metric.value;\n  const rating = metric.rating;\n\n  const end = getAbsoluteTime(value);\n\n  return {\n    type: 'web-vital',\n    name,\n    start: end,\n    end,\n    data: {\n      value,\n      size: value,\n      rating,\n      nodeIds: nodes ? nodes.map(node => record.mirror.getId(node)) : undefined,\n      attributions,\n    },\n  };\n}\n\n/**\n * Sets up a PerformanceObserver to listen to all performance entry types.\n * Returns a callback to stop observing.\n */\nfunction setupPerformanceObserver(replay) {\n  function addPerformanceEntry(entry) {\n    // It is possible for entries to come up multiple times\n    if (!replay.performanceEntries.includes(entry)) {\n      replay.performanceEntries.push(entry);\n    }\n  }\n\n  function onEntries({ entries }) {\n    entries.forEach(addPerformanceEntry);\n  }\n\n  const clearCallbacks = [];\n\n  (['navigation', 'paint', 'resource'] ).forEach(type => {\n    clearCallbacks.push(addPerformanceInstrumentationHandler(type, onEntries));\n  });\n\n  clearCallbacks.push(\n    addLcpInstrumentationHandler(webVitalHandler(getLargestContentfulPaint, replay)),\n    addClsInstrumentationHandler(webVitalHandler(getCumulativeLayoutShift, replay)),\n    addFidInstrumentationHandler(webVitalHandler(getFirstInputDelay, replay)),\n    addInpInstrumentationHandler(webVitalHandler(getInteractionToNextPaint, replay)),\n  );\n\n  // A callback to cleanup all handlers\n  return () => {\n    clearCallbacks.forEach(clearCallback => clearCallback());\n  };\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\nconst r = `var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),s=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),a=function(t,e){for(var i=new n(31),s=0;s<31;++s)i[s]=e+=1<<t[s-1];var a=new r(i[30]);for(s=1;s<30;++s)for(var o=i[s];o<i[s+1];++o)a[o]=o-i[s]<<5|s;return{b:i,r:a}},o=a(e,2),h=o.b,f=o.r;h[28]=258,f[258]=28;for(var l=a(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,s=0,a=new n(r);s<i;++s)t[s]&&++a[t[s]-1];var o,h=new n(r);for(s=1;s<r;++s)h[s]=h[s-1]+a[s-1]<<1;if(e){o=new n(1<<r);var f=15-r;for(s=0;s<i;++s)if(t[s])for(var l=s<<4|t[s],c=r-t[s],v=h[t[s]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>f]=l}else for(o=new n(i),s=0;s<i;++s)t[s]&&(o[s]=u[h[t[s]-1]++]>>15-t[s]);return o},p=new t(288);for(c=0;c<144;++c)p[c]=8;for(c=144;c<256;++c)p[c]=9;for(c=256;c<280;++c)p[c]=7;for(c=280;c<288;++c)p[c]=8;var g=new t(32);for(c=0;c<32;++c)g[c]=5;var w=d(p,9,0),y=d(g,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},_=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},x=function(r,e){for(var i=[],s=0;s<r.length;++s)r[s]&&i.push({s:s,f:r[s]});var a=i.length,o=i.slice();if(!a)return{t:F,l:0};if(1==a){var h=new t(i[0].s+1);return h[i[0].s]=1,{t:h,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var f=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:f.f+l.f,l:f,r:l};c!=a-1;)f=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:f.f+l.f,l:f,r:l};var d=o[0].s;for(s=1;s<a;++s)o[s].s>d&&(d=o[s].s);var p=new n(d+1),g=A(i[c-1],p,0);if(g>e){s=0;var w=0,y=g-e,m=1<<y;for(o.sort((function(t,n){return p[n.s]-p[t.s]||t.f-n.f}));s<a;++s){var b=o[s].s;if(!(p[b]>e))break;w+=m-(1<<g-p[b]),p[b]=e}for(w>>=y;w>0;){var M=o[s].s;p[M]<e?w-=1<<e-p[M]++-1:++s}for(;s>=0&&w;--s){var E=o[s].s;p[E]==e&&(--p[E],++w)}g=e}return{t:new t(p),l:g}},A=function(t,n,r){return-1==t.s?Math.max(A(t.l,n,r+1),A(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,s=t[0],a=1,o=function(t){e[i++]=t},h=1;h<=r;++h)if(t[h]==s&&h!=r)++a;else{if(!s&&a>2){for(;a>138;a-=138)o(32754);a>2&&(o(a>10?a-11<<5|28690:a-3<<5|12305),a=0)}else if(a>3){for(o(s),--a;a>6;a-=6)o(8304);a>2&&(o(a-3<<5|8208),a=0)}for(;a--;)o(s);a=1,s=t[h]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var s=0;s<e;++s)t[i+s+4]=r[s];return 8*(i+4+e)},U=function(t,r,a,o,h,f,l,u,c,v,m){z(r,m++,a),++h[256];for(var b=x(h,15),M=b.t,E=b.l,A=x(f,15),U=A.t,C=A.l,F=D(M),I=F.c,S=F.n,L=D(U),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=x(q,7),H=G.t,J=G.l,K=19;K>4&&!H[s[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(h,p)+T(f,g)+l,X=T(h,M)+T(f,U)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(U,C,0),R=U;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[s[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=w,P=p,Q=y,R=g;for(B=0;B<u;++B){var rt=o[B];if(rt>255){_(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;_(r,m,Q[et]),m+=R[et],et>3&&(_(r,m,rt>>5&8191),m+=i[et])}else _(r,m,N[rt]),m+=P[rt]}return _(r,m,N[256]),m+P[256]},C=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,s=0|r.length,a=0;a!=s;){for(var o=Math.min(a+2655,s);a<o;++a)i+=e+=r[a];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(s,a,o,h,u){if(!u&&(u={l:1},a.dictionary)){var c=a.dictionary.subarray(-32768),v=new t(c.length+s.length);v.set(c),v.set(s,c.length),s=v,u.w=c.length}return function(s,a,o,h,u,c){var v=c.z||s.length,d=new t(h+v+5*(1+Math.ceil(v/7e3))+u),p=d.subarray(h,d.length-u),g=c.l,w=7&(c.r||0);if(a){w&&(p[0]=c.r>>3);for(var y=C[a-1],M=y>>13,E=8191&y,z=(1<<o)-1,_=c.p||new n(32768),x=c.h||new n(z+1),A=Math.ceil(o/3),D=2*A,T=function(t){return(s[t]^s[t+1]<<A^s[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=x[H];if(_[J]=K,x[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!g)){w=U(s,p,0,F,I,S,O,q,G,j-G,w),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(s[j+Q]==s[j+Q-W]){for(var $=0;$<Z&&s[j+$]==s[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-_[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=_[J])&32767}if(R){F[q++]=268435456|f[Q]<<18|l[R];var it=31&f[Q],st=31&l[R];O+=e[it]+i[st],++I[257+it],++S[st],B=j+Q,++L}else F[q++]=s[j],++I[s[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=s[j],++I[s[j]];w=U(s,p,g,F,I,S,O,q,G,j-G,w),g||(c.r=7&w|p[w/8|0]<<3,w-=7,c.h=x,c.p=_,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+g;j+=65535){var at=j+65535;at>=v&&(p[w/8|0]=g,at=v),w=k(p,w+1,s.subarray(j,at))}c.i=v}return b(d,0,h+m(w)+u)}(s,null==a.level?6:a.level,null==a.mem?u.l?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(s.length)))):20:12+a.mem,o,h,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if(\"function\"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var s=this.b.length-this.s.z;this.b.set(n.subarray(0,s),this.s.z),this.s.z=this.b.length,this.p(this.b,!1),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(s),32768),this.s.z=n.length-s+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n.prototype.flush=function(){this.ondata||E(5),this.s.l&&E(4),this.p(this.b,!1),this.s.w=this.s.i,this.s.i-=2},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t.prototype.flush=function(){G.prototype.flush.call(this)},t}(),J=\"undefined\"!=typeof TextEncoder&&new TextEncoder,K=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(J)return J.encode(n);for(var e=n.length,i=new t(n.length+(n.length>>1)),s=0,a=function(t){i[s++]=t},o=0;o<e;++o){if(s+5>i.length){var h=new t(s+8+(e-o<<1));h.set(i),i=h}var f=n.charCodeAt(o);f<128||r?a(f):f<2048?(a(192|f>>6),a(128|63&f)):f>55295&&f<57344?(a(240|(f=65536+(1047552&f)|1023&n.charCodeAt(++o))>>18),a(128|f>>12&63),a(128|f>>6&63),a(128|63&f)):(a(224|f>>12),a(128|f>>6&63),a(128|63&f))}return b(i,0,s)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),s=i.length;return q(i,n),j(i,s-8,r.d()),j(i,s-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error(\"Adding invalid event\");const n=this._hasEvents?\",\":\"\";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push(\"]\",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push(\"[\")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener(\"message\",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&\"function\"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:\"init\",success:!0,response:void 0});`;\n\nfunction e(){const e=new Blob([r]);return URL.createObjectURL(e)}\n\nconst CONSOLE_LEVELS = ['info', 'warn', 'error', 'log'] ;\nconst PREFIX = '[Replay] ';\n\nfunction _addBreadcrumb(message, level = 'info') {\n  addBreadcrumb(\n    {\n      category: 'console',\n      data: {\n        logger: 'replay',\n      },\n      level,\n      message: `${PREFIX}${message}`,\n    },\n    { level },\n  );\n}\n\nfunction makeReplayLogger() {\n  let _capture = false;\n  let _trace = false;\n\n  const _logger = {\n    exception: () => undefined,\n    infoTick: () => undefined,\n    setConfig: (opts) => {\n      _capture = !!opts.captureExceptions;\n      _trace = !!opts.traceInternals;\n    },\n  };\n\n  if (DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      _logger[name] = (...args) => {\n        logger$1[name](PREFIX, ...args);\n        if (_trace) {\n          _addBreadcrumb(args.join(''), severityLevelFromString(name));\n        }\n      };\n    });\n\n    _logger.exception = (error, ...message) => {\n      if (message.length && _logger.error) {\n        _logger.error(...message);\n      }\n\n      logger$1.error(PREFIX, error);\n\n      if (_capture) {\n        captureException(error);\n      } else if (_trace) {\n        // No need for a breadcrumb if `_capture` is enabled since it should be\n        // captured as an exception\n        _addBreadcrumb(error, 'error');\n      }\n    };\n\n    _logger.infoTick = (...args) => {\n      logger$1.info(PREFIX, ...args);\n      if (_trace) {\n        // Wait a tick here to avoid race conditions for some initial logs\n        // which may be added before replay is initialized\n        setTimeout(() => _addBreadcrumb(args[0]), 0);\n      }\n    };\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      _logger[name] = () => undefined;\n    });\n  }\n\n  return _logger ;\n}\n\nconst logger = makeReplayLogger();\n\n/** This error indicates that the event buffer size exceeded the limit.. */\nclass EventBufferSizeExceededError extends Error {\n   constructor() {\n    super(`Event buffer exceeded maximum size of ${REPLAY_MAX_EVENT_BUFFER_SIZE}.`);\n  }\n}\n\n/**\n * A basic event buffer that does not do any compression.\n * Used as fallback if the compression worker cannot be loaded or is disabled.\n */\nclass EventBufferArray  {\n  /** All the events that are buffered to be sent. */\n\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n\n   constructor() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n    this.waitForCheckout = false;\n  }\n\n  /** @inheritdoc */\n   get hasEvents() {\n    return this.events.length > 0;\n  }\n\n  /** @inheritdoc */\n   get type() {\n    return 'sync';\n  }\n\n  /** @inheritdoc */\n   destroy() {\n    this.events = [];\n  }\n\n  /** @inheritdoc */\n   async addEvent(event) {\n    const eventSize = JSON.stringify(event).length;\n    this._totalSize += eventSize;\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      throw new EventBufferSizeExceededError();\n    }\n\n    this.events.push(event);\n  }\n\n  /** @inheritdoc */\n   finish() {\n    return new Promise(resolve => {\n      // Make a copy of the events array reference and immediately clear the\n      // events member so that we do not lose new events while uploading\n      // attachment.\n      const eventsRet = this.events;\n      this.clear();\n      resolve(JSON.stringify(eventsRet));\n    });\n  }\n\n  /** @inheritdoc */\n   clear() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n   getEarliestTimestamp() {\n    const timestamp = this.events.map(event => event.timestamp).sort()[0];\n\n    if (!timestamp) {\n      return null;\n    }\n\n    return timestampToMs(timestamp);\n  }\n}\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nclass WorkerHandler {\n\n   constructor(worker) {\n    this._worker = worker;\n    this._id = 0;\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occurred.\n   */\n   ensureReady() {\n    // Ensure we only check once\n    if (this._ensureReadyPromise) {\n      return this._ensureReadyPromise;\n    }\n\n    this._ensureReadyPromise = new Promise((resolve, reject) => {\n      this._worker.addEventListener(\n        'message',\n        ({ data }) => {\n          if ((data ).success) {\n            resolve();\n          } else {\n            reject();\n          }\n        },\n        { once: true },\n      );\n\n      this._worker.addEventListener(\n        'error',\n        error => {\n          reject(error);\n        },\n        { once: true },\n      );\n    });\n\n    return this._ensureReadyPromise;\n  }\n\n  /**\n   * Destroy the worker.\n   */\n   destroy() {\n    DEBUG_BUILD && logger.info('Destroying compression worker');\n    this._worker.terminate();\n  }\n\n  /**\n   * Post message to worker and wait for response before resolving promise.\n   */\n   postMessage(method, arg) {\n    const id = this._getAndIncrementId();\n\n    return new Promise((resolve, reject) => {\n      const listener = ({ data }) => {\n        const response = data ;\n        if (response.method !== method) {\n          return;\n        }\n\n        // There can be multiple listeners for a single method, the id ensures\n        // that the response matches the caller.\n        if (response.id !== id) {\n          return;\n        }\n\n        // At this point, we'll always want to remove listener regardless of result status\n        this._worker.removeEventListener('message', listener);\n\n        if (!response.success) {\n          // TODO: Do some error handling, not sure what\n          DEBUG_BUILD && logger.error('Error in compression worker: ', response.response);\n\n          reject(new Error('Error in compression worker'));\n          return;\n        }\n\n        resolve(response.response );\n      };\n\n      // Note: we can't use `once` option because it's possible it needs to\n      // listen to multiple messages\n      this._worker.addEventListener('message', listener);\n      this._worker.postMessage({ id, method, arg });\n    });\n  }\n\n  /** Get the current ID and increment it for the next call. */\n   _getAndIncrementId() {\n    return this._id++;\n  }\n}\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nclass EventBufferCompressionWorker  {\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n\n   constructor(worker) {\n    this._worker = new WorkerHandler(worker);\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n    this.waitForCheckout = false;\n  }\n\n  /** @inheritdoc */\n   get hasEvents() {\n    return !!this._earliestTimestamp;\n  }\n\n  /** @inheritdoc */\n   get type() {\n    return 'worker';\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occurred.\n   */\n   ensureReady() {\n    return this._worker.ensureReady();\n  }\n\n  /**\n   * Destroy the event buffer.\n   */\n   destroy() {\n    this._worker.destroy();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully received and processed by worker.\n   */\n   addEvent(event) {\n    const timestamp = timestampToMs(event.timestamp);\n    if (!this._earliestTimestamp || timestamp < this._earliestTimestamp) {\n      this._earliestTimestamp = timestamp;\n    }\n\n    const data = JSON.stringify(event);\n    this._totalSize += data.length;\n\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      return Promise.reject(new EventBufferSizeExceededError());\n    }\n\n    return this._sendEventToWorker(data);\n  }\n\n  /**\n   * Finish the event buffer and return the compressed data.\n   */\n   finish() {\n    return this._finishRequest();\n  }\n\n  /** @inheritdoc */\n   clear() {\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n\n    // We do not wait on this, as we assume the order of messages is consistent for the worker\n    this._worker.postMessage('clear').then(null, e => {\n      DEBUG_BUILD && logger.exception(e, 'Sending \"clear\" message to worker failed', e);\n    });\n  }\n\n  /** @inheritdoc */\n   getEarliestTimestamp() {\n    return this._earliestTimestamp;\n  }\n\n  /**\n   * Send the event to the worker.\n   */\n   _sendEventToWorker(data) {\n    return this._worker.postMessage('addEvent', data);\n  }\n\n  /**\n   * Finish the request and return the compressed data from the worker.\n   */\n   async _finishRequest() {\n    const response = await this._worker.postMessage('finish');\n\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n\n    return response;\n  }\n}\n\n/**\n * This proxy will try to use the compression worker, and fall back to use the simple buffer if an error occurs there.\n * This can happen e.g. if the worker cannot be loaded.\n * Exported only for testing.\n */\nclass EventBufferProxy  {\n\n   constructor(worker) {\n    this._fallback = new EventBufferArray();\n    this._compression = new EventBufferCompressionWorker(worker);\n    this._used = this._fallback;\n\n    this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();\n  }\n\n  /** @inheritdoc */\n   get waitForCheckout() {\n    return this._used.waitForCheckout;\n  }\n\n  /** @inheritdoc */\n   get type() {\n    return this._used.type;\n  }\n\n  /** @inheritDoc */\n   get hasEvents() {\n    return this._used.hasEvents;\n  }\n\n  /** @inheritdoc */\n   get hasCheckout() {\n    return this._used.hasCheckout;\n  }\n  /** @inheritdoc */\n   set hasCheckout(value) {\n    this._used.hasCheckout = value;\n  }\n\n  /** @inheritdoc */\n  // eslint-disable-next-line @typescript-eslint/adjacent-overload-signatures\n   set waitForCheckout(value) {\n    this._used.waitForCheckout = value;\n  }\n\n  /** @inheritDoc */\n   destroy() {\n    this._fallback.destroy();\n    this._compression.destroy();\n  }\n\n  /** @inheritdoc */\n   clear() {\n    return this._used.clear();\n  }\n\n  /** @inheritdoc */\n   getEarliestTimestamp() {\n    return this._used.getEarliestTimestamp();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully added.\n   */\n   addEvent(event) {\n    return this._used.addEvent(event);\n  }\n\n  /** @inheritDoc */\n   async finish() {\n    // Ensure the worker is loaded, so the sent event is compressed\n    await this.ensureWorkerIsLoaded();\n\n    return this._used.finish();\n  }\n\n  /** Ensure the worker has loaded. */\n   ensureWorkerIsLoaded() {\n    return this._ensureWorkerIsLoadedPromise;\n  }\n\n  /** Actually check if the worker has been loaded. */\n   async _ensureWorkerIsLoaded() {\n    try {\n      await this._compression.ensureReady();\n    } catch (error) {\n      // If the worker fails to load, we fall back to the simple buffer.\n      // Nothing more to do from our side here\n      DEBUG_BUILD && logger.exception(error, 'Failed to load the compression worker, falling back to simple buffer');\n      return;\n    }\n\n    // Now we need to switch over the array buffer to the compression worker\n    await this._switchToCompressionWorker();\n  }\n\n  /** Switch the used buffer to the compression worker. */\n   async _switchToCompressionWorker() {\n    const { events, hasCheckout, waitForCheckout } = this._fallback;\n\n    const addEventPromises = [];\n    for (const event of events) {\n      addEventPromises.push(this._compression.addEvent(event));\n    }\n\n    this._compression.hasCheckout = hasCheckout;\n    this._compression.waitForCheckout = waitForCheckout;\n\n    // We switch over to the new buffer immediately - any further events will be added\n    // after the previously buffered ones\n    this._used = this._compression;\n\n    // Wait for original events to be re-added before resolving\n    try {\n      await Promise.all(addEventPromises);\n\n      // Can now clear fallback buffer as it's no longer necessary\n      this._fallback.clear();\n    } catch (error) {\n      DEBUG_BUILD && logger.exception(error, 'Failed to add events when switching buffers.');\n    }\n  }\n}\n\n/**\n * Create an event buffer for replays.\n */\nfunction createEventBuffer({\n  useCompression,\n  workerUrl: customWorkerUrl,\n}) {\n  if (\n    useCompression &&\n    // eslint-disable-next-line no-restricted-globals\n    window.Worker\n  ) {\n    const worker = _loadWorker(customWorkerUrl);\n\n    if (worker) {\n      return worker;\n    }\n  }\n\n  DEBUG_BUILD && logger.info('Using simple buffer');\n  return new EventBufferArray();\n}\n\nfunction _loadWorker(customWorkerUrl) {\n  try {\n    const workerUrl = customWorkerUrl || _getWorkerUrl();\n\n    if (!workerUrl) {\n      return;\n    }\n\n    DEBUG_BUILD && logger.info(`Using compression worker${customWorkerUrl ? ` from ${customWorkerUrl}` : ''}`);\n    const worker = new Worker(workerUrl);\n    return new EventBufferProxy(worker);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to create compression worker');\n    // Fall back to use simple event buffer array\n  }\n}\n\nfunction _getWorkerUrl() {\n  if (typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ === 'undefined' || !__SENTRY_EXCLUDE_REPLAY_WORKER__) {\n    return e();\n  }\n\n  return '';\n}\n\n/** If sessionStorage is available. */\nfunction hasSessionStorage() {\n  try {\n    // This can throw, e.g. when being accessed in a sandboxed iframe\n    return 'sessionStorage' in WINDOW && !!WINDOW.sessionStorage;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Removes the session from Session Storage and unsets session in replay instance\n */\nfunction clearSession(replay) {\n  deleteSession();\n  replay.session = undefined;\n}\n\n/**\n * Deletes a session from storage\n */\nfunction deleteSession() {\n  if (!hasSessionStorage()) {\n    return;\n  }\n\n  try {\n    WINDOW.sessionStorage.removeItem(REPLAY_SESSION_KEY);\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n\n/**\n * Given a sample rate, returns true if replay should be sampled.\n *\n * 1.0 = 100% sampling\n * 0.0 = 0% sampling\n */\nfunction isSampled(sampleRate) {\n  if (sampleRate === undefined) {\n    return false;\n  }\n\n  // Math.random() returns a number in range of 0 to 1 (inclusive of 0, but not 1)\n  return Math.random() < sampleRate;\n}\n\n/**\n * Save a session to session storage.\n */\nfunction saveSession(session) {\n  if (!hasSessionStorage()) {\n    return;\n  }\n\n  try {\n    WINDOW.sessionStorage.setItem(REPLAY_SESSION_KEY, JSON.stringify(session));\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n\n/**\n * Get a session with defaults & applied sampling.\n */\nfunction makeSession(session) {\n  const now = Date.now();\n  const id = session.id || uuid4();\n  // Note that this means we cannot set a started/lastActivity of `0`, but this should not be relevant outside of tests.\n  const started = session.started || now;\n  const lastActivity = session.lastActivity || now;\n  const segmentId = session.segmentId || 0;\n  const sampled = session.sampled;\n  const previousSessionId = session.previousSessionId;\n\n  return {\n    id,\n    started,\n    lastActivity,\n    segmentId,\n    sampled,\n    previousSessionId,\n  };\n}\n\n/**\n * Get the sampled status for a session based on sample rates & current sampled status.\n */\nfunction getSessionSampleType(sessionSampleRate, allowBuffering) {\n  return isSampled(sessionSampleRate) ? 'session' : allowBuffering ? 'buffer' : false;\n}\n\n/**\n * Create a new session, which in its current implementation is a Sentry event\n * that all replays will be saved to as attachments. Currently, we only expect\n * one of these Sentry events per \"replay session\".\n */\nfunction createSession(\n  { sessionSampleRate, allowBuffering, stickySession = false },\n  { previousSessionId } = {},\n) {\n  const sampled = getSessionSampleType(sessionSampleRate, allowBuffering);\n  const session = makeSession({\n    sampled,\n    previousSessionId,\n  });\n\n  if (stickySession) {\n    saveSession(session);\n  }\n\n  return session;\n}\n\n/**\n * Fetches a session from storage\n */\nfunction fetchSession() {\n  if (!hasSessionStorage()) {\n    return null;\n  }\n\n  try {\n    // This can throw if cookies are disabled\n    const sessionStringFromStorage = WINDOW.sessionStorage.getItem(REPLAY_SESSION_KEY);\n\n    if (!sessionStringFromStorage) {\n      return null;\n    }\n\n    const sessionObj = JSON.parse(sessionStringFromStorage) ;\n\n    DEBUG_BUILD && logger.infoTick('Loading existing session');\n\n    return makeSession(sessionObj);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Given an initial timestamp and an expiry duration, checks to see if current\n * time should be considered as expired.\n */\nfunction isExpired(\n  initialTime,\n  expiry,\n  targetTime = +new Date(),\n) {\n  // Always expired if < 0\n  if (initialTime === null || expiry === undefined || expiry < 0) {\n    return true;\n  }\n\n  // Never expires if == 0\n  if (expiry === 0) {\n    return false;\n  }\n\n  return initialTime + expiry <= targetTime;\n}\n\n/**\n * Checks to see if session is expired\n */\nfunction isSessionExpired(\n  session,\n  {\n    maxReplayDuration,\n    sessionIdleExpire,\n    targetTime = Date.now(),\n  },\n) {\n  return (\n    // First, check that maximum session length has not been exceeded\n    isExpired(session.started, maxReplayDuration, targetTime) ||\n    // check that the idle timeout has not been exceeded (i.e. user has\n    // performed an action within the last `sessionIdleExpire` ms)\n    isExpired(session.lastActivity, sessionIdleExpire, targetTime)\n  );\n}\n\n/** If the session should be refreshed or not. */\nfunction shouldRefreshSession(\n  session,\n  { sessionIdleExpire, maxReplayDuration },\n) {\n  // If not expired, all good, just keep the session\n  if (!isSessionExpired(session, { sessionIdleExpire, maxReplayDuration })) {\n    return false;\n  }\n\n  // If we are buffering & haven't ever flushed yet, always continue\n  if (session.sampled === 'buffer' && session.segmentId === 0) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Get or create a session, when initializing the replay.\n * Returns a session that may be unsampled.\n */\nfunction loadOrCreateSession(\n  {\n    sessionIdleExpire,\n    maxReplayDuration,\n    previousSessionId,\n  }\n\n,\n  sessionOptions,\n) {\n  const existingSession = sessionOptions.stickySession && fetchSession();\n\n  // No session exists yet, just create a new one\n  if (!existingSession) {\n    DEBUG_BUILD && logger.infoTick('Creating new session');\n    return createSession(sessionOptions, { previousSessionId });\n  }\n\n  if (!shouldRefreshSession(existingSession, { sessionIdleExpire, maxReplayDuration })) {\n    return existingSession;\n  }\n\n  DEBUG_BUILD && logger.infoTick('Session in sessionStorage is expired, creating new one...');\n  return createSession(sessionOptions, { previousSessionId: existingSession.id });\n}\n\nfunction isCustomEvent(event) {\n  return event.type === EventType.Custom;\n}\n\n/**\n * Add an event to the event buffer.\n * In contrast to `addEvent`, this does not return a promise & does not wait for the adding of the event to succeed/fail.\n * Instead this returns `true` if we tried to add the event, else false.\n * It returns `false` e.g. if we are paused, disabled, or out of the max replay duration.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nfunction addEventSync(replay, event, isCheckout) {\n  if (!shouldAddEvent(replay, event)) {\n    return false;\n  }\n\n  // This should never reject\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  _addEvent(replay, event, isCheckout);\n\n  return true;\n}\n\n/**\n * Add an event to the event buffer.\n * Resolves to `null` if no event was added, else to `void`.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nfunction addEvent(\n  replay,\n  event,\n  isCheckout,\n) {\n  if (!shouldAddEvent(replay, event)) {\n    return Promise.resolve(null);\n  }\n\n  return _addEvent(replay, event, isCheckout);\n}\n\nasync function _addEvent(\n  replay,\n  event,\n  isCheckout,\n) {\n  const { eventBuffer } = replay;\n\n  if (!eventBuffer || (eventBuffer.waitForCheckout && !isCheckout)) {\n    return null;\n  }\n\n  const isBufferMode = replay.recordingMode === 'buffer';\n\n  try {\n    if (isCheckout && isBufferMode) {\n      eventBuffer.clear();\n    }\n\n    if (isCheckout) {\n      eventBuffer.hasCheckout = true;\n      eventBuffer.waitForCheckout = false;\n    }\n\n    const replayOptions = replay.getOptions();\n\n    const eventAfterPossibleCallback = maybeApplyCallback(event, replayOptions.beforeAddRecordingEvent);\n\n    if (!eventAfterPossibleCallback) {\n      return;\n    }\n\n    return await eventBuffer.addEvent(eventAfterPossibleCallback);\n  } catch (error) {\n    const isExceeded = error && error instanceof EventBufferSizeExceededError;\n    const reason = isExceeded ? 'addEventSizeExceeded' : 'addEvent';\n\n    if (isExceeded && isBufferMode) {\n      // Clear buffer and wait for next checkout\n      eventBuffer.clear();\n      eventBuffer.waitForCheckout = true;\n\n      return null;\n    }\n\n    replay.handleException(error);\n\n    await replay.stop({ reason });\n\n    const client = getClient();\n\n    if (client) {\n      client.recordDroppedEvent('internal_sdk_error', 'replay');\n    }\n  }\n}\n\n/** Exported only for tests. */\nfunction shouldAddEvent(replay, event) {\n  if (!replay.eventBuffer || replay.isPaused() || !replay.isEnabled()) {\n    return false;\n  }\n\n  const timestampInMs = timestampToMs(event.timestamp);\n\n  // Throw out events that happen more than 5 minutes ago. This can happen if\n  // page has been left open and idle for a long period of time and user\n  // comes back to trigger a new session. The performance entries rely on\n  // `performance.timeOrigin`, which is when the page first opened.\n  if (timestampInMs + replay.timeouts.sessionIdlePause < Date.now()) {\n    return false;\n  }\n\n  // Throw out events that are +60min from the initial timestamp\n  if (timestampInMs > replay.getContext().initialTimestamp + replay.getOptions().maxReplayDuration) {\n    DEBUG_BUILD &&\n      logger.infoTick(`Skipping event with timestamp ${timestampInMs} because it is after maxReplayDuration`);\n    return false;\n  }\n\n  return true;\n}\n\nfunction maybeApplyCallback(\n  event,\n  callback,\n) {\n  try {\n    if (typeof callback === 'function' && isCustomEvent(event)) {\n      return callback(event);\n    }\n  } catch (error) {\n    DEBUG_BUILD &&\n      logger.exception(error, 'An error occurred in the `beforeAddRecordingEvent` callback, skipping the event...');\n    return null;\n  }\n\n  return event;\n}\n\n/** If the event is an error event */\nfunction isErrorEvent(event) {\n  return !event.type;\n}\n\n/** If the event is a transaction event */\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\n\n/** If the event is an replay event */\nfunction isReplayEvent(event) {\n  return event.type === 'replay_event';\n}\n\n/** If the event is a feedback event */\nfunction isFeedbackEvent(event) {\n  return event.type === 'feedback';\n}\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nfunction handleAfterSendEvent(replay) {\n  return (event, sendResponse) => {\n    if (!replay.isEnabled() || (!isErrorEvent(event) && !isTransactionEvent(event))) {\n      return;\n    }\n\n    const statusCode = sendResponse?.statusCode;\n\n    // We only want to do stuff on successful error sending, otherwise you get error replays without errors attached\n    // If not using the base transport, we allow `undefined` response (as a custom transport may not implement this correctly yet)\n    // If we do use the base transport, we skip if we encountered an non-OK status code\n    if (!statusCode || statusCode < 200 || statusCode >= 300) {\n      return;\n    }\n\n    if (isTransactionEvent(event)) {\n      handleTransactionEvent(replay, event);\n      return;\n    }\n\n    handleErrorEvent(replay, event);\n  };\n}\n\nfunction handleTransactionEvent(replay, event) {\n  const replayContext = replay.getContext();\n\n  // Collect traceIds in _context regardless of `recordingMode`\n  // In error mode, _context gets cleared on every checkout\n  // We limit to max. 100 transactions linked\n  if (event.contexts?.trace?.trace_id && replayContext.traceIds.size < 100) {\n    replayContext.traceIds.add(event.contexts.trace.trace_id);\n  }\n}\n\nfunction handleErrorEvent(replay, event) {\n  const replayContext = replay.getContext();\n\n  // Add error to list of errorIds of replay. This is ok to do even if not\n  // sampled because context will get reset at next checkout.\n  // XXX: There is also a race condition where it's possible to capture an\n  // error to Sentry before Replay SDK has loaded, but response returns after\n  // it was loaded, and this gets called.\n  // We limit to max. 100 errors linked\n  if (event.event_id && replayContext.errorIds.size < 100) {\n    replayContext.errorIds.add(event.event_id);\n  }\n\n  // If error event is tagged with replay id it means it was sampled (when in buffer mode)\n  // Need to be very careful that this does not cause an infinite loop\n  if (replay.recordingMode !== 'buffer' || !event.tags || !event.tags.replayId) {\n    return;\n  }\n\n  const { beforeErrorSampling } = replay.getOptions();\n  if (typeof beforeErrorSampling === 'function' && !beforeErrorSampling(event)) {\n    return;\n  }\n\n  setTimeout$3(async () => {\n    try {\n      // Capture current event buffer as new replay\n      await replay.sendBufferedReplayOrFlush();\n    } catch (err) {\n      replay.handleException(err);\n    }\n  });\n}\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nfunction handleBeforeSendEvent(replay) {\n  return (event) => {\n    if (!replay.isEnabled() || !isErrorEvent(event)) {\n      return;\n    }\n\n    handleHydrationError(replay, event);\n  };\n}\n\nfunction handleHydrationError(replay, event) {\n  const exceptionValue = event.exception?.values?.[0]?.value;\n  if (typeof exceptionValue !== 'string') {\n    return;\n  }\n\n  if (\n    // Only matches errors in production builds of react-dom\n    // Example https://reactjs.org/docs/error-decoder.html?invariant=423\n    // With newer React versions, the messages changed to a different website https://react.dev/errors/418\n    exceptionValue.match(\n      /(reactjs\\.org\\/docs\\/error-decoder\\.html\\?invariant=|react\\.dev\\/errors\\/)(418|419|422|423|425)/,\n    ) ||\n    // Development builds of react-dom\n    // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.\n    // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.\n    exceptionValue.match(/(does not match server-rendered HTML|Hydration failed because)/i)\n  ) {\n    const breadcrumb = createBreadcrumb({\n      category: 'replay.hydrate-error',\n      data: {\n        url: getLocationHref(),\n      },\n    });\n    addBreadcrumbEvent(replay, breadcrumb);\n  }\n}\n\n/**\n * Handle breadcrumbs that Sentry captures, and make sure to capture relevant breadcrumbs to Replay as well.\n */\nfunction handleBreadcrumbs(replay) {\n  const client = getClient();\n\n  if (!client) {\n    return;\n  }\n\n  client.on('beforeAddBreadcrumb', breadcrumb => beforeAddBreadcrumb(replay, breadcrumb));\n}\n\nfunction beforeAddBreadcrumb(replay, breadcrumb) {\n  if (!replay.isEnabled() || !isBreadcrumbWithCategory(breadcrumb)) {\n    return;\n  }\n\n  const result = normalizeBreadcrumb(breadcrumb);\n  if (result) {\n    addBreadcrumbEvent(replay, result);\n  }\n}\n\n/** Exported only for tests. */\nfunction normalizeBreadcrumb(breadcrumb) {\n  if (\n    !isBreadcrumbWithCategory(breadcrumb) ||\n    [\n      // fetch & xhr are handled separately,in handleNetworkBreadcrumbs\n      'fetch',\n      'xhr',\n      // These two are breadcrumbs for emitted sentry events, we don't care about them\n      'sentry.event',\n      'sentry.transaction',\n    ].includes(breadcrumb.category) ||\n    // We capture UI breadcrumbs separately\n    breadcrumb.category.startsWith('ui.')\n  ) {\n    return null;\n  }\n\n  if (breadcrumb.category === 'console') {\n    return normalizeConsoleBreadcrumb(breadcrumb);\n  }\n\n  return createBreadcrumb(breadcrumb);\n}\n\n/** exported for tests only */\nfunction normalizeConsoleBreadcrumb(\n  breadcrumb,\n) {\n  const args = breadcrumb.data?.arguments;\n\n  if (!Array.isArray(args) || args.length === 0) {\n    return createBreadcrumb(breadcrumb);\n  }\n\n  let isTruncated = false;\n\n  // Avoid giant args captures\n  const normalizedArgs = args.map(arg => {\n    if (!arg) {\n      return arg;\n    }\n    if (typeof arg === 'string') {\n      if (arg.length > CONSOLE_ARG_MAX_SIZE) {\n        isTruncated = true;\n        return `${arg.slice(0, CONSOLE_ARG_MAX_SIZE)}`;\n      }\n\n      return arg;\n    }\n    if (typeof arg === 'object') {\n      try {\n        const normalizedArg = normalize(arg, 7);\n        const stringified = JSON.stringify(normalizedArg);\n        if (stringified.length > CONSOLE_ARG_MAX_SIZE) {\n          isTruncated = true;\n          // We use the pretty printed JSON string here as a base\n          return `${JSON.stringify(normalizedArg, null, 2).slice(0, CONSOLE_ARG_MAX_SIZE)}`;\n        }\n        return normalizedArg;\n      } catch {\n        // fall back to default\n      }\n    }\n\n    return arg;\n  });\n\n  return createBreadcrumb({\n    ...breadcrumb,\n    data: {\n      ...breadcrumb.data,\n      arguments: normalizedArgs,\n      ...(isTruncated ? { _meta: { warnings: ['CONSOLE_ARG_TRUNCATED'] } } : {}),\n    },\n  });\n}\n\nfunction isBreadcrumbWithCategory(breadcrumb) {\n  return !!breadcrumb.category;\n}\n\n/**\n * Returns true if we think the given event is an error originating inside of rrweb.\n */\nfunction isRrwebError(event, hint) {\n  if (event.type || !event.exception || !event.exception.values || !event.exception.values.length) {\n    return false;\n  }\n\n  // @ts-expect-error this may be set by rrweb when it finds errors\n  if (hint.originalException?.__rrweb__) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Reset the `replay_id` field on the DSC.\n */\nfunction resetReplayIdOnDynamicSamplingContext() {\n  // Reset DSC on the current scope, if there is one\n  const dsc = getCurrentScope().getPropagationContext().dsc;\n  if (dsc) {\n    delete dsc.replay_id;\n  }\n\n  // Clear it from frozen DSC on the active span\n  const activeSpan = getActiveSpan();\n  if (activeSpan) {\n    const dsc = getDynamicSamplingContextFromSpan(activeSpan);\n    delete (dsc ).replay_id;\n  }\n}\n\n/**\n * Add a feedback breadcrumb event to replay.\n */\nfunction addFeedbackBreadcrumb(replay, event) {\n  replay.triggerUserActivity();\n  replay.addUpdate(() => {\n    if (!event.timestamp) {\n      // Ignore events that don't have timestamps (this shouldn't happen, more of a typing issue)\n      // Return true here so that we don't flush\n      return true;\n    }\n\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: event.timestamp * 1000,\n      data: {\n        tag: 'breadcrumb',\n        payload: {\n          timestamp: event.timestamp,\n          type: 'default',\n          category: 'sentry.feedback',\n          data: {\n            feedbackId: event.event_id,\n          },\n        },\n      },\n    } );\n\n    return false;\n  });\n}\n\n/**\n * Determine if event should be sampled (only applies in buffer mode).\n * When an event is captured by `handleGlobalEvent`, when in buffer mode\n * we determine if we want to sample the error or not.\n */\nfunction shouldSampleForBufferEvent(replay, event) {\n  if (replay.recordingMode !== 'buffer') {\n    return false;\n  }\n\n  // ignore this error because otherwise we could loop indefinitely with\n  // trying to capture replay and failing\n  if (event.message === UNABLE_TO_SEND_REPLAY) {\n    return false;\n  }\n\n  // Require the event to be an error event & to have an exception\n  if (!event.exception || event.type) {\n    return false;\n  }\n\n  return isSampled(replay.getOptions().errorSampleRate);\n}\n\n/**\n * Returns a listener to be added to `addEventProcessor(listener)`.\n */\nfunction handleGlobalEventListener(replay) {\n  return Object.assign(\n    (event, hint) => {\n      // Do nothing if replay has been disabled or paused\n      if (!replay.isEnabled() || replay.isPaused()) {\n        return event;\n      }\n\n      if (isReplayEvent(event)) {\n        // Replays have separate set of breadcrumbs, do not include breadcrumbs\n        // from core SDK\n        delete event.breadcrumbs;\n        return event;\n      }\n\n      // We only want to handle errors, transactions, and feedbacks, nothing else\n      if (!isErrorEvent(event) && !isTransactionEvent(event) && !isFeedbackEvent(event)) {\n        return event;\n      }\n\n      // Ensure we do not add replay_id if the session is expired\n      const isSessionActive = replay.checkAndHandleExpiredSession();\n      if (!isSessionActive) {\n        // prevent exceeding replay durations by removing the expired replayId from the DSC\n        resetReplayIdOnDynamicSamplingContext();\n        return event;\n      }\n\n      if (isFeedbackEvent(event)) {\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        replay.flush();\n        event.contexts.feedback.replay_id = replay.getSessionId();\n        // Add a replay breadcrumb for this piece of feedback\n        addFeedbackBreadcrumb(replay, event);\n        return event;\n      }\n\n      // Unless `captureExceptions` is enabled, we want to ignore errors coming from rrweb\n      // As there can be a bunch of stuff going wrong in internals there, that we don't want to bubble up to users\n      if (isRrwebError(event, hint) && !replay.getOptions()._experiments.captureExceptions) {\n        DEBUG_BUILD && logger.log('Ignoring error from rrweb internals', event);\n        return null;\n      }\n\n      // When in buffer mode, we decide to sample here.\n      // Later, in `handleAfterSendEvent`, if the replayId is set, we know that we sampled\n      // And convert the buffer session to a full session\n      const isErrorEventSampled = shouldSampleForBufferEvent(replay, event);\n\n      // Tag errors if it has been sampled in buffer mode, or if it is session mode\n      // Only tag transactions if in session mode\n      const shouldTagReplayId = isErrorEventSampled || replay.recordingMode === 'session';\n\n      if (shouldTagReplayId) {\n        event.tags = { ...event.tags, replayId: replay.getSessionId() };\n      }\n\n      return event;\n    },\n    { id: 'Replay' },\n  );\n}\n\n/**\n * Create a \"span\" for each performance entry.\n */\nfunction createPerformanceSpans(\n  replay,\n  entries,\n) {\n  return entries.map(({ type, start, end, name, data }) => {\n    const response = replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: start,\n      data: {\n        tag: 'performanceSpan',\n        payload: {\n          op: type,\n          description: name,\n          startTimestamp: start,\n          endTimestamp: end,\n          data,\n        },\n      },\n    });\n\n    // If response is a string, it means its either THROTTLED or SKIPPED\n    return typeof response === 'string' ? Promise.resolve(null) : response;\n  });\n}\n\nfunction handleHistory(handlerData) {\n  const { from, to } = handlerData;\n\n  const now = Date.now() / 1000;\n\n  return {\n    type: 'navigation.push',\n    start: now,\n    end: now,\n    name: to,\n    data: {\n      previous: from,\n    },\n  };\n}\n\n/**\n * Returns a listener to be added to `addHistoryInstrumentationHandler(listener)`.\n */\nfunction handleHistorySpanListener(replay) {\n  return (handlerData) => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleHistory(handlerData);\n\n    if (result === null) {\n      return;\n    }\n\n    // Need to collect visited URLs\n    replay.getContext().urls.push(result.name);\n    replay.triggerUserActivity();\n\n    replay.addUpdate(() => {\n      createPerformanceSpans(replay, [result]);\n      // Returning false to flush\n      return false;\n    });\n  };\n}\n\n/**\n * Check whether a given request URL should be filtered out. This is so we\n * don't log Sentry ingest requests.\n */\nfunction shouldFilterRequest(replay, url) {\n  // If we enabled the `traceInternals` experiment, we want to trace everything\n  if (DEBUG_BUILD && replay.getOptions()._experiments.traceInternals) {\n    return false;\n  }\n\n  return isSentryRequestUrl(url, getClient());\n}\n\n/** Add a performance entry breadcrumb */\nfunction addNetworkBreadcrumb(\n  replay,\n  result,\n) {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  if (result === null) {\n    return;\n  }\n\n  if (shouldFilterRequest(replay, result.name)) {\n    return;\n  }\n\n  replay.addUpdate(() => {\n    createPerformanceSpans(replay, [result]);\n    // Returning true will cause `addUpdate` to not flush\n    // We do not want network requests to cause a flush. This will prevent\n    // recurring/polling requests from keeping the replay session alive.\n    return true;\n  });\n}\n\n/** Get the size of a body. */\nfunction getBodySize(body) {\n  if (!body) {\n    return undefined;\n  }\n\n  const textEncoder = new TextEncoder();\n\n  try {\n    if (typeof body === 'string') {\n      return textEncoder.encode(body).length;\n    }\n\n    if (body instanceof URLSearchParams) {\n      return textEncoder.encode(body.toString()).length;\n    }\n\n    if (body instanceof FormData) {\n      const formDataStr = serializeFormData(body);\n      return textEncoder.encode(formDataStr).length;\n    }\n\n    if (body instanceof Blob) {\n      return body.size;\n    }\n\n    if (body instanceof ArrayBuffer) {\n      return body.byteLength;\n    }\n\n    // Currently unhandled types: ArrayBufferView, ReadableStream\n  } catch {\n    // just return undefined\n  }\n\n  return undefined;\n}\n\n/** Convert a Content-Length header to number/undefined.  */\nfunction parseContentLengthHeader(header) {\n  if (!header) {\n    return undefined;\n  }\n\n  const size = parseInt(header, 10);\n  return isNaN(size) ? undefined : size;\n}\n\n/** Merge a warning into an existing network request/response. */\nfunction mergeWarning(\n  info,\n  warning,\n) {\n  if (!info) {\n    return {\n      headers: {},\n      size: undefined,\n      _meta: {\n        warnings: [warning],\n      },\n    };\n  }\n\n  const newMeta = { ...info._meta };\n  const existingWarnings = newMeta.warnings || [];\n  newMeta.warnings = [...existingWarnings, warning];\n\n  info._meta = newMeta;\n  return info;\n}\n\n/** Convert ReplayNetworkRequestData to a PerformanceEntry. */\nfunction makeNetworkReplayBreadcrumb(\n  type,\n  data,\n) {\n  if (!data) {\n    return null;\n  }\n\n  const { startTimestamp, endTimestamp, url, method, statusCode, request, response } = data;\n\n  const result = {\n    type,\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    name: url,\n    data: {\n      method,\n      statusCode,\n      request,\n      response,\n    },\n  };\n\n  return result;\n}\n\n/** Build the request or response part of a replay network breadcrumb that was skipped. */\nfunction buildSkippedNetworkRequestOrResponse(bodySize) {\n  return {\n    headers: {},\n    size: bodySize,\n    _meta: {\n      warnings: ['URL_SKIPPED'],\n    },\n  };\n}\n\n/** Build the request or response part of a replay network breadcrumb. */\nfunction buildNetworkRequestOrResponse(\n  headers,\n  bodySize,\n  body,\n) {\n  if (!bodySize && Object.keys(headers).length === 0) {\n    return undefined;\n  }\n\n  if (!bodySize) {\n    return {\n      headers,\n    };\n  }\n\n  if (!body) {\n    return {\n      headers,\n      size: bodySize,\n    };\n  }\n\n  const info = {\n    headers,\n    size: bodySize,\n  };\n\n  const { body: normalizedBody, warnings } = normalizeNetworkBody(body);\n  info.body = normalizedBody;\n  if (warnings?.length) {\n    info._meta = {\n      warnings,\n    };\n  }\n\n  return info;\n}\n\n/** Filter a set of headers */\nfunction getAllowedHeaders(headers, allowedHeaders) {\n  return Object.entries(headers).reduce((filteredHeaders, [key, value]) => {\n    const normalizedKey = key.toLowerCase();\n    // Avoid putting empty strings into the headers\n    if (allowedHeaders.includes(normalizedKey) && headers[key]) {\n      filteredHeaders[normalizedKey] = value;\n    }\n    return filteredHeaders;\n  }, {});\n}\n\nfunction normalizeNetworkBody(body)\n\n {\n  if (!body || typeof body !== 'string') {\n    return {\n      body,\n    };\n  }\n\n  const exceedsSizeLimit = body.length > NETWORK_BODY_MAX_SIZE;\n  const isProbablyJson = _strIsProbablyJson(body);\n\n  if (exceedsSizeLimit) {\n    const truncatedBody = body.slice(0, NETWORK_BODY_MAX_SIZE);\n\n    if (isProbablyJson) {\n      return {\n        body: truncatedBody,\n        warnings: ['MAYBE_JSON_TRUNCATED'],\n      };\n    }\n\n    return {\n      body: `${truncatedBody}`,\n      warnings: ['TEXT_TRUNCATED'],\n    };\n  }\n\n  if (isProbablyJson) {\n    try {\n      const jsonBody = JSON.parse(body);\n      return {\n        body: jsonBody,\n      };\n    } catch {\n      // fall back to just send the body as string\n    }\n  }\n\n  return {\n    body,\n  };\n}\n\nfunction _strIsProbablyJson(str) {\n  const first = str[0];\n  const last = str[str.length - 1];\n\n  // Simple check: If this does not start & end with {} or [], it's not JSON\n  return (first === '[' && last === ']') || (first === '{' && last === '}');\n}\n\n/** Match an URL against a list of strings/Regex. */\nfunction urlMatches(url, urls) {\n  const fullUrl = getFullUrl(url);\n\n  return stringMatchesSomePattern(fullUrl, urls);\n}\n\n/** exported for tests */\nfunction getFullUrl(url, baseURI = WINDOW.document.baseURI) {\n  // Short circuit for common cases:\n  if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith(WINDOW.location.origin)) {\n    return url;\n  }\n  const fixedUrl = new URL(url, baseURI);\n\n  // If these do not match, we are not dealing with a relative URL, so just return it\n  if (fixedUrl.origin !== new URL(baseURI).origin) {\n    return url;\n  }\n\n  const fullUrl = fixedUrl.href;\n\n  // Remove trailing slashes, if they don't match the original URL\n  if (!url.endsWith('/') && fullUrl.endsWith('/')) {\n    return fullUrl.slice(0, -1);\n  }\n\n  return fullUrl;\n}\n\n/**\n * Capture a fetch breadcrumb to a replay.\n * This adds additional data (where appropriate).\n */\nasync function captureFetchBreadcrumbToReplay(\n  breadcrumb,\n  hint,\n  options\n\n,\n) {\n  try {\n    const data = await _prepareFetchData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.fetch', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to capture fetch breadcrumb');\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nfunction enrichFetchBreadcrumb(\n  breadcrumb,\n  hint,\n) {\n  const { input, response } = hint;\n\n  const body = input ? getFetchRequestArgBody(input) : undefined;\n  const reqSize = getBodySize(body);\n\n  const resSize = response ? parseContentLengthHeader(response.headers.get('content-length')) : undefined;\n\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\n\nasync function _prepareFetchData(\n  breadcrumb,\n  hint,\n  options,\n) {\n  const now = Date.now();\n  const { startTimestamp = now, endTimestamp = now } = hint;\n\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize,\n  } = breadcrumb.data;\n\n  const captureDetails =\n    urlMatches(url, options.networkDetailAllowUrls) && !urlMatches(url, options.networkDetailDenyUrls);\n\n  const request = captureDetails\n    ? _getRequestInfo(options, hint.input, requestBodySize)\n    : buildSkippedNetworkRequestOrResponse(requestBodySize);\n  const response = await _getResponseInfo(captureDetails, options, hint.response, responseBodySize);\n\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request,\n    response,\n  };\n}\n\nfunction _getRequestInfo(\n  { networkCaptureBodies, networkRequestHeaders },\n  input,\n  requestBodySize,\n) {\n  const headers = input ? getRequestHeaders(input, networkRequestHeaders) : {};\n\n  if (!networkCaptureBodies) {\n    return buildNetworkRequestOrResponse(headers, requestBodySize, undefined);\n  }\n\n  // We only want to transmit string or string-like bodies\n  const requestBody = getFetchRequestArgBody(input);\n  const [bodyStr, warning] = getBodyString(requestBody, logger);\n  const data = buildNetworkRequestOrResponse(headers, requestBodySize, bodyStr);\n\n  if (warning) {\n    return mergeWarning(data, warning);\n  }\n\n  return data;\n}\n\n/** Exported only for tests. */\nasync function _getResponseInfo(\n  captureDetails,\n  {\n    networkCaptureBodies,\n    networkResponseHeaders,\n  },\n  response,\n  responseBodySize,\n) {\n  if (!captureDetails && responseBodySize !== undefined) {\n    return buildSkippedNetworkRequestOrResponse(responseBodySize);\n  }\n\n  const headers = response ? getAllHeaders(response.headers, networkResponseHeaders) : {};\n\n  if (!response || (!networkCaptureBodies && responseBodySize !== undefined)) {\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n\n  const [bodyText, warning] = await _parseFetchResponseBody(response);\n  const result = getResponseData(bodyText, {\n    networkCaptureBodies,\n\n    responseBodySize,\n    captureDetails,\n    headers,\n  });\n\n  if (warning) {\n    return mergeWarning(result, warning);\n  }\n\n  return result;\n}\n\nfunction getResponseData(\n  bodyText,\n  {\n    networkCaptureBodies,\n    responseBodySize,\n    captureDetails,\n    headers,\n  }\n\n,\n) {\n  try {\n    const size = bodyText?.length && responseBodySize === undefined ? getBodySize(bodyText) : responseBodySize;\n\n    if (!captureDetails) {\n      return buildSkippedNetworkRequestOrResponse(size);\n    }\n\n    if (networkCaptureBodies) {\n      return buildNetworkRequestOrResponse(headers, size, bodyText);\n    }\n\n    return buildNetworkRequestOrResponse(headers, size, undefined);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to serialize response body');\n    // fallback\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n}\n\nasync function _parseFetchResponseBody(response) {\n  const res = _tryCloneResponse(response);\n\n  if (!res) {\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n\n  try {\n    const text = await _tryGetResponseText(res);\n    return [text];\n  } catch (error) {\n    if (error instanceof Error && error.message.indexOf('Timeout') > -1) {\n      DEBUG_BUILD && logger.warn('Parsing text body from response timed out');\n      return [undefined, 'BODY_PARSE_TIMEOUT'];\n    }\n\n    DEBUG_BUILD && logger.exception(error, 'Failed to get text body from response');\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n}\n\nfunction getAllHeaders(headers, allowedHeaders) {\n  const allHeaders = {};\n\n  allowedHeaders.forEach(header => {\n    if (headers.get(header)) {\n      allHeaders[header] = headers.get(header) ;\n    }\n  });\n\n  return allHeaders;\n}\n\nfunction getRequestHeaders(fetchArgs, allowedHeaders) {\n  if (fetchArgs.length === 1 && typeof fetchArgs[0] !== 'string') {\n    return getHeadersFromOptions(fetchArgs[0] , allowedHeaders);\n  }\n\n  if (fetchArgs.length === 2) {\n    return getHeadersFromOptions(fetchArgs[1] , allowedHeaders);\n  }\n\n  return {};\n}\n\nfunction getHeadersFromOptions(\n  input,\n  allowedHeaders,\n) {\n  if (!input) {\n    return {};\n  }\n\n  const headers = input.headers;\n\n  if (!headers) {\n    return {};\n  }\n\n  if (headers instanceof Headers) {\n    return getAllHeaders(headers, allowedHeaders);\n  }\n\n  // We do not support this, as it is not really documented (anymore?)\n  if (Array.isArray(headers)) {\n    return {};\n  }\n\n  return getAllowedHeaders(headers, allowedHeaders);\n}\n\nfunction _tryCloneResponse(response) {\n  try {\n    // We have to clone this, as the body can only be read once\n    return response.clone();\n  } catch (error) {\n    // this can throw if the response was already consumed before\n    DEBUG_BUILD && logger.exception(error, 'Failed to clone response body');\n  }\n}\n\n/**\n * Get the response body of a fetch request, or timeout after 500ms.\n * Fetch can return a streaming body, that may not resolve (or not for a long time).\n * If that happens, we rather abort after a short time than keep waiting for this.\n */\nfunction _tryGetResponseText(response) {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout$3(() => reject(new Error('Timeout while trying to read response body')), 500);\n\n    _getResponseText(response)\n      .then(\n        txt => resolve(txt),\n        reason => reject(reason),\n      )\n      .finally(() => clearTimeout(timeout));\n  });\n}\n\nasync function _getResponseText(response) {\n  // Force this to be a promise, just to be safe\n  // eslint-disable-next-line no-return-await\n  return await response.text();\n}\n\n/**\n * Capture an XHR breadcrumb to a replay.\n * This adds additional data (where appropriate).\n */\nasync function captureXhrBreadcrumbToReplay(\n  breadcrumb,\n  hint,\n  options,\n) {\n  try {\n    const data = _prepareXhrData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.xhr', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to capture xhr breadcrumb');\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nfunction enrichXhrBreadcrumb(\n  breadcrumb,\n  hint,\n) {\n  const { xhr, input } = hint;\n\n  if (!xhr) {\n    return;\n  }\n\n  const reqSize = getBodySize(input);\n  const resSize = xhr.getResponseHeader('content-length')\n    ? parseContentLengthHeader(xhr.getResponseHeader('content-length'))\n    : _getBodySize(xhr.response, xhr.responseType);\n\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\n\nfunction _prepareXhrData(\n  breadcrumb,\n  hint,\n  options,\n) {\n  const now = Date.now();\n  const { startTimestamp = now, endTimestamp = now, input, xhr } = hint;\n\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize,\n  } = breadcrumb.data;\n\n  if (!url) {\n    return null;\n  }\n\n  if (!xhr || !urlMatches(url, options.networkDetailAllowUrls) || urlMatches(url, options.networkDetailDenyUrls)) {\n    const request = buildSkippedNetworkRequestOrResponse(requestBodySize);\n    const response = buildSkippedNetworkRequestOrResponse(responseBodySize);\n    return {\n      startTimestamp,\n      endTimestamp,\n      url,\n      method,\n      statusCode,\n      request,\n      response,\n    };\n  }\n\n  // ---- This additional network data below is only captured for URLs defined in `networkDetailAllowUrls` ----\n\n  const xhrInfo = xhr[SENTRY_XHR_DATA_KEY];\n  const networkRequestHeaders = xhrInfo\n    ? getAllowedHeaders(xhrInfo.request_headers, options.networkRequestHeaders)\n    : {};\n  const networkResponseHeaders = getAllowedHeaders(getResponseHeaders(xhr), options.networkResponseHeaders);\n\n  const [requestBody, requestWarning] = options.networkCaptureBodies ? getBodyString(input, logger) : [undefined];\n  const [responseBody, responseWarning] = options.networkCaptureBodies ? _getXhrResponseBody(xhr) : [undefined];\n\n  const request = buildNetworkRequestOrResponse(networkRequestHeaders, requestBodySize, requestBody);\n  const response = buildNetworkRequestOrResponse(networkResponseHeaders, responseBodySize, responseBody);\n\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request: requestWarning ? mergeWarning(request, requestWarning) : request,\n    response: responseWarning ? mergeWarning(response, responseWarning) : response,\n  };\n}\n\nfunction getResponseHeaders(xhr) {\n  const headers = xhr.getAllResponseHeaders();\n\n  if (!headers) {\n    return {};\n  }\n\n  return headers.split('\\r\\n').reduce((acc, line) => {\n    const [key, value] = line.split(': ') ;\n    if (value) {\n      acc[key.toLowerCase()] = value;\n    }\n    return acc;\n  }, {});\n}\n\nfunction _getXhrResponseBody(xhr) {\n  // We collect errors that happen, but only log them if we can't get any response body\n  const errors = [];\n\n  try {\n    return [xhr.responseText];\n  } catch (e) {\n    errors.push(e);\n  }\n\n  // Try to manually parse the response body, if responseText fails\n  try {\n    return _parseXhrResponse(xhr.response, xhr.responseType);\n  } catch (e) {\n    errors.push(e);\n  }\n\n  DEBUG_BUILD && logger.warn('Failed to get xhr response body', ...errors);\n\n  return [undefined];\n}\n\n/**\n * Get the string representation of the XHR response.\n * Based on MDN, these are the possible types of the response:\n * string\n * ArrayBuffer\n * Blob\n * Document\n * POJO\n *\n * Exported only for tests.\n */\nfunction _parseXhrResponse(\n  body,\n  responseType,\n) {\n  try {\n    if (typeof body === 'string') {\n      return [body];\n    }\n\n    if (body instanceof Document) {\n      return [body.body.outerHTML];\n    }\n\n    if (responseType === 'json' && body && typeof body === 'object') {\n      return [JSON.stringify(body)];\n    }\n\n    if (!body) {\n      return [undefined];\n    }\n  } catch (error) {\n    DEBUG_BUILD && logger.exception(error, 'Failed to serialize body', body);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n\n  DEBUG_BUILD && logger.info('Skipping network body because of body type', body);\n\n  return [undefined, 'UNPARSEABLE_BODY_TYPE'];\n}\n\nfunction _getBodySize(\n  body,\n  responseType,\n) {\n  try {\n    const bodyStr = responseType === 'json' && body && typeof body === 'object' ? JSON.stringify(body) : body;\n    return getBodySize(bodyStr);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * This method does two things:\n * - It enriches the regular XHR/fetch breadcrumbs with request/response size data\n * - It captures the XHR/fetch breadcrumbs to the replay\n *   (enriching it with further data that is _not_ added to the regular breadcrumbs)\n */\nfunction handleNetworkBreadcrumbs(replay) {\n  const client = getClient();\n\n  try {\n    const {\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders,\n    } = replay.getOptions();\n\n    const options = {\n      replay,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders,\n    };\n\n    if (client) {\n      client.on('beforeAddBreadcrumb', (breadcrumb, hint) => beforeAddNetworkBreadcrumb(options, breadcrumb, hint));\n    }\n  } catch {\n    // Do nothing\n  }\n}\n\n/** just exported for tests */\nfunction beforeAddNetworkBreadcrumb(\n  options,\n  breadcrumb,\n  hint,\n) {\n  if (!breadcrumb.data) {\n    return;\n  }\n\n  try {\n    if (_isXhrBreadcrumb(breadcrumb) && _isXhrHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichXhrBreadcrumb(breadcrumb, hint);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureXhrBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n\n    if (_isFetchBreadcrumb(breadcrumb) && _isFetchHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichFetchBreadcrumb(breadcrumb, hint);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureFetchBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n  } catch (e) {\n    DEBUG_BUILD && logger.exception(e, 'Error when enriching network breadcrumb');\n  }\n}\n\nfunction _isXhrBreadcrumb(breadcrumb) {\n  return breadcrumb.category === 'xhr';\n}\n\nfunction _isFetchBreadcrumb(breadcrumb) {\n  return breadcrumb.category === 'fetch';\n}\n\nfunction _isXhrHint(hint) {\n  return hint?.xhr;\n}\n\nfunction _isFetchHint(hint) {\n  return hint?.response;\n}\n\n/**\n * Add global listeners that cannot be removed.\n */\nfunction addGlobalListeners(\n  replay,\n  { autoFlushOnFeedback },\n) {\n  // Listeners from core SDK //\n  const client = getClient();\n\n  addClickKeypressInstrumentationHandler(handleDomListener(replay));\n  addHistoryInstrumentationHandler(handleHistorySpanListener(replay));\n  handleBreadcrumbs(replay);\n  handleNetworkBreadcrumbs(replay);\n\n  // Tag all (non replay) events that get sent to Sentry with the current\n  // replay ID so that we can reference them later in the UI\n  const eventProcessor = handleGlobalEventListener(replay);\n  addEventProcessor(eventProcessor);\n\n  // If a custom client has no hooks yet, we continue to use the \"old\" implementation\n  if (client) {\n    client.on('beforeSendEvent', handleBeforeSendEvent(replay));\n    client.on('afterSendEvent', handleAfterSendEvent(replay));\n    client.on('createDsc', (dsc) => {\n      const replayId = replay.getSessionId();\n      // We do not want to set the DSC when in buffer mode, as that means the replay has not been sent (yet)\n      if (replayId && replay.isEnabled() && replay.recordingMode === 'session') {\n        // Ensure to check that the session is still active - it could have expired in the meanwhile\n        const isSessionActive = replay.checkAndHandleExpiredSession();\n        if (isSessionActive) {\n          dsc.replay_id = replayId;\n        }\n      }\n    });\n\n    client.on('spanStart', span => {\n      replay.lastActiveSpan = span;\n    });\n\n    // We may be missing the initial spanStart due to timing issues,\n    // so we capture it on finish again.\n    client.on('spanEnd', span => {\n      replay.lastActiveSpan = span;\n    });\n\n    // We want to attach the replay id to the feedback event\n    client.on('beforeSendFeedback', async (feedbackEvent, options) => {\n      const replayId = replay.getSessionId();\n      if (options?.includeReplay && replay.isEnabled() && replayId && feedbackEvent.contexts?.feedback) {\n        // In case the feedback is sent via API and not through our widget, we want to flush replay\n        if (feedbackEvent.contexts.feedback.source === 'api' && autoFlushOnFeedback) {\n          await replay.flush();\n        }\n        feedbackEvent.contexts.feedback.replay_id = replayId;\n      }\n    });\n\n    if (autoFlushOnFeedback) {\n      client.on('openFeedbackWidget', async () => {\n        await replay.flush();\n      });\n    }\n  }\n}\n\n/**\n * Create a \"span\" for the total amount of memory being used by JS objects\n * (including v8 internal objects).\n */\nasync function addMemoryEntry(replay) {\n  // window.performance.memory is a non-standard API and doesn't work on all browsers, so we try-catch this\n  try {\n    return Promise.all(\n      createPerformanceSpans(replay, [\n        // @ts-expect-error memory doesn't exist on type Performance as the API is non-standard (we check that it exists above)\n        createMemoryEntry(WINDOW.performance.memory),\n      ]),\n    );\n  } catch (error) {\n    // Do nothing\n    return [];\n  }\n}\n\nfunction createMemoryEntry(memoryEntry) {\n  const { jsHeapSizeLimit, totalJSHeapSize, usedJSHeapSize } = memoryEntry;\n  // we don't want to use `getAbsoluteTime` because it adds the event time to the\n  // time origin, so we get the current timestamp instead\n  const time = Date.now() / 1000;\n  return {\n    type: 'memory',\n    name: 'memory',\n    start: time,\n    end: time,\n    data: {\n      memory: {\n        jsHeapSizeLimit,\n        totalJSHeapSize,\n        usedJSHeapSize,\n      },\n    },\n  };\n}\n\n/**\n * Heavily simplified debounce function based on lodash.debounce.\n *\n * This function takes a callback function (@param fun) and delays its invocation\n * by @param wait milliseconds. Optionally, a maxWait can be specified in @param options,\n * which ensures that the callback is invoked at least once after the specified max. wait time.\n *\n * @param func the function whose invocation is to be debounced\n * @param wait the minimum time until the function is invoked after it was called once\n * @param options the options object, which can contain the `maxWait` property\n *\n * @returns the debounced version of the function, which needs to be called at least once to start the\n *          debouncing process. Subsequent calls will reset the debouncing timer and, in case @paramfunc\n *          was already invoked in the meantime, return @param func's return value.\n *          The debounced function has two additional properties:\n *          - `flush`: Invokes the debounced function immediately and returns its return value\n *          - `cancel`: Cancels the debouncing process and resets the debouncing timer\n */\nfunction debounce(func, wait, options) {\n  let callbackReturnValue;\n\n  let timerId;\n  let maxTimerId;\n\n  const maxWait = options?.maxWait ? Math.max(options.maxWait, wait) : 0;\n\n  function invokeFunc() {\n    cancelTimers();\n    callbackReturnValue = func();\n    return callbackReturnValue;\n  }\n\n  function cancelTimers() {\n    timerId !== undefined && clearTimeout(timerId);\n    maxTimerId !== undefined && clearTimeout(maxTimerId);\n    timerId = maxTimerId = undefined;\n  }\n\n  function flush() {\n    if (timerId !== undefined || maxTimerId !== undefined) {\n      return invokeFunc();\n    }\n    return callbackReturnValue;\n  }\n\n  function debounced() {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout$3(invokeFunc, wait);\n\n    if (maxWait && maxTimerId === undefined) {\n      maxTimerId = setTimeout$3(invokeFunc, maxWait);\n    }\n\n    return callbackReturnValue;\n  }\n\n  debounced.cancel = cancelTimers;\n  debounced.flush = flush;\n  return debounced;\n}\n\nconst NAVIGATOR = GLOBAL_OBJ.navigator;\n\n/**\n *  Disable sampling mousemove events on iOS browsers as this can cause blocking the main thread\n *  https://github.com/getsentry/sentry-javascript/issues/14534\n */\nfunction getRecordingSamplingOptions() {\n  if (\n    /iPhone|iPad|iPod/i.test(NAVIGATOR?.userAgent ?? '') ||\n    (/Macintosh/i.test(NAVIGATOR?.userAgent ?? '') && NAVIGATOR?.maxTouchPoints && NAVIGATOR?.maxTouchPoints > 1)\n  ) {\n    return {\n      sampling: {\n        mousemove: false,\n      },\n    };\n  }\n\n  return {};\n}\n\n/**\n * Handler for recording events.\n *\n * Adds to event buffer, and has varying flushing behaviors if the event was a checkout.\n */\nfunction getHandleRecordingEmit(replay) {\n  let hadFirstEvent = false;\n\n  return (event, _isCheckout) => {\n    // If this is false, it means session is expired, create and a new session and wait for checkout\n    if (!replay.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.warn('Received replay event after session expired.');\n\n      return;\n    }\n\n    // `_isCheckout` is only set when the checkout is due to `checkoutEveryNms`\n    // We also want to treat the first event as a checkout, so we handle this specifically here\n    const isCheckout = _isCheckout || !hadFirstEvent;\n    hadFirstEvent = true;\n\n    if (replay.clickDetector) {\n      updateClickDetectorForRecordingEvent(replay.clickDetector, event);\n    }\n\n    // The handler returns `true` if we do not want to trigger debounced flush, `false` if we want to debounce flush.\n    replay.addUpdate(() => {\n      // The session is always started immediately on pageload/init, but for\n      // error-only replays, it should reflect the most recent checkout\n      // when an error occurs. Clear any state that happens before this current\n      // checkout. This needs to happen before `addEvent()` which updates state\n      // dependent on this reset.\n      if (replay.recordingMode === 'buffer' && isCheckout) {\n        replay.setInitialState();\n      }\n\n      // If the event is not added (e.g. due to being paused, disabled, or out of the max replay duration),\n      // Skip all further steps\n      if (!addEventSync(replay, event, isCheckout)) {\n        // Return true to skip scheduling a debounced flush\n        return true;\n      }\n\n      // Different behavior for full snapshots (type=2), ignore other event types\n      // See https://github.com/rrweb-io/rrweb/blob/d8f9290ca496712aa1e7d472549480c4e7876594/packages/rrweb/src/types.ts#L16\n      if (!isCheckout) {\n        return false;\n      }\n\n      const session = replay.session;\n\n      // Additionally, create a meta event that will capture certain SDK settings.\n      // In order to handle buffer mode, this needs to either be done when we\n      // receive checkout events or at flush time. We have an experimental mode\n      // to perform multiple checkouts a session (the idea is to improve\n      // seeking during playback), so also only include if segmentId is 0\n      // (handled in `addSettingsEvent`).\n      //\n      // `isCheckout` is always true, but want to be explicit that it should\n      // only be added for checkouts\n      addSettingsEvent(replay, isCheckout);\n\n      // When in buffer mode, make sure we adjust the session started date to the current earliest event of the buffer\n      // this should usually be the timestamp of the checkout event, but to be safe...\n      if (replay.recordingMode === 'buffer' && session && replay.eventBuffer) {\n        const earliestEvent = replay.eventBuffer.getEarliestTimestamp();\n        if (earliestEvent) {\n          DEBUG_BUILD &&\n            logger.info(`Updating session start time to earliest event in buffer to ${new Date(earliestEvent)}`);\n\n          session.started = earliestEvent;\n\n          if (replay.getOptions().stickySession) {\n            saveSession(session);\n          }\n        }\n      }\n\n      // If there is a previousSessionId after a full snapshot occurs, then\n      // the replay session was started due to session expiration. The new session\n      // is started before triggering a new checkout and contains the id\n      // of the previous session. Do not immediately flush in this case\n      // to avoid capturing only the checkout and instead the replay will\n      // be captured if they perform any follow-up actions.\n      if (session?.previousSessionId) {\n        return true;\n      }\n\n      if (replay.recordingMode === 'session') {\n        // If the full snapshot is due to an initial load, we will not have\n        // a previous session ID. In this case, we want to buffer events\n        // for a set amount of time before flushing. This can help avoid\n        // capturing replays of users that immediately close the window.\n\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        void replay.flush();\n      }\n\n      return true;\n    });\n  };\n}\n\n/**\n * Exported for tests\n */\nfunction createOptionsEvent(replay) {\n  const options = replay.getOptions();\n  return {\n    type: EventType.Custom,\n    timestamp: Date.now(),\n    data: {\n      tag: 'options',\n      payload: {\n        shouldRecordCanvas: replay.isRecordingCanvas(),\n        sessionSampleRate: options.sessionSampleRate,\n        errorSampleRate: options.errorSampleRate,\n        useCompressionOption: options.useCompression,\n        blockAllMedia: options.blockAllMedia,\n        maskAllText: options.maskAllText,\n        maskAllInputs: options.maskAllInputs,\n        useCompression: replay.eventBuffer ? replay.eventBuffer.type === 'worker' : false,\n        networkDetailHasUrls: options.networkDetailAllowUrls.length > 0,\n        networkCaptureBodies: options.networkCaptureBodies,\n        networkRequestHasHeaders: options.networkRequestHeaders.length > 0,\n        networkResponseHasHeaders: options.networkResponseHeaders.length > 0,\n      },\n    },\n  };\n}\n\n/**\n * Add a \"meta\" event that contains a simplified view on current configuration\n * options. This should only be included on the first segment of a recording.\n */\nfunction addSettingsEvent(replay, isCheckout) {\n  // Only need to add this event when sending the first segment\n  if (!isCheckout || !replay.session || replay.session.segmentId !== 0) {\n    return;\n  }\n\n  addEventSync(replay, createOptionsEvent(replay), false);\n}\n\n/**\n * Create a replay envelope ready to be sent.\n * This includes both the replay event, as well as the recording data.\n */\nfunction createReplayEnvelope(\n  replayEvent,\n  recordingData,\n  dsn,\n  tunnel,\n) {\n  return createEnvelope(\n    createEventEnvelopeHeaders(replayEvent, getSdkMetadataForEnvelopeHeader(replayEvent), tunnel, dsn),\n    [\n      [{ type: 'replay_event' }, replayEvent],\n      [\n        {\n          type: 'replay_recording',\n          // If string then we need to encode to UTF8, otherwise will have\n          // wrong size. TextEncoder has similar browser support to\n          // MutationObserver, although it does not accept IE11.\n          length:\n            typeof recordingData === 'string' ? new TextEncoder().encode(recordingData).length : recordingData.length,\n        },\n        recordingData,\n      ],\n    ],\n  );\n}\n\n/**\n * Prepare the recording data ready to be sent.\n */\nfunction prepareRecordingData({\n  recordingData,\n  headers,\n}\n\n) {\n  let payloadWithSequence;\n\n  // XXX: newline is needed to separate sequence id from events\n  const replayHeaders = `${JSON.stringify(headers)}\n`;\n\n  if (typeof recordingData === 'string') {\n    payloadWithSequence = `${replayHeaders}${recordingData}`;\n  } else {\n    const enc = new TextEncoder();\n    // XXX: newline is needed to separate sequence id from events\n    const sequence = enc.encode(replayHeaders);\n    // Merge the two Uint8Arrays\n    payloadWithSequence = new Uint8Array(sequence.length + recordingData.length);\n    payloadWithSequence.set(sequence);\n    payloadWithSequence.set(recordingData, sequence.length);\n  }\n\n  return payloadWithSequence;\n}\n\n/**\n * Prepare a replay event & enrich it with the SDK metadata.\n */\nasync function prepareReplayEvent({\n  client,\n  scope,\n  replayId: event_id,\n  event,\n}\n\n) {\n  const integrations =\n    typeof client['_integrations'] === 'object' &&\n    client['_integrations'] !== null &&\n    !Array.isArray(client['_integrations'])\n      ? Object.keys(client['_integrations'])\n      : undefined;\n\n  const eventHint = { event_id, integrations };\n\n  client.emit('preprocessEvent', event, eventHint);\n\n  const preparedEvent = (await prepareEvent(\n    client.getOptions(),\n    event,\n    eventHint,\n    scope,\n    client,\n    getIsolationScope(),\n  )) ;\n\n  // If e.g. a global event processor returned null\n  if (!preparedEvent) {\n    return null;\n  }\n\n  client.emit('postprocessEvent', preparedEvent, eventHint);\n\n  // This normally happens in browser client \"_prepareEvent\"\n  // but since we do not use this private method from the client, but rather the plain import\n  // we need to do this manually.\n  preparedEvent.platform = preparedEvent.platform || 'javascript';\n\n  // extract the SDK name because `client._prepareEvent` doesn't add it to the event\n  const metadata = client.getSdkMetadata();\n  const { name, version } = metadata?.sdk || {};\n\n  preparedEvent.sdk = {\n    ...preparedEvent.sdk,\n    name: name || 'sentry.javascript.unknown',\n    version: version || '0.0.0',\n  };\n\n  return preparedEvent;\n}\n\n/**\n * Send replay attachment using `fetch()`\n */\nasync function sendReplayRequest({\n  recordingData,\n  replayId,\n  segmentId: segment_id,\n  eventContext,\n  timestamp,\n  session,\n}) {\n  const preparedRecordingData = prepareRecordingData({\n    recordingData,\n    headers: {\n      segment_id,\n    },\n  });\n\n  const { urls, errorIds, traceIds, initialTimestamp } = eventContext;\n\n  const client = getClient();\n  const scope = getCurrentScope();\n  const transport = client?.getTransport();\n  const dsn = client?.getDsn();\n\n  if (!client || !transport || !dsn || !session.sampled) {\n    return resolvedSyncPromise({});\n  }\n\n  const baseEvent = {\n    type: REPLAY_EVENT_NAME,\n    replay_start_timestamp: initialTimestamp / 1000,\n    timestamp: timestamp / 1000,\n    error_ids: errorIds,\n    trace_ids: traceIds,\n    urls,\n    replay_id: replayId,\n    segment_id,\n    replay_type: session.sampled,\n  };\n\n  const replayEvent = await prepareReplayEvent({ scope, client, replayId, event: baseEvent });\n\n  if (!replayEvent) {\n    // Taken from baseclient's `_processEvent` method, where this is handled for errors/transactions\n    client.recordDroppedEvent('event_processor', 'replay');\n    DEBUG_BUILD && logger.info('An event processor returned `null`, will not send event.');\n    return resolvedSyncPromise({});\n  }\n\n  /*\n  For reference, the fully built event looks something like this:\n  {\n      \"type\": \"replay_event\",\n      \"timestamp\": 1670837008.634,\n      \"error_ids\": [\n          \"errorId\"\n      ],\n      \"trace_ids\": [\n          \"traceId\"\n      ],\n      \"urls\": [\n          \"https://example.com\"\n      ],\n      \"replay_id\": \"eventId\",\n      \"segment_id\": 3,\n      \"replay_type\": \"error\",\n      \"platform\": \"javascript\",\n      \"event_id\": \"eventId\",\n      \"environment\": \"production\",\n      \"sdk\": {\n          \"integrations\": [\n              \"BrowserTracing\",\n              \"Replay\"\n          ],\n          \"name\": \"sentry.javascript.browser\",\n          \"version\": \"7.25.0\"\n      },\n      \"sdkProcessingMetadata\": {},\n      \"contexts\": {\n      },\n  }\n  */\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete replayEvent.sdkProcessingMetadata;\n\n  const envelope = createReplayEnvelope(replayEvent, preparedRecordingData, dsn, client.getOptions().tunnel);\n\n  let response;\n\n  try {\n    response = await transport.send(envelope);\n  } catch (err) {\n    const error = new Error(UNABLE_TO_SEND_REPLAY);\n\n    try {\n      // In case browsers don't allow this property to be writable\n      // @ts-expect-error This needs lib es2022 and newer\n      error.cause = err;\n    } catch {\n      // nothing to do\n    }\n    throw error;\n  }\n\n  // If the status code is invalid, we want to immediately stop & not retry\n  if (typeof response.statusCode === 'number' && (response.statusCode < 200 || response.statusCode >= 300)) {\n    throw new TransportStatusCodeError(response.statusCode);\n  }\n\n  const rateLimits = updateRateLimits({}, response);\n  if (isRateLimited(rateLimits, 'replay')) {\n    throw new RateLimitError(rateLimits);\n  }\n\n  return response;\n}\n\n/**\n * This error indicates that the transport returned an invalid status code.\n */\nclass TransportStatusCodeError extends Error {\n   constructor(statusCode) {\n    super(`Transport returned status code ${statusCode}`);\n  }\n}\n\n/**\n * This error indicates that we hit a rate limit API error.\n */\nclass RateLimitError extends Error {\n\n   constructor(rateLimits) {\n    super('Rate limit hit');\n    this.rateLimits = rateLimits;\n  }\n}\n\n/**\n * Finalize and send the current replay event to Sentry\n */\nasync function sendReplay(\n  replayData,\n  retryConfig = {\n    count: 0,\n    interval: RETRY_BASE_INTERVAL,\n  },\n) {\n  const { recordingData, onError } = replayData;\n\n  // short circuit if there's no events to upload (this shouldn't happen as _runFlush makes this check)\n  if (!recordingData.length) {\n    return;\n  }\n\n  try {\n    await sendReplayRequest(replayData);\n    return true;\n  } catch (err) {\n    if (err instanceof TransportStatusCodeError || err instanceof RateLimitError) {\n      throw err;\n    }\n\n    // Capture error for every failed replay\n    setContext('Replays', {\n      _retryCount: retryConfig.count,\n    });\n\n    if (onError) {\n      onError(err);\n    }\n\n    // If an error happened here, it's likely that uploading the attachment\n    // failed, we'll can retry with the same events payload\n    if (retryConfig.count >= RETRY_MAX_COUNT) {\n      const error = new Error(`${UNABLE_TO_SEND_REPLAY} - max retries exceeded`);\n\n      try {\n        // In case browsers don't allow this property to be writable\n        // @ts-expect-error This needs lib es2022 and newer\n        error.cause = err;\n      } catch {\n        // nothing to do\n      }\n\n      throw error;\n    }\n\n    // will retry in intervals of 5, 10, 30\n    retryConfig.interval *= ++retryConfig.count;\n\n    return new Promise((resolve, reject) => {\n      setTimeout$3(async () => {\n        try {\n          await sendReplay(replayData, retryConfig);\n          resolve(true);\n        } catch (err) {\n          reject(err);\n        }\n      }, retryConfig.interval);\n    });\n  }\n}\n\nconst THROTTLED = '__THROTTLED';\nconst SKIPPED = '__SKIPPED';\n\n/**\n * Create a throttled function off a given function.\n * When calling the throttled function, it will call the original function only\n * if it hasn't been called more than `maxCount` times in the last `durationSeconds`.\n *\n * Returns `THROTTLED` if throttled for the first time, after that `SKIPPED`,\n * or else the return value of the original function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction throttle(\n  fn,\n  maxCount,\n  durationSeconds,\n) {\n  const counter = new Map();\n\n  const _cleanup = (now) => {\n    const threshold = now - durationSeconds;\n    counter.forEach((_value, key) => {\n      if (key < threshold) {\n        counter.delete(key);\n      }\n    });\n  };\n\n  const _getTotalCount = () => {\n    return [...counter.values()].reduce((a, b) => a + b, 0);\n  };\n\n  let isThrottled = false;\n\n  return (...rest) => {\n    // Date in second-precision, which we use as basis for the throttling\n    const now = Math.floor(Date.now() / 1000);\n\n    // First, make sure to delete any old entries\n    _cleanup(now);\n\n    // If already over limit, do nothing\n    if (_getTotalCount() >= maxCount) {\n      const wasThrottled = isThrottled;\n      isThrottled = true;\n      return wasThrottled ? SKIPPED : THROTTLED;\n    }\n\n    isThrottled = false;\n    const count = counter.get(now) || 0;\n    counter.set(now, count + 1);\n\n    return fn(...rest);\n  };\n}\n\n/**\n * The main replay container class, which holds all the state and methods for recording and sending replays.\n */\nclass ReplayContainer  {\n\n  /**\n   * Recording can happen in one of two modes:\n   *   - session: Record the whole session, sending it continuously\n   *   - buffer: Always keep the last 60s of recording, requires:\n   *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *     - or calling `flush()` to send the replay\n   */\n\n  /**\n   * The current or last active span.\n   * This is only available when performance is enabled.\n   */\n\n  /**\n   * These are here so we can overwrite them in tests etc.\n   * @hidden\n   */\n\n  /** The replay has to be manually started, because no sample rate (neither session or error) was provided. */\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n\n  /**\n   * Timestamp of the last user activity. This lives across sessions.\n   */\n\n  /**\n   * Is the integration currently active?\n   */\n\n  /**\n   * Paused is a state where:\n   * - DOM Recording is not listening at all\n   * - Nothing will be added to event buffer (e.g. core SDK events)\n   */\n\n  /**\n   * Have we attached listeners to the core SDK?\n   * Note we have to track this as there is no way to remove instrumentation handlers.\n   */\n\n  /**\n   * Function to stop recording\n   */\n\n  /**\n   * Internal use for canvas recording options\n   */\n\n  /**\n   * Handle when visibility of the page content changes. Opening a new tab will\n   * cause the state to change to hidden because of content of current page will\n   * be hidden. Likewise, moving a different window to cover the contents of the\n   * page will also trigger a change to a hidden state.\n   */\n\n  /**\n   * Handle when page is blurred\n   */\n\n  /**\n   * Handle when page is focused\n   */\n\n  /** Ensure page remains active when a key is pressed. */\n\n   constructor({\n    options,\n    recordingOptions,\n  }\n\n) {\n    this.eventBuffer = null;\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n    this.recordingMode = 'session';\n    this.timeouts = {\n      sessionIdlePause: SESSION_IDLE_PAUSE_DURATION,\n      sessionIdleExpire: SESSION_IDLE_EXPIRE_DURATION,\n    } ;\n    this._lastActivity = Date.now();\n    this._isEnabled = false;\n    this._isPaused = false;\n    this._requiresManualStart = false;\n    this._hasInitializedCoreListeners = false;\n    this._context = {\n      errorIds: new Set(),\n      traceIds: new Set(),\n      urls: [],\n      initialTimestamp: Date.now(),\n      initialUrl: '',\n    };\n\n    this._recordingOptions = recordingOptions;\n    this._options = options;\n\n    this._debouncedFlush = debounce(() => this._flush(), this._options.flushMinDelay, {\n      maxWait: this._options.flushMaxDelay,\n    });\n\n    this._throttledAddEvent = throttle(\n      (event, isCheckout) => addEvent(this, event, isCheckout),\n      // Max 300 events...\n      300,\n      // ... per 5s\n      5,\n    );\n\n    const { slowClickTimeout, slowClickIgnoreSelectors } = this.getOptions();\n\n    const slowClickConfig = slowClickTimeout\n      ? {\n          threshold: Math.min(SLOW_CLICK_THRESHOLD, slowClickTimeout),\n          timeout: slowClickTimeout,\n          scrollTimeout: SLOW_CLICK_SCROLL_TIMEOUT,\n          ignoreSelector: slowClickIgnoreSelectors ? slowClickIgnoreSelectors.join(',') : '',\n        }\n      : undefined;\n\n    if (slowClickConfig) {\n      this.clickDetector = new ClickDetector(this, slowClickConfig);\n    }\n\n    // Configure replay logger w/ experimental options\n    if (DEBUG_BUILD) {\n      const experiments = options._experiments;\n      logger.setConfig({\n        captureExceptions: !!experiments.captureExceptions,\n        traceInternals: !!experiments.traceInternals,\n      });\n    }\n\n    // We set these handler properties as class properties, to make binding/unbinding them easier\n    this._handleVisibilityChange = () => {\n      if (WINDOW.document.visibilityState === 'visible') {\n        this._doChangeToForegroundTasks();\n      } else {\n        this._doChangeToBackgroundTasks();\n      }\n    };\n\n    /**\n     * Handle when page is blurred\n     */\n    this._handleWindowBlur = () => {\n      const breadcrumb = createBreadcrumb({\n        category: 'ui.blur',\n      });\n\n      // Do not count blur as a user action -- it's part of the process of them\n      // leaving the page\n      this._doChangeToBackgroundTasks(breadcrumb);\n    };\n\n    this._handleWindowFocus = () => {\n      const breadcrumb = createBreadcrumb({\n        category: 'ui.focus',\n      });\n\n      // Do not count focus as a user action -- instead wait until they focus and\n      // interactive with page\n      this._doChangeToForegroundTasks(breadcrumb);\n    };\n\n    /** Ensure page remains active when a key is pressed. */\n    this._handleKeyboardEvent = (event) => {\n      handleKeyboardEvent(this, event);\n    };\n  }\n\n  /** Get the event context. */\n   getContext() {\n    return this._context;\n  }\n\n  /** If recording is currently enabled. */\n   isEnabled() {\n    return this._isEnabled;\n  }\n\n  /** If recording is currently paused. */\n   isPaused() {\n    return this._isPaused;\n  }\n\n  /**\n   * Determine if canvas recording is enabled\n   */\n   isRecordingCanvas() {\n    return Boolean(this._canvas);\n  }\n\n  /** Get the replay integration options. */\n   getOptions() {\n    return this._options;\n  }\n\n  /** A wrapper to conditionally capture exceptions. */\n   handleException(error) {\n    DEBUG_BUILD && logger.exception(error);\n    if (this._options.onError) {\n      this._options.onError(error);\n    }\n  }\n\n  /**\n   * Initializes the plugin based on sampling configuration. Should not be\n   * called outside of constructor.\n   */\n   initializeSampling(previousSessionId) {\n    const { errorSampleRate, sessionSampleRate } = this._options;\n\n    // If neither sample rate is > 0, then do nothing - user will need to call one of\n    // `start()` or `startBuffering` themselves.\n    const requiresManualStart = errorSampleRate <= 0 && sessionSampleRate <= 0;\n\n    this._requiresManualStart = requiresManualStart;\n\n    if (requiresManualStart) {\n      return;\n    }\n\n    // Otherwise if there is _any_ sample rate set, try to load an existing\n    // session, or create a new one.\n    this._initializeSessionForSampling(previousSessionId);\n\n    if (!this.session) {\n      // This should not happen, something wrong has occurred\n      DEBUG_BUILD && logger.exception(new Error('Unable to initialize and create session'));\n      return;\n    }\n\n    if (this.session.sampled === false) {\n      // This should only occur if `errorSampleRate` is 0 and was unsampled for\n      // session-based replay. In this case there is nothing to do.\n      return;\n    }\n\n    // If segmentId > 0, it means we've previously already captured this session\n    // In this case, we still want to continue in `session` recording mode\n    this.recordingMode = this.session.sampled === 'buffer' && this.session.segmentId === 0 ? 'buffer' : 'session';\n\n    DEBUG_BUILD && logger.infoTick(`Starting replay in ${this.recordingMode} mode`);\n\n    this._initializeRecording();\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will log a message if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * _performanceObserver, Recording, Sentry SDK, etc)\n   */\n   start() {\n    if (this._isEnabled && this.recordingMode === 'session') {\n      DEBUG_BUILD && logger.info('Recording is already in progress');\n      return;\n    }\n\n    if (this._isEnabled && this.recordingMode === 'buffer') {\n      DEBUG_BUILD && logger.info('Buffering is in progress, call `flush()` to save the replay');\n      return;\n    }\n\n    DEBUG_BUILD && logger.infoTick('Starting replay in session mode');\n\n    // Required as user activity is initially set in\n    // constructor, so if `start()` is called after\n    // session idle expiration, a replay will not be\n    // created due to an idle timeout.\n    this._updateUserActivity();\n\n    const session = loadOrCreateSession(\n      {\n        maxReplayDuration: this._options.maxReplayDuration,\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      },\n      {\n        stickySession: this._options.stickySession,\n        // This is intentional: create a new session-based replay when calling `start()`\n        sessionSampleRate: 1,\n        allowBuffering: false,\n      },\n    );\n\n    this.session = session;\n\n    this._initializeRecording();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, an error occurs.\n   */\n   startBuffering() {\n    if (this._isEnabled) {\n      DEBUG_BUILD && logger.info('Buffering is in progress, call `flush()` to save the replay');\n      return;\n    }\n\n    DEBUG_BUILD && logger.infoTick('Starting replay in buffer mode');\n\n    const session = loadOrCreateSession(\n      {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n      },\n      {\n        stickySession: this._options.stickySession,\n        sessionSampleRate: 0,\n        allowBuffering: true,\n      },\n    );\n\n    this.session = session;\n\n    this.recordingMode = 'buffer';\n    this._initializeRecording();\n  }\n\n  /**\n   * Start recording.\n   *\n   * Note that this will cause a new DOM checkout\n   */\n   startRecording() {\n    try {\n      const canvasOptions = this._canvas;\n\n      this._stopRecording = record({\n        ...this._recordingOptions,\n        // When running in error sampling mode, we need to overwrite `checkoutEveryNms`\n        // Without this, it would record forever, until an error happens, which we don't want\n        // instead, we'll always keep the last 60 seconds of replay before an error happened\n        ...(this.recordingMode === 'buffer'\n          ? { checkoutEveryNms: BUFFER_CHECKOUT_TIME }\n          : // Otherwise, use experimental option w/ min checkout time of 6 minutes\n            // This is to improve playback seeking as there could potentially be\n            // less mutations to process in the worse cases.\n            //\n            // checkout by \"N\" events is probably ideal, but means we have less\n            // control about the number of checkouts we make (which generally\n            // increases replay size)\n            this._options._experiments.continuousCheckout && {\n              // Minimum checkout time is 6 minutes\n              checkoutEveryNms: Math.max(360000, this._options._experiments.continuousCheckout),\n            }),\n        emit: getHandleRecordingEmit(this),\n        ...getRecordingSamplingOptions(),\n        onMutation: this._onMutationHandler.bind(this),\n        ...(canvasOptions\n          ? {\n              recordCanvas: canvasOptions.recordCanvas,\n              getCanvasManager: canvasOptions.getCanvasManager,\n              sampling: canvasOptions.sampling,\n              dataURLOptions: canvasOptions.dataURLOptions,\n            }\n          : {}),\n      });\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Stops the recording, if it was running.\n   *\n   * Returns true if it was previously stopped, or is now stopped,\n   * otherwise false.\n   */\n   stopRecording() {\n    try {\n      if (this._stopRecording) {\n        this._stopRecording();\n        this._stopRecording = undefined;\n      }\n\n      return true;\n    } catch (err) {\n      this.handleException(err);\n      return false;\n    }\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n   async stop({ forceFlush = false, reason } = {}) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    // We can't move `_isEnabled` after awaiting a flush, otherwise we can\n    // enter into an infinite loop when `stop()` is called while flushing.\n    this._isEnabled = false;\n\n    try {\n      DEBUG_BUILD && logger.info(`Stopping Replay${reason ? ` triggered by ${reason}` : ''}`);\n\n      resetReplayIdOnDynamicSamplingContext();\n\n      this._removeListeners();\n      this.stopRecording();\n\n      this._debouncedFlush.cancel();\n      // See comment above re: `_isEnabled`, we \"force\" a flush, ignoring the\n      // `_isEnabled` state of the plugin since it was disabled above.\n      if (forceFlush) {\n        await this._flush({ force: true });\n      }\n\n      // After flush, destroy event buffer\n      this.eventBuffer?.destroy();\n      this.eventBuffer = null;\n\n      // Clear session from session storage, note this means if a new session\n      // is started after, it will not have `previousSessionId`\n      clearSession(this);\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Pause some replay functionality. See comments for `_isPaused`.\n   * This differs from stop as this only stops DOM recording, it is\n   * not as thorough of a shutdown as `stop()`.\n   */\n   pause() {\n    if (this._isPaused) {\n      return;\n    }\n\n    this._isPaused = true;\n    this.stopRecording();\n\n    DEBUG_BUILD && logger.info('Pausing replay');\n  }\n\n  /**\n   * Resumes recording, see notes for `pause().\n   *\n   * Note that calling `startRecording()` here will cause a\n   * new DOM checkout.`\n   */\n   resume() {\n    if (!this._isPaused || !this._checkSession()) {\n      return;\n    }\n\n    this._isPaused = false;\n    this.startRecording();\n\n    DEBUG_BUILD && logger.info('Resuming replay');\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n   async sendBufferedReplayOrFlush({ continueRecording = true } = {}) {\n    if (this.recordingMode === 'session') {\n      return this.flushImmediate();\n    }\n\n    const activityTime = Date.now();\n\n    DEBUG_BUILD && logger.info('Converting buffer to session');\n\n    // Allow flush to complete before resuming as a session recording, otherwise\n    // the checkout from `startRecording` may be included in the payload.\n    // Prefer to keep the error replay as a separate (and smaller) segment\n    // than the session replay.\n    await this.flushImmediate();\n\n    const hasStoppedRecording = this.stopRecording();\n\n    if (!continueRecording || !hasStoppedRecording) {\n      return;\n    }\n\n    // To avoid race conditions where this is called multiple times, we check here again that we are still buffering\n    if ((this.recordingMode ) === 'session') {\n      return;\n    }\n\n    // Re-start recording in session-mode\n    this.recordingMode = 'session';\n\n    // Once this session ends, we do not want to refresh it\n    if (this.session) {\n      this._updateUserActivity(activityTime);\n      this._updateSessionActivity(activityTime);\n      this._maybeSaveSession();\n    }\n\n    this.startRecording();\n  }\n\n  /**\n   * We want to batch uploads of replay events. Save events only if\n   * `<flushMinDelay>` milliseconds have elapsed since the last event\n   * *OR* if `<flushMaxDelay>` milliseconds have elapsed.\n   *\n   * Accepts a callback to perform side-effects and returns true to stop batch\n   * processing and hand back control to caller.\n   */\n   addUpdate(cb) {\n    // We need to always run `cb` (e.g. in the case of `this.recordingMode == 'buffer'`)\n    const cbResult = cb();\n\n    // If this option is turned on then we will only want to call `flush`\n    // explicitly\n    if (this.recordingMode === 'buffer') {\n      return;\n    }\n\n    // If callback is true, we do not want to continue with flushing -- the\n    // caller will need to handle it.\n    if (cbResult === true) {\n      return;\n    }\n\n    // addUpdate is called quite frequently - use _debouncedFlush so that it\n    // respects the flush delays and does not flush immediately\n    this._debouncedFlush();\n  }\n\n  /**\n   * Updates the user activity timestamp and resumes recording. This should be\n   * called in an event handler for a user action that we consider as the user\n   * being \"active\" (e.g. a mouse click).\n   */\n   triggerUserActivity() {\n    this._updateUserActivity();\n\n    // This case means that recording was once stopped due to inactivity.\n    // Ensure that recording is resumed.\n    if (!this._stopRecording) {\n      // Create a new session, otherwise when the user action is flushed, it\n      // will get rejected due to an expired session.\n      if (!this._checkSession()) {\n        return;\n      }\n\n      // Note: This will cause a new DOM checkout\n      this.resume();\n      return;\n    }\n\n    // Otherwise... recording was never suspended, continue as normalish\n    this.checkAndHandleExpiredSession();\n\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Updates the user activity timestamp *without* resuming\n   * recording. Some user events (e.g. keydown) can be create\n   * low-value replays that only contain the keypress as a\n   * breadcrumb. Instead this would require other events to\n   * create a new replay after a session has expired.\n   */\n   updateUserActivity() {\n    this._updateUserActivity();\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Only flush if `this.recordingMode === 'session'`\n   */\n   conditionalFlush() {\n    if (this.recordingMode === 'buffer') {\n      return Promise.resolve();\n    }\n\n    return this.flushImmediate();\n  }\n\n  /**\n   * Flush using debounce flush\n   */\n   flush() {\n    return this._debouncedFlush() ;\n  }\n\n  /**\n   * Always flush via `_debouncedFlush` so that we do not have flushes triggered\n   * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be\n   * cases of multiple flushes happening closely together.\n   */\n   flushImmediate() {\n    this._debouncedFlush();\n    // `.flush` is provided by the debounced function, analogously to lodash.debounce\n    return this._debouncedFlush.flush() ;\n  }\n\n  /**\n   * Cancels queued up flushes.\n   */\n   cancelFlush() {\n    this._debouncedFlush.cancel();\n  }\n\n  /** Get the current session (=replay) ID */\n   getSessionId() {\n    return this.session?.id;\n  }\n\n  /**\n   * Checks if recording should be stopped due to user inactivity. Otherwise\n   * check if session is expired and create a new session if so. Triggers a new\n   * full snapshot on new session.\n   *\n   * Returns true if session is not expired, false otherwise.\n   * @hidden\n   */\n   checkAndHandleExpiredSession() {\n    // Prevent starting a new session if the last user activity is older than\n    // SESSION_IDLE_PAUSE_DURATION. Otherwise non-user activity can trigger a new\n    // session+recording. This creates noisy replays that do not have much\n    // content in them.\n    if (\n      this._lastActivity &&\n      isExpired(this._lastActivity, this.timeouts.sessionIdlePause) &&\n      this.session &&\n      this.session.sampled === 'session'\n    ) {\n      // Pause recording only for session-based replays. Otherwise, resuming\n      // will create a new replay and will conflict with users who only choose\n      // to record error-based replays only. (e.g. the resumed replay will not\n      // contain a reference to an error)\n      this.pause();\n      return;\n    }\n\n    // --- There is recent user activity --- //\n    // This will create a new session if expired, based on expiry length\n    if (!this._checkSession()) {\n      // Check session handles the refreshing itself\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Capture some initial state that can change throughout the lifespan of the\n   * replay. This is required because otherwise they would be captured at the\n   * first flush.\n   */\n   setInitialState() {\n    const urlPath = `${WINDOW.location.pathname}${WINDOW.location.hash}${WINDOW.location.search}`;\n    const url = `${WINDOW.location.origin}${urlPath}`;\n\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // Reset _context as well\n    this._clearContext();\n\n    this._context.initialUrl = url;\n    this._context.initialTimestamp = Date.now();\n    this._context.urls.push(url);\n  }\n\n  /**\n   * Add a breadcrumb event, that may be throttled.\n   * If it was throttled, we add a custom breadcrumb to indicate that.\n   */\n   throttledAddEvent(\n    event,\n    isCheckout,\n  ) {\n    const res = this._throttledAddEvent(event, isCheckout);\n\n    // If this is THROTTLED, it means we have throttled the event for the first time\n    // In this case, we want to add a breadcrumb indicating that something was skipped\n    if (res === THROTTLED) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.throttled',\n      });\n\n      this.addUpdate(() => {\n        // Return `false` if the event _was_ added, as that means we schedule a flush\n        return !addEventSync(this, {\n          type: ReplayEventTypeCustom,\n          timestamp: breadcrumb.timestamp || 0,\n          data: {\n            tag: 'breadcrumb',\n            payload: breadcrumb,\n            metric: true,\n          },\n        });\n      });\n    }\n\n    return res;\n  }\n\n  /**\n   * This will get the parametrized route name of the current page.\n   * This is only available if performance is enabled, and if an instrumented router is used.\n   */\n   getCurrentRoute() {\n    const lastActiveSpan = this.lastActiveSpan || getActiveSpan();\n    const lastRootSpan = lastActiveSpan && getRootSpan(lastActiveSpan);\n\n    const attributes = (lastRootSpan && spanToJSON(lastRootSpan).data) || {};\n    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    if (!lastRootSpan || !source || !['route', 'custom'].includes(source)) {\n      return undefined;\n    }\n\n    return spanToJSON(lastRootSpan).description;\n  }\n\n  /**\n   * Initialize and start all listeners to varying events (DOM,\n   * Performance Observer, Recording, Sentry SDK, etc)\n   */\n   _initializeRecording() {\n    this.setInitialState();\n\n    // this method is generally called on page load or manually - in both cases\n    // we should treat it as an activity\n    this._updateSessionActivity();\n\n    this.eventBuffer = createEventBuffer({\n      useCompression: this._options.useCompression,\n      workerUrl: this._options.workerUrl,\n    });\n\n    this._removeListeners();\n    this._addListeners();\n\n    // Need to set as enabled before we start recording, as `record()` can trigger a flush with a new checkout\n    this._isEnabled = true;\n    this._isPaused = false;\n\n    this.startRecording();\n  }\n\n  /**\n   * Loads (or refreshes) the current session.\n   */\n   _initializeSessionForSampling(previousSessionId) {\n    // Whenever there is _any_ error sample rate, we always allow buffering\n    // Because we decide on sampling when an error occurs, we need to buffer at all times if sampling for errors\n    const allowBuffering = this._options.errorSampleRate > 0;\n\n    const session = loadOrCreateSession(\n      {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n        previousSessionId,\n      },\n      {\n        stickySession: this._options.stickySession,\n        sessionSampleRate: this._options.sessionSampleRate,\n        allowBuffering,\n      },\n    );\n\n    this.session = session;\n  }\n\n  /**\n   * Checks and potentially refreshes the current session.\n   * Returns false if session is not recorded.\n   */\n   _checkSession() {\n    // If there is no session yet, we do not want to refresh anything\n    // This should generally not happen, but to be safe....\n    if (!this.session) {\n      return false;\n    }\n\n    const currentSession = this.session;\n\n    if (\n      shouldRefreshSession(currentSession, {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n      })\n    ) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._refreshSession(currentSession);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Refresh a session with a new one.\n   * This stops the current session (without forcing a flush, as that would never work since we are expired),\n   * and then does a new sampling based on the refreshed session.\n   */\n   async _refreshSession(session) {\n    if (!this._isEnabled) {\n      return;\n    }\n    await this.stop({ reason: 'refresh session' });\n    this.initializeSampling(session.id);\n  }\n\n  /**\n   * Adds listeners to record events for the replay\n   */\n   _addListeners() {\n    try {\n      WINDOW.document.addEventListener('visibilitychange', this._handleVisibilityChange);\n      WINDOW.addEventListener('blur', this._handleWindowBlur);\n      WINDOW.addEventListener('focus', this._handleWindowFocus);\n      WINDOW.addEventListener('keydown', this._handleKeyboardEvent);\n\n      if (this.clickDetector) {\n        this.clickDetector.addListeners();\n      }\n\n      // There is no way to remove these listeners, so ensure they are only added once\n      if (!this._hasInitializedCoreListeners) {\n        addGlobalListeners(this, { autoFlushOnFeedback: this._options._experiments.autoFlushOnFeedback });\n\n        this._hasInitializedCoreListeners = true;\n      }\n    } catch (err) {\n      this.handleException(err);\n    }\n\n    this._performanceCleanupCallback = setupPerformanceObserver(this);\n  }\n\n  /**\n   * Cleans up listeners that were created in `_addListeners`\n   */\n   _removeListeners() {\n    try {\n      WINDOW.document.removeEventListener('visibilitychange', this._handleVisibilityChange);\n\n      WINDOW.removeEventListener('blur', this._handleWindowBlur);\n      WINDOW.removeEventListener('focus', this._handleWindowFocus);\n      WINDOW.removeEventListener('keydown', this._handleKeyboardEvent);\n\n      if (this.clickDetector) {\n        this.clickDetector.removeListeners();\n      }\n\n      if (this._performanceCleanupCallback) {\n        this._performanceCleanupCallback();\n      }\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)\n   */\n   _doChangeToBackgroundTasks(breadcrumb) {\n    if (!this.session) {\n      return;\n    }\n\n    const expired = isSessionExpired(this.session, {\n      maxReplayDuration: this._options.maxReplayDuration,\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n    });\n\n    if (expired) {\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Send replay when the page/tab becomes hidden. There is no reason to send\n    // replay if it becomes visible, since no actions we care about were done\n    // while it was hidden\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    void this.conditionalFlush();\n  }\n\n  /**\n   * Tasks to run when we consider a page to be visible (via focus and/or visibility)\n   */\n   _doChangeToForegroundTasks(breadcrumb) {\n    if (!this.session) {\n      return;\n    }\n\n    const isSessionActive = this.checkAndHandleExpiredSession();\n\n    if (!isSessionActive) {\n      // If the user has come back to the page within SESSION_IDLE_PAUSE_DURATION\n      // ms, we will re-use the existing session, otherwise create a new\n      // session\n      DEBUG_BUILD && logger.info('Document has become active, but session has expired');\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n  }\n\n  /**\n   * Update user activity (across session lifespans)\n   */\n   _updateUserActivity(_lastActivity = Date.now()) {\n    this._lastActivity = _lastActivity;\n  }\n\n  /**\n   * Updates the session's last activity timestamp\n   */\n   _updateSessionActivity(_lastActivity = Date.now()) {\n    if (this.session) {\n      this.session.lastActivity = _lastActivity;\n      this._maybeSaveSession();\n    }\n  }\n\n  /**\n   * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb\n   */\n   _createCustomBreadcrumb(breadcrumb) {\n    this.addUpdate(() => {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.throttledAddEvent({\n        type: EventType.Custom,\n        timestamp: breadcrumb.timestamp || 0,\n        data: {\n          tag: 'breadcrumb',\n          payload: breadcrumb,\n        },\n      });\n    });\n  }\n\n  /**\n   * Observed performance events are added to `this.performanceEntries`. These\n   * are included in the replay event before it is finished and sent to Sentry.\n   */\n   _addPerformanceEntries() {\n    let performanceEntries = createPerformanceEntries(this.performanceEntries).concat(this.replayPerformanceEntries);\n\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // If we are manually starting, we want to ensure we only include performance entries\n    // that are after the initial timestamp\n    // The reason for this is that we may have performance entries from the page load, but may decide to start\n    // the replay later on, in which case we do not want to include these entries.\n    // without this, manually started replays can have events long before the actual replay recording starts,\n    // which messes with the timeline etc.\n    if (this._requiresManualStart) {\n      const initialTimestampInSeconds = this._context.initialTimestamp / 1000;\n      performanceEntries = performanceEntries.filter(entry => entry.start >= initialTimestampInSeconds);\n    }\n\n    return Promise.all(createPerformanceSpans(this, performanceEntries));\n  }\n\n  /**\n   * Clear _context\n   */\n   _clearContext() {\n    // XXX: `initialTimestamp` and `initialUrl` do not get cleared\n    this._context.errorIds.clear();\n    this._context.traceIds.clear();\n    this._context.urls = [];\n  }\n\n  /** Update the initial timestamp based on the buffer content. */\n   _updateInitialTimestampFromEventBuffer() {\n    const { session, eventBuffer } = this;\n    // If replay was started manually (=no sample rate was given),\n    // We do not want to back-port the initial timestamp\n    if (!session || !eventBuffer || this._requiresManualStart) {\n      return;\n    }\n\n    // we only ever update this on the initial segment\n    if (session.segmentId) {\n      return;\n    }\n\n    const earliestEvent = eventBuffer.getEarliestTimestamp();\n    if (earliestEvent && earliestEvent < this._context.initialTimestamp) {\n      this._context.initialTimestamp = earliestEvent;\n    }\n  }\n\n  /**\n   * Return and clear _context\n   */\n   _popEventContext() {\n    const _context = {\n      initialTimestamp: this._context.initialTimestamp,\n      initialUrl: this._context.initialUrl,\n      errorIds: Array.from(this._context.errorIds),\n      traceIds: Array.from(this._context.traceIds),\n      urls: this._context.urls,\n    };\n\n    this._clearContext();\n\n    return _context;\n  }\n\n  /**\n   * Flushes replay event buffer to Sentry.\n   *\n   * Performance events are only added right before flushing - this is\n   * due to the buffered performance observer events.\n   *\n   * Should never be called directly, only by `flush`\n   */\n   async _runFlush() {\n    const replayId = this.getSessionId();\n\n    if (!this.session || !this.eventBuffer || !replayId) {\n      DEBUG_BUILD && logger.error('No session or eventBuffer found to flush.');\n      return;\n    }\n\n    await this._addPerformanceEntries();\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer?.hasEvents) {\n      return;\n    }\n\n    // Only attach memory event if eventBuffer is not empty\n    await addMemoryEntry(this);\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer) {\n      return;\n    }\n\n    // if this changed in the meanwhile, e.g. because the session was refreshed or similar, we abort here\n    if (replayId !== this.getSessionId()) {\n      return;\n    }\n\n    try {\n      // This uses the data from the eventBuffer, so we need to call this before `finish()\n      this._updateInitialTimestampFromEventBuffer();\n\n      const timestamp = Date.now();\n\n      // Check total duration again, to avoid sending outdated stuff\n      // We leave 30s wiggle room to accommodate late flushing etc.\n      // This _could_ happen when the browser is suspended during flushing, in which case we just want to stop\n      if (timestamp - this._context.initialTimestamp > this._options.maxReplayDuration + 30000) {\n        throw new Error('Session is too long, not sending replay');\n      }\n\n      const eventContext = this._popEventContext();\n      // Always increment segmentId regardless of outcome of sending replay\n      const segmentId = this.session.segmentId++;\n      this._maybeSaveSession();\n\n      // Note this empties the event buffer regardless of outcome of sending replay\n      const recordingData = await this.eventBuffer.finish();\n\n      await sendReplay({\n        replayId,\n        recordingData,\n        segmentId,\n        eventContext,\n        session: this.session,\n        timestamp,\n        onError: err => this.handleException(err),\n      });\n    } catch (err) {\n      this.handleException(err);\n\n      // This means we retried 3 times and all of them failed,\n      // or we ran into a problem we don't want to retry, like rate limiting.\n      // In this case, we want to completely stop the replay - otherwise, we may get inconsistent segments\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({ reason: 'sendReplay' });\n\n      const client = getClient();\n\n      if (client) {\n        const dropReason = err instanceof RateLimitError ? 'ratelimit_backoff' : 'send_error';\n        client.recordDroppedEvent(dropReason, 'replay');\n      }\n    }\n  }\n\n  /**\n   * Flush recording data to Sentry. Creates a lock so that only a single flush\n   * can be active at a time. Do not call this directly.\n   */\n   async _flush({\n    force = false,\n  }\n\n = {}) {\n    if (!this._isEnabled && !force) {\n      // This can happen if e.g. the replay was stopped because of exceeding the retry limit\n      return;\n    }\n\n    if (!this.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && logger.error('Attempting to finish replay event after session expired.');\n      return;\n    }\n\n    if (!this.session) {\n      // should never happen, as we would have bailed out before\n      return;\n    }\n\n    const start = this.session.started;\n    const now = Date.now();\n    const duration = now - start;\n\n    // A flush is about to happen, cancel any queued flushes\n    this._debouncedFlush.cancel();\n\n    // If session is too short, or too long (allow some wiggle room over maxReplayDuration), do not send it\n    // This _should_ not happen, but it may happen if flush is triggered due to a page activity change or similar\n    const tooShort = duration < this._options.minReplayDuration;\n    const tooLong = duration > this._options.maxReplayDuration + 5000;\n    if (tooShort || tooLong) {\n      DEBUG_BUILD &&\n        logger.info(\n          `Session duration (${Math.floor(duration / 1000)}s) is too ${\n            tooShort ? 'short' : 'long'\n          }, not sending replay.`,\n        );\n\n      if (tooShort) {\n        this._debouncedFlush();\n      }\n      return;\n    }\n\n    const eventBuffer = this.eventBuffer;\n    if (eventBuffer && this.session.segmentId === 0 && !eventBuffer.hasCheckout) {\n      DEBUG_BUILD && logger.info('Flushing initial segment without checkout.');\n      // TODO FN: Evaluate if we want to stop here, or remove this again?\n    }\n\n    const _flushInProgress = !!this._flushLock;\n\n    // this._flushLock acts as a lock so that future calls to `_flush()` will\n    // be blocked until current flush is finished (i.e. this promise resolves)\n    if (!this._flushLock) {\n      this._flushLock = this._runFlush();\n    }\n\n    try {\n      await this._flushLock;\n    } catch (err) {\n      this.handleException(err);\n    } finally {\n      this._flushLock = undefined;\n\n      if (_flushInProgress) {\n        // Wait for previous flush to finish, then call the debounced\n        // `_flush()`. It's possible there are other flush requests queued and\n        // waiting for it to resolve. We want to reduce all outstanding\n        // requests (as well as any new flush requests that occur within a\n        // second of the locked flush completing) into a single flush.\n        this._debouncedFlush();\n      }\n    }\n  }\n\n  /** Save the session, if it is sticky */\n   _maybeSaveSession() {\n    if (this.session && this._options.stickySession) {\n      saveSession(this.session);\n    }\n  }\n\n  /** Handler for rrweb.record.onMutation */\n   _onMutationHandler(mutations) {\n    const count = mutations.length;\n\n    const mutationLimit = this._options.mutationLimit;\n    const mutationBreadcrumbLimit = this._options.mutationBreadcrumbLimit;\n    const overMutationLimit = mutationLimit && count > mutationLimit;\n\n    // Create a breadcrumb if a lot of mutations happen at the same time\n    // We can show this in the UI as an information with potential performance improvements\n    if (count > mutationBreadcrumbLimit || overMutationLimit) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.mutations',\n        data: {\n          count,\n          limit: overMutationLimit,\n        },\n      });\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Stop replay if over the mutation limit\n    if (overMutationLimit) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({ reason: 'mutationLimit', forceFlush: this.recordingMode === 'session' });\n      return false;\n    }\n\n    // `true` means we use the regular mutation handling by rrweb\n    return true;\n  }\n}\n\nfunction getOption(selectors, defaultSelectors) {\n  return [\n    ...selectors,\n    // sentry defaults\n    ...defaultSelectors,\n  ].join(',');\n}\n\n/**\n * Returns privacy related configuration for use in rrweb\n */\nfunction getPrivacyOptions({ mask, unmask, block, unblock, ignore }) {\n  const defaultBlockedElements = ['base', 'iframe[srcdoc]:not([src])'];\n\n  const maskSelector = getOption(mask, ['.sentry-mask', '[data-sentry-mask]']);\n  const unmaskSelector = getOption(unmask, []);\n\n  const options = {\n    // We are making the decision to make text and input selectors the same\n    maskTextSelector: maskSelector,\n    unmaskTextSelector: unmaskSelector,\n\n    blockSelector: getOption(block, ['.sentry-block', '[data-sentry-block]', ...defaultBlockedElements]),\n    unblockSelector: getOption(unblock, []),\n    ignoreSelector: getOption(ignore, ['.sentry-ignore', '[data-sentry-ignore]', 'input[type=\"file\"]']),\n  };\n\n  return options;\n}\n\n/**\n * Masks an attribute if necessary, otherwise return attribute value as-is.\n */\nfunction maskAttribute({\n  el,\n  key,\n  maskAttributes,\n  maskAllText,\n  privacyOptions,\n  value,\n}) {\n  // We only mask attributes if `maskAllText` is true\n  if (!maskAllText) {\n    return value;\n  }\n\n  // unmaskTextSelector takes precedence\n  if (privacyOptions.unmaskTextSelector && el.matches(privacyOptions.unmaskTextSelector)) {\n    return value;\n  }\n\n  if (\n    maskAttributes.includes(key) ||\n    // Need to mask `value` attribute for `<input>` if it's a button-like\n    // type\n    (key === 'value' && el.tagName === 'INPUT' && ['submit', 'button'].includes(el.getAttribute('type') || ''))\n  ) {\n    return value.replace(/[\\S]/g, '*');\n  }\n\n  return value;\n}\n\nconst MEDIA_SELECTORS =\n  'img,image,svg,video,object,picture,embed,map,audio,link[rel=\"icon\"],link[rel=\"apple-touch-icon\"]';\n\nconst DEFAULT_NETWORK_HEADERS = ['content-length', 'content-type', 'accept'];\n\nlet _initialized = false;\n\n/**\n * Sentry integration for [Session Replay](https://sentry.io/for/session-replay/).\n *\n * See the [Replay documentation](https://docs.sentry.io/platforms/javascript/guides/session-replay/) for more information.\n *\n * @example\n *\n * ```\n * Sentry.init({\n *   dsn: '__DSN__',\n *   integrations: [Sentry.replayIntegration()],\n * });\n * ```\n */\nconst replayIntegration = ((options) => {\n  return new Replay(options);\n}) ;\n\n/**\n * Replay integration\n */\nclass Replay  {\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n\n  /**\n   * Initial options passed to the replay integration, merged with default values.\n   * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they\n   * can only be finally set when setupOnce() is called.\n   *\n   * @private\n   */\n\n   constructor({\n    flushMinDelay = DEFAULT_FLUSH_MIN_DELAY,\n    flushMaxDelay = DEFAULT_FLUSH_MAX_DELAY,\n    minReplayDuration = MIN_REPLAY_DURATION,\n    maxReplayDuration = MAX_REPLAY_DURATION,\n    stickySession = true,\n    useCompression = true,\n    workerUrl,\n    _experiments = {},\n    maskAllText = true,\n    maskAllInputs = true,\n    blockAllMedia = true,\n\n    mutationBreadcrumbLimit = 750,\n    mutationLimit = 10000,\n\n    slowClickTimeout = 7000,\n    slowClickIgnoreSelectors = [],\n\n    networkDetailAllowUrls = [],\n    networkDetailDenyUrls = [],\n    networkCaptureBodies = true,\n    networkRequestHeaders = [],\n    networkResponseHeaders = [],\n\n    mask = [],\n    maskAttributes = ['title', 'placeholder', 'aria-label'],\n    unmask = [],\n    block = [],\n    unblock = [],\n    ignore = [],\n    maskFn,\n\n    beforeAddRecordingEvent,\n    beforeErrorSampling,\n    onError,\n  } = {}) {\n    this.name = 'Replay';\n\n    const privacyOptions = getPrivacyOptions({\n      mask,\n      unmask,\n      block,\n      unblock,\n      ignore,\n    });\n\n    this._recordingOptions = {\n      maskAllInputs,\n      maskAllText,\n      maskInputOptions: { password: true },\n      maskTextFn: maskFn,\n      maskInputFn: maskFn,\n      maskAttributeFn: (key, value, el) =>\n        maskAttribute({\n          maskAttributes,\n          maskAllText,\n          privacyOptions,\n          key,\n          value,\n          el,\n        }),\n\n      ...privacyOptions,\n\n      // Our defaults\n      slimDOMOptions: 'all',\n      inlineStylesheet: true,\n      // Disable inline images as it will increase segment/replay size\n      inlineImages: false,\n      // collect fonts, but be aware that `sentry.io` needs to be an allowed\n      // origin for playback\n      collectFonts: true,\n      errorHandler: (err) => {\n        try {\n          err.__rrweb__ = true;\n        } catch (error) {\n          // ignore errors here\n          // this can happen if the error is frozen or does not allow mutation for other reasons\n        }\n      },\n      // experimental support for recording iframes from different origins\n      recordCrossOriginIframes: Boolean(_experiments.recordCrossOriginIframes),\n    };\n\n    this._initialOptions = {\n      flushMinDelay,\n      flushMaxDelay,\n      minReplayDuration: Math.min(minReplayDuration, MIN_REPLAY_DURATION_LIMIT),\n      maxReplayDuration: Math.min(maxReplayDuration, MAX_REPLAY_DURATION),\n      stickySession,\n      useCompression,\n      workerUrl,\n      blockAllMedia,\n      maskAllInputs,\n      maskAllText,\n      mutationBreadcrumbLimit,\n      mutationLimit,\n      slowClickTimeout,\n      slowClickIgnoreSelectors,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders: _getMergedNetworkHeaders(networkRequestHeaders),\n      networkResponseHeaders: _getMergedNetworkHeaders(networkResponseHeaders),\n      beforeAddRecordingEvent,\n      beforeErrorSampling,\n      onError,\n\n      _experiments,\n    };\n\n    if (this._initialOptions.blockAllMedia) {\n      // `blockAllMedia` is a more user friendly option to configure blocking\n      // embedded media elements\n      this._recordingOptions.blockSelector = !this._recordingOptions.blockSelector\n        ? MEDIA_SELECTORS\n        : `${this._recordingOptions.blockSelector},${MEDIA_SELECTORS}`;\n    }\n\n    if (this._isInitialized && isBrowser()) {\n      throw new Error('Multiple Sentry Session Replay instances are not supported');\n    }\n\n    this._isInitialized = true;\n  }\n\n  /** If replay has already been initialized */\n   get _isInitialized() {\n    return _initialized;\n  }\n\n  /** Update _isInitialized */\n   set _isInitialized(value) {\n    _initialized = value;\n  }\n\n  /**\n   * Setup and initialize replay container\n   */\n   afterAllSetup(client) {\n    if (!isBrowser() || this._replay) {\n      return;\n    }\n\n    this._setup(client);\n    this._initialize(client);\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will log a message if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * PerformanceObserver, Recording, Sentry SDK, etc)\n   */\n   start() {\n    if (!this._replay) {\n      return;\n    }\n    this._replay.start();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, until an error occurs.\n   */\n   startBuffering() {\n    if (!this._replay) {\n      return;\n    }\n\n    this._replay.startBuffering();\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n   stop() {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n\n    return this._replay.stop({ forceFlush: this._replay.recordingMode === 'session' });\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * If replay is not enabled, a new session replay is started.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n   flush(options) {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n\n    // assuming a session should be recorded in this case\n    if (!this._replay.isEnabled()) {\n      this._replay.start();\n      return Promise.resolve();\n    }\n\n    return this._replay.sendBufferedReplayOrFlush(options);\n  }\n\n  /**\n   * Get the current session ID.\n   */\n   getReplayId() {\n    if (!this._replay?.isEnabled()) {\n      return;\n    }\n\n    return this._replay.getSessionId();\n  }\n\n  /**\n   * Get the current recording mode. This can be either `session` or `buffer`.\n   *\n   * `session`: Recording the whole session, sending it continuously\n   * `buffer`: Always keeping the last 60s of recording, requires:\n   *   - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *   - or calling `flush()` to send the replay\n   */\n   getRecordingMode() {\n    if (!this._replay?.isEnabled()) {\n      return;\n    }\n\n    return this._replay.recordingMode;\n  }\n\n  /**\n   * Initializes replay.\n   */\n   _initialize(client) {\n    if (!this._replay) {\n      return;\n    }\n\n    this._maybeLoadFromReplayCanvasIntegration(client);\n    this._replay.initializeSampling();\n  }\n\n  /** Setup the integration. */\n   _setup(client) {\n    // Client is not available in constructor, so we need to wait until setupOnce\n    const finalOptions = loadReplayOptionsFromClient(this._initialOptions, client);\n\n    this._replay = new ReplayContainer({\n      options: finalOptions,\n      recordingOptions: this._recordingOptions,\n    });\n  }\n\n  /** Get canvas options from ReplayCanvas integration, if it is also added. */\n   _maybeLoadFromReplayCanvasIntegration(client) {\n    // To save bundle size, we skip checking for stuff here\n    // and instead just try-catch everything - as generally this should all be defined\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    try {\n      const canvasIntegration = client.getIntegrationByName('ReplayCanvas')\n\n;\n      if (!canvasIntegration) {\n        return;\n      }\n\n      this._replay['_canvas'] = canvasIntegration.getOptions();\n    } catch {\n      // ignore errors here\n    }\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n  }\n}\n\n/** Parse Replay-related options from SDK options */\nfunction loadReplayOptionsFromClient(initialOptions, client) {\n  const opt = client.getOptions() ;\n\n  const finalOptions = {\n    sessionSampleRate: 0,\n    errorSampleRate: 0,\n    ...initialOptions,\n  };\n\n  const replaysSessionSampleRate = parseSampleRate(opt.replaysSessionSampleRate);\n  const replaysOnErrorSampleRate = parseSampleRate(opt.replaysOnErrorSampleRate);\n\n  if (replaysSessionSampleRate == null && replaysOnErrorSampleRate == null) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.',\n      );\n    });\n  }\n\n  if (replaysSessionSampleRate != null) {\n    finalOptions.sessionSampleRate = replaysSessionSampleRate;\n  }\n\n  if (replaysOnErrorSampleRate != null) {\n    finalOptions.errorSampleRate = replaysOnErrorSampleRate;\n  }\n\n  return finalOptions;\n}\n\nfunction _getMergedNetworkHeaders(headers) {\n  return [...DEFAULT_NETWORK_HEADERS, ...headers.map(header => header.toLowerCase())];\n}\n\n/**\n * This is a small utility to get a type-safe instance of the Replay integration.\n */\nfunction getReplay() {\n  const client = getClient();\n  return client?.getIntegrationByName('Replay');\n}\n\nexport { getReplay, replayIntegration };\n//# sourceMappingURL=index.js.map\n"],"names":["WINDOW","GLOBAL_OBJ","REPLAY_SESSION_KEY","UNABLE_TO_SEND_REPLAY","NETWORK_BODY_MAX_SIZE","CONSOLE_ARG_MAX_SIZE","REPLAY_MAX_EVENT_BUFFER_SIZE","MAX_REPLAY_DURATION","__defProp$1","Object","defineProperty","__publicField$1","obj","key","value","enumerable","configurable","writable","__defNormalProp$1","NodeType$2","NodeType2","isShadowRoot","n2","host","Boolean","shadowRoot","isNativeShadowDom","prototype","toString","call","stringifyStylesheet","s2","rules2","rules","cssRules","cssText","Array","from","stringifyRule","join","includes","replace","error","rule","importStringified","isCSSImportRule","styleSheet","split","length","statement","JSON","stringify","href","layerName","push","supportsText","media","mediaText","escapeImportStatement","isCSSStyleRule","needsSafariColonFix","selectorText","needsAllFix","style","styles","i2","styleDeclaration","attribute","isImportant","getPropertyPriority","getPropertyValue","fixAllCssProperty","cssStringified","regex","fixSafariColons","Mirror","constructor","this","Map","WeakMap","getId","_a","getMeta","id","getNode","idNodeMap","get","getIds","keys","nodeMetaMap","removeNodeFromMap","delete","childNodes","forEach","childNode","has","hasNode","node","add","meta","set","oldNode","reset","shouldMaskInput","maskInputOptions","tagName","type","toLowerCase","maskInputValue","isMasked","element","maskInputFn","text","repeat","str","toUpperCase","ORIGINAL_ATTRIBUTE_NAME","getInputType","hasAttribute","getInputValue","el","getAttribute","extractFileExtension","path","baseURL","url","URL","window","location","err","match","pathname","cachedImplementations$1","getImplementation$1","name","cached","document2","document","impl","createElement","sandbox","hidden","head","appendChild","contentWindow","removeChild","e2","bind","setTimeout$2","rest","clearTimeout$1","getIframeContentDocument","iframe","contentDocument","_id","tagNameRegex","RegExp","genId","canvasService","canvasCtx","URL_IN_CSS_REF","URL_PROTOCOL_MATCH","URL_WWW_MATCH","DATA_URI","absoluteToStylesheet","origin","quote1","path1","quote2","path2","path3","filePath","maybeQuote","test","indexOf","slice","extractOrigin","stack","parts","pop","part","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","cachedDocument","absoluteToDoc","doc","attributeValue","trim","getHref","isSVGElement","ownerSVGElement","customHref","a2","startsWith","setAttribute","transformAttribute","maskAttributeFn","pos","collectCharacters","regEx","chars2","exec","substring","output","descriptorsStr","inParens","c2","charAt","getAbsoluteSrcsetString","ignoreAttribute","_value","_isBlockedElement","blockClass","blockSelector","unblockSelector","matches","classList","contains","eIndex","className","distanceToMatch","matchPredicate","limit","Infinity","distance","nodeType","ELEMENT_NODE","parentNode","createMatchPredicate","selector","elementClassMatchesRegex","needMaskingText","maskTextClass","maskTextSelector","unmaskTextClass","unmaskTextSelector","maskAllText","parentElement","autocomplete","maskDistance","unmaskDistance","serializeNode","options","mirror","mirror2","inlineStylesheet","maskTextFn","dataURLOptions","inlineImages","recordCanvas","keepIframeSrcFn","newlyAddedElement","rootId","docId","getRootId","DOCUMENT_NODE","compatMode","Document","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","HTMLFormElement","processedTagName","getValidTagName$1","attributes2","len","attributes","attr","stylesheet","styleSheets","find","rel","crossorigin","_cssText","sheet","innerText","textContent","checked","forceMask","selected","__context","canvas","ctx","getContext","x","width","y","height","getImageData","originalGetImageData","Uint32Array","Math","min","data","buffer","some","pixel","is2DCanvasBlank","rr_dataURL","toDataURL","quality","canvasDataURL","blankCanvas","image","imageSrc","currentSrc","priorCrossOrigin","crossOrigin","recordInlineImage","removeEventListener","naturalWidth","naturalHeight","drawImage","complete","addEventListener","console","warn","removeAttribute","rr_mediaState","paused","rr_mediaCurrentTime","currentTime","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","getBoundingClientRect","class","rr_width","rr_height","src","rr_src","isCustomElement","customElements","Element","isSVG","isCustom","serializeElementNode","TEXT_NODE","parentTagName","isStyle","isScript","isTextarea","nextSibling","previousSibling","textarea","Text","serializeTextNode","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","lowerIfExists","maybeAttr","serializeNodeWithId","skipChild","slimDOMOptions","onSerialize","onIframeLoad","iframeLoadTimeout","onStylesheetLoad","stylesheetLoadTimeout","preserveWhiteSpace","_serializedNode","sn","comment","script","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode2","assign","recordChild","isShadowHost","headWhitespace","bypassOptions","childN","serializedChildNode","isElement$1","isShadow","iframeEl","listener","win","readyState","fired","timer","blankUrl","onceIframeLoaded","iframeDoc","serializedIframeNode","link","styleSheetLoadTimeout","styleSheetLoaded","onceStylesheetLoaded","serializedLinkNode","on","fn","target","capture","passive","DEPARTED_MIRROR_ACCESS_WARNING","_mirror","map","throttle$1","func","wait","timeout","previous","args","now","Date","leading","remaining","context","getImplementation","clearTimeout$2","apply","trailing","setTimeout$1","hookSetter","d","isRevoked","original","getOwnPropertyDescriptor","patch","source","replacement","wrapped","defineProperties","__rrweb_original__","Proxy","Reflect","prop","receiver","nowTimestamp","getWindowScroll","left","scrollingElement","pageXOffset","documentElement","_b","body","_c","top","pageYOffset","_e","_d","_f","getWindowHeight","innerHeight","clientHeight","getWindowWidth","innerWidth","clientWidth","closestElementOfNode","isBlocked","checkAncestors","blockedPredicate","isUnblocked","blockDistance","unblockDistance","isIgnored","isAncestorRemoved","legacy_isTouchEvent","event","changedTouches","isSerializedIframe","nodeName","isSerializedStylesheet","hasShadowRoot","getTime","StyleSheetMirror","styleIDMap","idStyleMap","newId","getStyle","generateId","getShadowHost","shadowHost","getRootNode","Node","DOCUMENT_FRAGMENT_NODE","shadowHostInDom","ownerDocument","rootShadowHost","getRootShadowHost","inDom","cachedImplementations","EventType","EventType2","IncrementalSource","IncrementalSource2","MouseInteractions","MouseInteractions2","PointerTypes","PointerTypes2","MediaInteractions","MediaInteractions2","getIFrameContentDocument","isNodeInLinkedList","DoubleLinkedList","tail","position","Error","current","index","next","addNode","__ln","removeNode","moveKey","parentId","MutationBuffer","frozen","locked","texts","attributeMap","removes","mapRemoves","movedMap","addedSet","Set","movedSet","droppedSet","processMutations","mutations","processMutation","emit","adds","addedIds","addList","getNextId","ns","nextId","pushAdd","currentN","iframeManager","addIframe","stylesheetManager","trackLinkElement","shadowDomManager","addShadowRoot","childSn","attachIframe","canvasManager","addWindow","observeAttachShadow","attachLinkElement","shift","isParentRemoved","isAncestorInSet","candidate","tailNode","_node","unhandledNode","payload","filter","diffAsStr","styleDiff","unchangedAsStr","_unchangedStyles","mutationCb","m","oldValue","attributeName","isInputMasked","item","unattachedDoc","implementation","createHTMLDocument","old","pname","newValue","newPriority","addedNodes","genAdds","removedNodes","nodeId","isSerialized","deepDelete","processedNodeManager","inOtherBuffer","targetId","init","freeze","unfreeze","isFrozen","lock","unlock","addsSet","r2","_isParentRemoved","size","_isAncestorInSet","errorHandler","callbackWrapper","cb","mutationBuffers","getEventTarget","composedPath","initMutationObserver","rootEl","mutationBuffer","mutationObserverCtor","MutationObserver","__rrMutationObserver","angularZoneSymbol","Zone","__symbol__","observer","onMutation","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","initMouseInteractionObserver","mouseInteractionCb","sampling","mouseInteraction","disableMap","handlers","currentPointerType","Number","isNaN","endsWith","eventKey","eventName","handler","pointerType","thisEventKey","Mouse","Touch","Pen","MouseDown","MouseUp","Click","clientX","clientY","getHandler","PointerEvent","TouchStart","TouchEnd","h","initScrollObserver","scrollCb","evt","defaultView","scrollLeftTop","scroll","INPUT_TAGS","lastInputValueMap","initInputObserver","inputCb","ignoreClass","ignoreSelector","userTriggeredOnInput","eventHandler","userTriggered","isTrusted","isChecked","cbWithDedup","querySelectorAll","el2","text2","v2","lastInputValue","input","currentWindow","propertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","HTMLOptionElement","p","getNestedCSSRulePositions","childRule","hasNestedCSSRule","parentRule","CSSGroupingRule","CSSMediaRule","CSSSupportsRule","CSSConditionRule","unshift","parentStyleSheet","recurse","getIdAndStyleId","styleMirror","styleId","ownerNode","initAdoptedStyleSheetObserver","hostId","patchTarget","ShadowRoot","originalPropertyDescriptor","sheets","result","adoptStyleSheets","initObservers","o2","_hooks","mutationObserver","recordDOM","mousemoveHandler","mousemoveCb","mousemove","threshold","callbackThreshold","mousemoveCallback","timeBaseline","positions","wrappedCb","totalOffset","timeOffset","updatePosition","DragEvent","Drag","MouseEvent","MouseMove","TouchMove","initMoveObserver","mouseInteractionHandler","scrollHandler","viewportResizeHandler","viewportResizeCb","lastH","lastW","initViewportResizeObserver","inputHandler","mediaInteractionHandler","mediaInteractionCb","volume","muted","playbackRate","Play","Pause","Seeked","VolumeChange","RateChange","initMediaInteractionObserver","styleSheetObserver","adoptedStyleSheetObserver","styleDeclarationObserver","fontObserver","styleSheetRuleCb","CSSStyleSheet","insertRule","thisArg","argumentsList","deleteRule","replaceSync","supportedNestedCSSRuleTypes","canMonkeyPatchNestedCSSRule","unmodifiedFunctions","entries","typeKey","initStyleSheetObserver","styleDeclarationCb","ignoreCSSAttributes","setProperty","CSSStyleDeclaration","priority","removeProperty","remove","initStyleDeclarationObserver","collectFonts","fontCb","fontMap","originalFontFace","FontFace","family","descriptors","fontFace","fontSource","Uint8Array","restoreHandler","fonts","initFontObserver","selectionObserver","param","selectionCb","collapsed","updateSelection","selection","getSelection","isCollapsed","ranges","count","rangeCount","range","getRangeAt","startContainer","startOffset","endContainer","endOffset","start","end","initSelectionObserver","customElementObserver","customElementCb","define","initCustomElementObserver","pluginHandlers","plugin","plugins","callback","b","disconnect","CrossOriginIframeMirror","generateIdFn","iframeIdToRemoteIdMap","iframeRemoteIdToIdMap","remoteId","idToRemoteMap","remoteToIdMap","idToRemoteIdMap","getIdToRemoteIdMap","remoteIdToIdMap","getRemoteIdToIdMap","getRemoteId","getRemoteIds","ids","IframeManagerNoop","crossOriginIframeMirror","crossOriginIframeRootIdMap","addLoadListener","IframeManager","iframes","crossOriginIframeMap","wrappedEmit","recordCrossOriginIframes","crossOriginIframeStyleMirror","handleMessage","loadListener","isAttachIframe","adoptedStyleSheets","message","crossOriginMessageEvent","transformedEvent","transformCrossOriginEvent","isCheckout","FullSnapshot","replaceIdOnNode","patchRootIdOnNode","timestamp","IncrementalSnapshot","Mutation","Meta","Load","DomContentLoaded","Plugin","Custom","replaceIds","ViewportResize","MediaInteraction","MouseInteraction","Scroll","CanvasMutation","Input","StyleSheetRule","StyleDeclaration","replaceStyleIds","Font","Selection","AdoptedStyleSheet","iframeMirror","isArray","child","ShadowDomManagerNoop","ShadowDomManager","shadowDoms","WeakSet","restoreHandlers","patchAttachShadow","iframeElement","iframeWindow","getIFrameContentWindow","manager","option","resetShadowRoots","chars","lookup","i$1","charCodeAt","CanvasManagerNoop","snapshot","StylesheetManager","trackedLinkElements","adoptedStyleSheetCb","linkEl","trackStylesheetInLinkElement","adoptedStyleSheetData","styleIds","CSSRule","_linkEl","ProcessedNodeManager","nodeMap","active","thisBuffer","buffers","onRequestAnimationFrame","destroy","_takeFullSnapshot","cleanFrame","debug","record","checkoutEveryNms","checkoutEveryNth","maskAllInputs","_maskInputOptions","_slimDOMOptions","maxCanvasSize","packFn","mousemoveWait","recordAfter","errorHandler2","getCanvasManager","inEmittingFrame","parent","passEmitsToParent","color","date","email","month","number","search","tel","time","week","select","radio","checkbox","lastFullSnapshotEvent","NodeList","DOMTokenList","TypeError","polyfill$1","incrementalSnapshotCount","eventProcessor","buf","postMessage","exceedCount","exceedTime","takeFullSnapshot2","wrappedMutationEmit","wrappedScrollEmit","wrappedCanvasMutationEmit","__RRWEB_EXCLUDE_IFRAME__","getMirror","nodeMirror","getCanvasManagerFn","_getCanvasManager","__RRWEB_EXCLUDE_SHADOW_DOM__","slimDOM","initialOffset","canvasMutationCb","CustomElement","n","t2","takeFullSnapshot","NotStarted","Running","Stopped","timestampToMs","timestampToS","addBreadcrumbEvent","replay","breadcrumb","category","triggerUserActivity","checkAndHandleExpiredSession","addUpdate","throttledAddEvent","tag","normalize","getClosestInteractive","closest","getClickTargetNode","getTargetNode","isEventWithTarget","onWindowOpen","fill","originalWindowOpen","e","splice","IncrementalMutationSources","ClickDetector","slowClickConfig","_addBreadcrumbEvent","_lastMutation","_lastScroll","_clicks","_timeout","_threshold","_scrollTimeout","scrollTimeout","_replay","_ignoreSelector","addListeners","cleanupWindowOpen","nowInSeconds","_teardown","removeListeners","_checkClickTimeout","clearTimeout","handleClick","SLOW_CLICK_TAGS","ignoreElement","isClickBreadcrumb","newClick","clickBreadcrumb","clickCount","click","abs","_scheduleCheckClicks","registerMutation","registerScroll","registerClick","_handleMultiClick","_getClicks","_checkClicks","timedOutClicks","mutationAfter","scrollAfter","_generateBreadcrumbs","hadScroll","hadMutation","isSlowClick","timeAfterClickMs","endReason","route","getCurrentRoute","metric","setTimeout$3","updateClickDetectorForRecordingEvent","clickDetector","isIncrementalEvent","isIncrementalMouseInteraction","HTMLElement","createBreadcrumb","NodeType","ATTRIBUTES_TO_RECORD","getAttributesToRecord","normalizedKey","handleDomListener","handlerData","isEnabled","isClick","htmlTreeAsString","maxStringLength","getDomTarget","getBaseDomBreadcrumb","handleDom","altKey","metaKey","ctrlKey","shiftKey","isElement","handleKeyboardEvent","updateUserActivity","isContentEditable","isInputElement","hasModifierKey","isCharacterKey","baseBreadcrumb","getKeyboardBreadcrumb","ENTRY_TYPES","resource","entry","entryType","initiatorType","responseEnd","startTime","decodedBodySize","encodedBodySize","responseStatus","transferSize","getAbsoluteTime","statusCode","paint","duration","navigation","domComplete","domContentLoadedEventStart","domContentLoadedEventEnd","domInteractive","loadEventStart","loadEventEnd","redirectCount","webVitalHandler","getter","replayPerformanceEntries","createPerformanceEntry","browserPerformanceTimeOrigin","performance","timeOrigin","getLargestContentfulPaint","lastEntry","getWebVital","isLayoutShift","sources","getCumulativeLayoutShift","layoutShifts","nodes","nodeIds","getFirstInputDelay","getInteractionToNextPaint","attributions","rating","DEBUG_BUILD","__SENTRY_DEBUG__","CONSOLE_LEVELS","PREFIX","_addBreadcrumb","level","addBreadcrumb","logger","_capture","_trace","_logger","exception","infoTick","setConfig","opts","captureExceptions","traceInternals","logger$1","severityLevelFromString","captureException","info","setTimeout","makeReplayLogger","EventBufferSizeExceededError","super","EventBufferArray","events","_totalSize","hasCheckout","waitForCheckout","hasEvents","addEvent","eventSize","finish","Promise","resolve","eventsRet","clear","getEarliestTimestamp","sort","WorkerHandler","worker","_worker","ensureReady","_ensureReadyPromise","reject","success","once","terminate","method","arg","_getAndIncrementId","response","EventBufferCompressionWorker","_earliestTimestamp","_sendEventToWorker","_finishRequest","then","EventBufferProxy","_fallback","_compression","_used","_ensureWorkerIsLoadedPromise","_ensureWorkerIsLoaded","ensureWorkerIsLoaded","_switchToCompressionWorker","addEventPromises","all","createEventBuffer","useCompression","workerUrl","customWorkerUrl","Worker","__SENTRY_EXCLUDE_REPLAY_WORKER__","Blob","createObjectURL","_getWorkerUrl","_loadWorker","hasSessionStorage","sessionStorage","clearSession","removeItem","deleteSession","session","isSampled","sampleRate","random","saveSession","setItem","makeSession","uuid4","started","lastActivity","segmentId","sampled","previousSessionId","createSession","sessionSampleRate","allowBuffering","stickySession","getSessionSampleType","isExpired","initialTime","expiry","targetTime","isSessionExpired","maxReplayDuration","sessionIdleExpire","shouldRefreshSession","loadOrCreateSession","sessionOptions","existingSession","sessionStringFromStorage","getItem","sessionObj","parse","fetchSession","addEventSync","shouldAddEvent","_addEvent","async","eventBuffer","isBufferMode","recordingMode","eventAfterPossibleCallback","isCustomEvent","maybeApplyCallback","getOptions","beforeAddRecordingEvent","isExceeded","reason","handleException","stop","client","getClient","recordDroppedEvent","isPaused","timestampInMs","timeouts","sessionIdlePause","initialTimestamp","isErrorEvent","isTransactionEvent","isFeedbackEvent","handleAfterSendEvent","sendResponse","replayContext","contexts","trace","trace_id","traceIds","handleTransactionEvent","event_id","errorIds","tags","replayId","beforeErrorSampling","sendBufferedReplayOrFlush","handleErrorEvent","handleBeforeSendEvent","exceptionValue","values","getLocationHref","handleHydrationError","handleBreadcrumbs","isBreadcrumbWithCategory","arguments","isTruncated","normalizedArgs","normalizedArg","_meta","warnings","normalizeConsoleBreadcrumb","normalizeBreadcrumb","beforeAddBreadcrumb","resetReplayIdOnDynamicSamplingContext","dsc","getCurrentScope","getPropagationContext","replay_id","activeSpan","getActiveSpan","getDynamicSamplingContextFromSpan","handleGlobalEventListener","hint","isReplayEvent","breadcrumbs","flush","feedback","getSessionId","feedbackId","addFeedbackBreadcrumb","originalException","__rrweb__","isRrwebError","_experiments","log","isErrorEventSampled","errorSampleRate","shouldSampleForBufferEvent","createPerformanceSpans","op","description","startTimestamp","endTimestamp","handleHistorySpanListener","to","handleHistory","urls","addNetworkBreadcrumb","isSentryRequestUrl","shouldFilterRequest","getBodySize","textEncoder","TextEncoder","encode","URLSearchParams","FormData","formDataStr","serializeFormData","ArrayBuffer","byteLength","parseContentLengthHeader","header","parseInt","mergeWarning","warning","headers","newMeta","existingWarnings","makeNetworkReplayBreadcrumb","request","buildSkippedNetworkRequestOrResponse","bodySize","buildNetworkRequestOrResponse","normalizedBody","exceedsSizeLimit","isProbablyJson","first","last","_strIsProbablyJson","truncatedBody","normalizeNetworkBody","getAllowedHeaders","allowedHeaders","reduce","filteredHeaders","urlMatches","fullUrl","baseURI","fixedUrl","getFullUrl","stringMatchesSomePattern","captureFetchBreadcrumbToReplay","status_code","request_body_size","requestBodySize","response_body_size","responseBodySize","captureDetails","networkDetailAllowUrls","networkDetailDenyUrls","networkCaptureBodies","networkRequestHeaders","fetchArgs","getHeadersFromOptions","getRequestHeaders","requestBody","getFetchRequestArgBody","bodyStr","getBodyString","_getRequestInfo","networkResponseHeaders","getAllHeaders","bodyText","res","clone","_tryCloneResponse","_getResponseText","txt","finally","_tryGetResponseText","_parseFetchResponseBody","getResponseData","_getResponseInfo","_prepareFetchData","allHeaders","Headers","captureXhrBreadcrumbToReplay","xhr","xhrInfo","SENTRY_XHR_DATA_KEY","request_headers","getAllResponseHeaders","acc","line","getResponseHeaders","requestWarning","responseBody","responseWarning","errors","responseText","responseType","outerHTML","_parseXhrResponse","_getXhrResponseBody","_prepareXhrData","enrichXhrBreadcrumb","reqSize","resSize","getResponseHeader","_getBodySize","handleNetworkBreadcrumbs","_isXhrBreadcrumb","_isXhrHint","_isFetchBreadcrumb","_isFetchHint","enrichFetchBreadcrumb","beforeAddNetworkBreadcrumb","createMemoryEntry","memoryEntry","jsHeapSizeLimit","totalJSHeapSize","usedJSHeapSize","memory","NAVIGATOR","navigator","getHandleRecordingEmit","hadFirstEvent","_isCheckout","setInitialState","shouldRecordCanvas","isRecordingCanvas","useCompressionOption","blockAllMedia","networkDetailHasUrls","networkRequestHasHeaders","networkResponseHasHeaders","createOptionsEvent","addSettingsEvent","earliestEvent","sendReplayRequest","recordingData","segment_id","eventContext","preparedRecordingData","payloadWithSequence","replayHeaders","sequence","prepareRecordingData","scope","transport","getTransport","dsn","getDsn","resolvedSyncPromise","baseEvent","replay_start_timestamp","error_ids","trace_ids","replay_type","replayEvent","eventHint","integrations","preparedEvent","prepareEvent","getIsolationScope","platform","metadata","getSdkMetadata","version","sdk","prepareReplayEvent","sdkProcessingMetadata","envelope","tunnel","createEnvelope","createEventEnvelopeHeaders","getSdkMetadataForEnvelopeHeader","createReplayEnvelope","send","cause","TransportStatusCodeError","rateLimits","updateRateLimits","isRateLimited","RateLimitError","sendReplay","replayData","retryConfig","interval","onError","setContext","_retryCount","THROTTLED","throttle","maxCount","durationSeconds","counter","isThrottled","floor","_cleanup","a","wasThrottled","ReplayContainer","recordingOptions","performanceEntries","_lastActivity","_isEnabled","_isPaused","_requiresManualStart","_hasInitializedCoreListeners","_context","initialUrl","_recordingOptions","_options","_debouncedFlush","callbackReturnValue","timerId","maxTimerId","maxWait","max","invokeFunc","cancelTimers","debounced","cancel","debounce","_flush","flushMinDelay","flushMaxDelay","_throttledAddEvent","slowClickTimeout","slowClickIgnoreSelectors","experiments","_handleVisibilityChange","visibilityState","_doChangeToForegroundTasks","_doChangeToBackgroundTasks","_handleWindowBlur","_handleWindowFocus","_handleKeyboardEvent","_canvas","initializeSampling","requiresManualStart","_initializeSessionForSampling","_initializeRecording","_updateUserActivity","startBuffering","startRecording","canvasOptions","_stopRecording","continuousCheckout","userAgent","maxTouchPoints","_onMutationHandler","stopRecording","forceFlush","_removeListeners","force","pause","resume","_checkSession","continueRecording","flushImmediate","activityTime","hasStoppedRecording","_updateSessionActivity","_maybeSaveSession","cbResult","conditionalFlush","cancelFlush","urlPath","hash","_clearContext","lastActiveSpan","lastRootSpan","getRootSpan","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","_addListeners","currentSession","_refreshSession","autoFlushOnFeedback","addClickKeypressInstrumentationHandler","addHistoryInstrumentationHandler","addEventProcessor","span","feedbackEvent","includeReplay","addGlobalListeners","_performanceCleanupCallback","addPerformanceEntry","onEntries","clearCallbacks","addPerformanceInstrumentationHandler","addLcpInstrumentationHandler","addClsInstrumentationHandler","addFidInstrumentationHandler","addInpInstrumentationHandler","clearCallback","setupPerformanceObserver","_createCustomBreadcrumb","_addPerformanceEntries","concat","initialTimestampInSeconds","_updateInitialTimestampFromEventBuffer","_popEventContext","_runFlush","addMemoryEntry","dropReason","tooShort","minReplayDuration","tooLong","_flushInProgress","_flushLock","mutationLimit","overMutationLimit","mutationBreadcrumbLimit","getOption","selectors","defaultSelectors","MEDIA_SELECTORS","DEFAULT_NETWORK_HEADERS","_initialized","replayIntegration","Replay","mask","maskAttributes","unmask","block","unblock","ignore","maskFn","privacyOptions","getPrivacyOptions","password","maskAttribute","_initialOptions","_getMergedNetworkHeaders","_isInitialized","isBrowser","afterAllSetup","_setup","_initialize","getReplayId","getRecordingMode","_maybeLoadFromReplayCanvasIntegration","finalOptions","initialOptions","opt","replaysSessionSampleRate","parseSampleRate","replaysOnErrorSampleRate","consoleSandbox","loadReplayOptionsFromClient","canvasIntegration","getIntegrationByName"],"mappings":"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","x_google_ignoreList":[0]}