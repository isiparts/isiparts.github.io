{"version":3,"file":"browser-utils-BUixo4nC.js","sources":["../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/debug-build.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/bindReporter.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/types.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/getNavigationEntry.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/getActivationStart.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/initMetric.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/generateUniqueID.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/observe.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/onHidden.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/runOnce.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/getVisibilityWatcher.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/whenActivated.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/onFCP.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/getCLS.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/getFID.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/polyfills/interactionCountPolyfill.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/interactions.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/lib/whenIdle.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/getINP.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/getLCP.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/onTTFB.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/instrument.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/utils.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/cls.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/browserMetrics.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/instrument/dom.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/instrument/history.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/getNativeImplementation.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/instrument/xhr.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/networkUtils.js","../../../node_modules/.pnpm/@sentry-internal+browser-utils@9.22.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/inp.js"],"sourcesContent":["/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\nexport { DEBUG_BUILD };\n//# sourceMappingURL=debug-build.js.map\n","const getRating = (value, thresholds) => {\n  if (value > thresholds[1]) {\n    return 'poor';\n  }\n  if (value > thresholds[0]) {\n    return 'needs-improvement';\n  }\n  return 'good';\n};\n\nconst bindReporter = (\n  callback,\n  metric,\n  thresholds,\n  reportAllChanges,\n) => {\n  let prevValue;\n  let delta;\n  return (forceReport) => {\n    if (metric.value >= 0) {\n      if (forceReport || reportAllChanges) {\n        delta = metric.value - (prevValue || 0);\n\n        // Report the metric if there's a non-zero delta or if no previous\n        // value exists (which can happen in the case of the document becoming\n        // hidden when the metric value is 0).\n        // See: https://github.com/GoogleChrome/web-vitals/issues/14\n        if (delta || prevValue === undefined) {\n          prevValue = metric.value;\n          metric.delta = delta;\n          metric.rating = getRating(metric.value, thresholds);\n          callback(metric);\n        }\n      }\n    }\n  };\n};\n\nexport { bindReporter };\n//# sourceMappingURL=bindReporter.js.map\n","import { GLOBAL_OBJ } from '@sentry/core';\n\nconst WINDOW = GLOBAL_OBJ\n\n;\n\nexport { WINDOW };\n//# sourceMappingURL=types.js.map\n","import { WINDOW } from '../../../types.js';\n\n/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// sentry-specific change:\n// add optional param to not check for responseStart (see comment below)\nconst getNavigationEntry = (checkResponseStart = true) => {\n  const navigationEntry = WINDOW.performance?.getEntriesByType?.('navigation')[0];\n  // Check to ensure the `responseStart` property is present and valid.\n  // In some cases no value is reported by the browser (for\n  // privacy/security reasons), and in other cases (bugs) the value is\n  // negative or is larger than the current page time. Ignore these cases:\n  // https://github.com/GoogleChrome/web-vitals/issues/137\n  // https://github.com/GoogleChrome/web-vitals/issues/162\n  // https://github.com/GoogleChrome/web-vitals/issues/275\n  if (\n    // sentry-specific change:\n    // We don't want to check for responseStart for our own use of `getNavigationEntry`\n    !checkResponseStart ||\n    (navigationEntry && navigationEntry.responseStart > 0 && navigationEntry.responseStart < performance.now())\n  ) {\n    return navigationEntry;\n  }\n};\n\nexport { getNavigationEntry };\n//# sourceMappingURL=getNavigationEntry.js.map\n","import { getNavigationEntry } from './getNavigationEntry.js';\n\n/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst getActivationStart = () => {\n  const navEntry = getNavigationEntry();\n  return navEntry?.activationStart || 0;\n};\n\nexport { getActivationStart };\n//# sourceMappingURL=getActivationStart.js.map\n","import { WINDOW } from '../../../types.js';\nimport { generateUniqueID } from './generateUniqueID.js';\nimport { getActivationStart } from './getActivationStart.js';\nimport { getNavigationEntry } from './getNavigationEntry.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst initMetric = (name, value) => {\n  const navEntry = getNavigationEntry();\n  let navigationType = 'navigate';\n\n  if (navEntry) {\n    if (WINDOW.document?.prerendering || getActivationStart() > 0) {\n      navigationType = 'prerender';\n    } else if (WINDOW.document?.wasDiscarded) {\n      navigationType = 'restore';\n    } else if (navEntry.type) {\n      navigationType = navEntry.type.replace(/_/g, '-') ;\n    }\n  }\n\n  // Use `entries` type specific for the metric.\n  const entries = [];\n\n  return {\n    name,\n    value: typeof value === 'undefined' ? -1 : value,\n    rating: 'good' , // If needed, will be updated when reported. `const` to keep the type from widening to `string`.\n    delta: 0,\n    entries,\n    id: generateUniqueID(),\n    navigationType,\n  };\n};\n\nexport { initMetric };\n//# sourceMappingURL=initMetric.js.map\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Performantly generate a unique, 30-char string by combining a version\n * number, the current timestamp with a 13-digit number integer.\n * @return {string}\n */\nconst generateUniqueID = () => {\n  return `v4-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n};\n\nexport { generateUniqueID };\n//# sourceMappingURL=generateUniqueID.js.map\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Takes a performance entry type and a callback function, and creates a\n * `PerformanceObserver` instance that will observe the specified entry type\n * with buffering enabled and call the callback _for each entry_.\n *\n * This function also feature-detects entry support and wraps the logic in a\n * try/catch to avoid errors in unsupporting browsers.\n */\nconst observe = (\n  type,\n  callback,\n  opts,\n) => {\n  try {\n    if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n      const po = new PerformanceObserver(list => {\n        // Delay by a microtask to workaround a bug in Safari where the\n        // callback is invoked immediately, rather than in a separate task.\n        // See: https://github.com/GoogleChrome/web-vitals/issues/277\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.resolve().then(() => {\n          callback(list.getEntries() );\n        });\n      });\n      po.observe(\n        Object.assign(\n          {\n            type,\n            buffered: true,\n          },\n          opts || {},\n        ) ,\n      );\n      return po;\n    }\n  } catch (e) {\n    // Do nothing.\n  }\n  return;\n};\n\nexport { observe };\n//# sourceMappingURL=observe.js.map\n","import { WINDOW } from '../../../types.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// Sentry-specific change:\n// This function's logic was NOT updated to web-vitals 4.2.4 but we continue\n// to use the web-vitals 3.5.2 due to us having stricter browser support.\n// PR with context that made the changes: https://github.com/GoogleChrome/web-vitals/pull/442/files#r1530492402\n// The PR removed listening to the `pagehide` event, in favour of only listening to `visibilitychange` event.\n// This is \"more correct\" but some browsers we still support (Safari 12.1-14.0) don't fully support `visibilitychange`\n// or have known bugs w.r.t the `visibilitychange` event.\n// TODO (v9): If we decide to drop support for Safari 12.1-14.0, we can use the logic from web-vitals 4.2.4\n// In this case, we also need to update the integration tests that currently trigger the `pagehide` event to\n// simulate the page being hidden.\nconst onHidden = (cb) => {\n  const onHiddenOrPageHide = (event) => {\n    if (event.type === 'pagehide' || WINDOW.document?.visibilityState === 'hidden') {\n      cb(event);\n    }\n  };\n\n  if (WINDOW.document) {\n    addEventListener('visibilitychange', onHiddenOrPageHide, true);\n    // Some browsers have buggy implementations of visibilitychange,\n    // so we use pagehide in addition, just to be safe.\n    addEventListener('pagehide', onHiddenOrPageHide, true);\n  }\n};\n\nexport { onHidden };\n//# sourceMappingURL=onHidden.js.map\n","/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst runOnce = (cb) => {\n  let called = false;\n  return () => {\n    if (!called) {\n      cb();\n      called = true;\n    }\n  };\n};\n\nexport { runOnce };\n//# sourceMappingURL=runOnce.js.map\n","import { WINDOW } from '../../../types.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nlet firstHiddenTime = -1;\n\nconst initHiddenTime = () => {\n  // If the document is hidden when this code runs, assume it was always\n  // hidden and the page was loaded in the background, with the one exception\n  // that visibility state is always 'hidden' during prerendering, so we have\n  // to ignore that case until prerendering finishes (see: `prerenderingchange`\n  // event logic below).\n  return WINDOW.document.visibilityState === 'hidden' && !WINDOW.document.prerendering ? 0 : Infinity;\n};\n\nconst onVisibilityUpdate = (event) => {\n  // If the document is 'hidden' and no previous hidden timestamp has been\n  // set, update it based on the current event data.\n  if (WINDOW.document.visibilityState === 'hidden' && firstHiddenTime > -1) {\n    // If the event is a 'visibilitychange' event, it means the page was\n    // visible prior to this change, so the event timestamp is the first\n    // hidden time.\n    // However, if the event is not a 'visibilitychange' event, then it must\n    // be a 'prerenderingchange' event, and the fact that the document is\n    // still 'hidden' from the above check means the tab was activated\n    // in a background state and so has always been hidden.\n    firstHiddenTime = event.type === 'visibilitychange' ? event.timeStamp : 0;\n\n    // Remove all listeners now that a `firstHiddenTime` value has been set.\n    removeChangeListeners();\n  }\n};\n\nconst addChangeListeners = () => {\n  addEventListener('visibilitychange', onVisibilityUpdate, true);\n  // IMPORTANT: when a page is prerendering, its `visibilityState` is\n  // 'hidden', so in order to account for cases where this module checks for\n  // visibility during prerendering, an additional check after prerendering\n  // completes is also required.\n  addEventListener('prerenderingchange', onVisibilityUpdate, true);\n};\n\nconst removeChangeListeners = () => {\n  removeEventListener('visibilitychange', onVisibilityUpdate, true);\n  removeEventListener('prerenderingchange', onVisibilityUpdate, true);\n};\n\nconst getVisibilityWatcher = () => {\n  if (WINDOW.document && firstHiddenTime < 0) {\n    // If the document is hidden when this code runs, assume it was hidden\n    // since navigation start. This isn't a perfect heuristic, but it's the\n    // best we can do until an API is available to support querying past\n    // visibilityState.\n    firstHiddenTime = initHiddenTime();\n    addChangeListeners();\n  }\n  return {\n    get firstHiddenTime() {\n      return firstHiddenTime;\n    },\n  };\n};\n\nexport { getVisibilityWatcher };\n//# sourceMappingURL=getVisibilityWatcher.js.map\n","import { WINDOW } from '../../../types.js';\n\n/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst whenActivated = (callback) => {\n  if (WINDOW.document?.prerendering) {\n    addEventListener('prerenderingchange', () => callback(), true);\n  } else {\n    callback();\n  }\n};\n\nexport { whenActivated };\n//# sourceMappingURL=whenActivated.js.map\n","import { bindReporter } from './lib/bindReporter.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { whenActivated } from './lib/whenActivated.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** Thresholds for FCP. See https://web.dev/articles/fcp#what_is_a_good_fcp_score */\nconst FCPThresholds = [1800, 3000];\n\n/**\n * Calculates the [FCP](https://web.dev/articles/fcp) value for the current page and\n * calls the `callback` function once the value is ready, along with the\n * relevant `paint` performance entry used to determine the value. The reported\n * value is a `DOMHighResTimeStamp`.\n */\nconst onFCP = (onReport, opts = {}) => {\n  whenActivated(() => {\n    const visibilityWatcher = getVisibilityWatcher();\n    const metric = initMetric('FCP');\n    let report;\n\n    const handleEntries = (entries) => {\n      entries.forEach(entry => {\n        if (entry.name === 'first-contentful-paint') {\n          po.disconnect();\n\n          // Only report if the page wasn't hidden prior to the first paint.\n          if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n            // The activationStart reference is used because FCP should be\n            // relative to page activation rather than navigation start if the\n            // page was prerendered. But in cases where `activationStart` occurs\n            // after the FCP, this time should be clamped at 0.\n            metric.value = Math.max(entry.startTime - getActivationStart(), 0);\n            metric.entries.push(entry);\n            report(true);\n          }\n        }\n      });\n    };\n\n    const po = observe('paint', handleEntries);\n\n    if (po) {\n      report = bindReporter(onReport, metric, FCPThresholds, opts.reportAllChanges);\n    }\n  });\n};\n\nexport { FCPThresholds, onFCP };\n//# sourceMappingURL=onFCP.js.map\n","import { bindReporter } from './lib/bindReporter.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { runOnce } from './lib/runOnce.js';\nimport { onFCP } from './onFCP.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** Thresholds for CLS. See https://web.dev/articles/cls#what_is_a_good_cls_score */\nconst CLSThresholds = [0.1, 0.25];\n\n/**\n * Calculates the [CLS](https://web.dev/articles/cls) value for the current page and\n * calls the `callback` function once the value is ready to be reported, along\n * with all `layout-shift` performance entries that were used in the metric\n * value calculation. The reported value is a `double` (corresponding to a\n * [layout shift score](https://web.dev/articles/cls#layout_shift_score)).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** CLS should be continually monitored for changes throughout\n * the entire lifespan of a page—including if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nconst onCLS = (onReport, opts = {}) => {\n  // Start monitoring FCP so we can only report CLS if FCP is also reported.\n  // Note: this is done to match the current behavior of CrUX.\n  onFCP(\n    runOnce(() => {\n      const metric = initMetric('CLS', 0);\n      let report;\n\n      let sessionValue = 0;\n      let sessionEntries = [];\n\n      const handleEntries = (entries) => {\n        entries.forEach(entry => {\n          // Only count layout shifts without recent user input.\n          if (!entry.hadRecentInput) {\n            const firstSessionEntry = sessionEntries[0];\n            const lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n\n            // If the entry occurred less than 1 second after the previous entry\n            // and less than 5 seconds after the first entry in the session,\n            // include the entry in the current session. Otherwise, start a new\n            // session.\n            if (\n              sessionValue &&\n              firstSessionEntry &&\n              lastSessionEntry &&\n              entry.startTime - lastSessionEntry.startTime < 1000 &&\n              entry.startTime - firstSessionEntry.startTime < 5000\n            ) {\n              sessionValue += entry.value;\n              sessionEntries.push(entry);\n            } else {\n              sessionValue = entry.value;\n              sessionEntries = [entry];\n            }\n          }\n        });\n\n        // If the current session value is larger than the current CLS value,\n        // update CLS and the entries contributing to it.\n        if (sessionValue > metric.value) {\n          metric.value = sessionValue;\n          metric.entries = sessionEntries;\n          report();\n        }\n      };\n\n      const po = observe('layout-shift', handleEntries);\n      if (po) {\n        report = bindReporter(onReport, metric, CLSThresholds, opts.reportAllChanges);\n\n        onHidden(() => {\n          handleEntries(po.takeRecords() );\n          report(true);\n        });\n\n        // Queue a task to report (if nothing else triggers a report first).\n        // This allows CLS to be reported as soon as FCP fires when\n        // `reportAllChanges` is true.\n        setTimeout(report, 0);\n      }\n    }),\n  );\n};\n\nexport { CLSThresholds, onCLS };\n//# sourceMappingURL=getCLS.js.map\n","import { bindReporter } from './lib/bindReporter.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { runOnce } from './lib/runOnce.js';\nimport { whenActivated } from './lib/whenActivated.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** Thresholds for FID. See https://web.dev/articles/fid#what_is_a_good_fid_score */\nconst FIDThresholds = [100, 300];\n\n/**\n * Calculates the [FID](https://web.dev/articles/fid) value for the current page and\n * calls the `callback` function once the value is ready, along with the\n * relevant `first-input` performance entry used to determine the value. The\n * reported value is a `DOMHighResTimeStamp`.\n *\n * _**Important:** since FID is only reported after the user interacts with the\n * page, it's possible that it will not be reported for some page loads._\n */\nconst onFID = (onReport, opts = {}) => {\n  whenActivated(() => {\n    const visibilityWatcher = getVisibilityWatcher();\n    const metric = initMetric('FID');\n    // eslint-disable-next-line prefer-const\n    let report;\n\n    const handleEntry = (entry) => {\n      // Only report if the page wasn't hidden prior to the first input.\n      if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n        metric.value = entry.processingStart - entry.startTime;\n        metric.entries.push(entry);\n        report(true);\n      }\n    };\n\n    const handleEntries = (entries) => {\n      (entries ).forEach(handleEntry);\n    };\n\n    const po = observe('first-input', handleEntries);\n\n    report = bindReporter(onReport, metric, FIDThresholds, opts.reportAllChanges);\n\n    if (po) {\n      onHidden(\n        runOnce(() => {\n          handleEntries(po.takeRecords() );\n          po.disconnect();\n        }),\n      );\n    }\n  });\n};\n\nexport { FIDThresholds, onFID };\n//# sourceMappingURL=getFID.js.map\n","import { observe } from '../observe.js';\n\n/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nlet interactionCountEstimate = 0;\nlet minKnownInteractionId = Infinity;\nlet maxKnownInteractionId = 0;\n\nconst updateEstimate = (entries) => {\n  entries.forEach(e => {\n    if (e.interactionId) {\n      minKnownInteractionId = Math.min(minKnownInteractionId, e.interactionId);\n      maxKnownInteractionId = Math.max(maxKnownInteractionId, e.interactionId);\n\n      interactionCountEstimate = maxKnownInteractionId ? (maxKnownInteractionId - minKnownInteractionId) / 7 + 1 : 0;\n    }\n  });\n};\n\nlet po;\n\n/**\n * Returns the `interactionCount` value using the native API (if available)\n * or the polyfill estimate in this module.\n */\nconst getInteractionCount = () => {\n  return po ? interactionCountEstimate : performance.interactionCount || 0;\n};\n\n/**\n * Feature detects native support or initializes the polyfill if needed.\n */\nconst initInteractionCountPolyfill = () => {\n  if ('interactionCount' in performance || po) return;\n\n  po = observe('event', updateEstimate, {\n    type: 'event',\n    buffered: true,\n    durationThreshold: 0,\n  } );\n};\n\nexport { getInteractionCount, initInteractionCountPolyfill };\n//# sourceMappingURL=interactionCountPolyfill.js.map\n","import { getInteractionCount } from './polyfills/interactionCountPolyfill.js';\n\n/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// A list of longest interactions on the page (by latency) sorted so the\n// longest one is first. The list is at most MAX_INTERACTIONS_TO_CONSIDER long.\nconst longestInteractionList = [];\n\n// A mapping of longest interactions by their interaction ID.\n// This is used for faster lookup.\nconst longestInteractionMap = new Map();\n\n// The default `durationThreshold` used across this library for observing\n// `event` entries via PerformanceObserver.\nconst DEFAULT_DURATION_THRESHOLD = 40;\n\n// Used to store the interaction count after a bfcache restore, since p98\n// interaction latencies should only consider the current navigation.\nlet prevInteractionCount = 0;\n\n/**\n * Returns the interaction count since the last bfcache restore (or for the\n * full page lifecycle if there were no bfcache restores).\n */\nconst getInteractionCountForNavigation = () => {\n  return getInteractionCount() - prevInteractionCount;\n};\n\n/**\n * Returns the estimated p98 longest interaction based on the stored\n * interaction candidates and the interaction count for the current page.\n */\nconst estimateP98LongestInteraction = () => {\n  const candidateInteractionIndex = Math.min(\n    longestInteractionList.length - 1,\n    Math.floor(getInteractionCountForNavigation() / 50),\n  );\n\n  return longestInteractionList[candidateInteractionIndex];\n};\n\n// To prevent unnecessary memory usage on pages with lots of interactions,\n// store at most 10 of the longest interactions to consider as INP candidates.\nconst MAX_INTERACTIONS_TO_CONSIDER = 10;\n\n/**\n * A list of callback functions to run before each entry is processed.\n * Exposing this list allows the attribution build to hook into the\n * entry processing pipeline.\n */\nconst entryPreProcessingCallbacks = [];\n\n/**\n * Takes a performance entry and adds it to the list of worst interactions\n * if its duration is long enough to make it among the worst. If the\n * entry is part of an existing interaction, it is merged and the latency\n * and entries list is updated as needed.\n */\nconst processInteractionEntry = (entry) => {\n  entryPreProcessingCallbacks.forEach(cb => cb(entry));\n\n  // Skip further processing for entries that cannot be INP candidates.\n  if (!(entry.interactionId || entry.entryType === 'first-input')) return;\n\n  // The least-long of the 10 longest interactions.\n  const minLongestInteraction = longestInteractionList[longestInteractionList.length - 1];\n\n  const existingInteraction = longestInteractionMap.get(entry.interactionId);\n\n  // Only process the entry if it's possibly one of the ten longest,\n  // or if it's part of an existing interaction.\n  if (\n    existingInteraction ||\n    longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER ||\n    (minLongestInteraction && entry.duration > minLongestInteraction.latency)\n  ) {\n    // If the interaction already exists, update it. Otherwise create one.\n    if (existingInteraction) {\n      // If the new entry has a longer duration, replace the old entries,\n      // otherwise add to the array.\n      if (entry.duration > existingInteraction.latency) {\n        existingInteraction.entries = [entry];\n        existingInteraction.latency = entry.duration;\n      } else if (\n        entry.duration === existingInteraction.latency &&\n        entry.startTime === existingInteraction.entries[0]?.startTime\n      ) {\n        existingInteraction.entries.push(entry);\n      }\n    } else {\n      const interaction = {\n        id: entry.interactionId,\n        latency: entry.duration,\n        entries: [entry],\n      };\n      longestInteractionMap.set(interaction.id, interaction);\n      longestInteractionList.push(interaction);\n    }\n\n    // Sort the entries by latency (descending) and keep only the top ten.\n    longestInteractionList.sort((a, b) => b.latency - a.latency);\n    if (longestInteractionList.length > MAX_INTERACTIONS_TO_CONSIDER) {\n      longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER).forEach(i => longestInteractionMap.delete(i.id));\n    }\n  }\n};\n\nexport { DEFAULT_DURATION_THRESHOLD, entryPreProcessingCallbacks, estimateP98LongestInteraction, longestInteractionList, longestInteractionMap, processInteractionEntry };\n//# sourceMappingURL=interactions.js.map\n","import { WINDOW } from '../../../types.js';\nimport { onHidden } from './onHidden.js';\nimport { runOnce } from './runOnce.js';\n\n/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Runs the passed callback during the next idle period, or immediately\n * if the browser's visibility state is (or becomes) hidden.\n */\nconst whenIdle = (cb) => {\n  const rIC = WINDOW.requestIdleCallback || WINDOW.setTimeout;\n\n  let handle = -1;\n  // eslint-disable-next-line no-param-reassign\n  cb = runOnce(cb) ;\n  // If the document is hidden, run the callback immediately, otherwise\n  // race an idle callback with the next `visibilitychange` event.\n  if (WINDOW.document?.visibilityState === 'hidden') {\n    cb();\n  } else {\n    handle = rIC(cb);\n    onHidden(cb);\n  }\n  return handle;\n};\n\nexport { whenIdle };\n//# sourceMappingURL=whenIdle.js.map\n","import { WINDOW } from '../../types.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { DEFAULT_DURATION_THRESHOLD, processInteractionEntry, estimateP98LongestInteraction } from './lib/interactions.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { initInteractionCountPolyfill } from './lib/polyfills/interactionCountPolyfill.js';\nimport { whenActivated } from './lib/whenActivated.js';\nimport { whenIdle } from './lib/whenIdle.js';\n\n/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** Thresholds for INP. See https://web.dev/articles/inp#what_is_a_good_inp_score */\nconst INPThresholds = [200, 500];\n\n/**\n * Calculates the [INP](https://web.dev/articles/inp) value for the current\n * page and calls the `callback` function once the value is ready, along with\n * the `event` performance entries reported for that interaction. The reported\n * value is a `DOMHighResTimeStamp`.\n *\n * A custom `durationThreshold` configuration option can optionally be passed to\n * control what `event-timing` entries are considered for INP reporting. The\n * default threshold is `40`, which means INP scores of less than 40 are\n * reported as 0. Note that this will not affect your 75th percentile INP value\n * unless that value is also less than 40 (well below the recommended\n * [good](https://web.dev/articles/inp#what_is_a_good_inp_score) threshold).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** INP should be continually monitored for changes throughout\n * the entire lifespan of a page—including if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nconst onINP = (onReport, opts = {}) => {\n  // Return if the browser doesn't support all APIs needed to measure INP.\n  if (!('PerformanceEventTiming' in WINDOW && 'interactionId' in PerformanceEventTiming.prototype)) {\n    return;\n  }\n\n  whenActivated(() => {\n    // TODO(philipwalton): remove once the polyfill is no longer needed.\n    initInteractionCountPolyfill();\n\n    const metric = initMetric('INP');\n    // eslint-disable-next-line prefer-const\n    let report;\n\n    const handleEntries = (entries) => {\n      // Queue the `handleEntries()` callback in the next idle task.\n      // This is needed to increase the chances that all event entries that\n      // occurred between the user interaction and the next paint\n      // have been dispatched. Note: there is currently an experiment\n      // running in Chrome (EventTimingKeypressAndCompositionInteractionId)\n      // 123+ that if rolled out fully may make this no longer necessary.\n      whenIdle(() => {\n        entries.forEach(processInteractionEntry);\n\n        const inp = estimateP98LongestInteraction();\n\n        if (inp && inp.latency !== metric.value) {\n          metric.value = inp.latency;\n          metric.entries = inp.entries;\n          report();\n        }\n      });\n    };\n\n    const po = observe('event', handleEntries, {\n      // Event Timing entries have their durations rounded to the nearest 8ms,\n      // so a duration of 40ms would be any event that spans 2.5 or more frames\n      // at 60Hz. This threshold is chosen to strike a balance between usefulness\n      // and performance. Running this callback for any interaction that spans\n      // just one or two frames is likely not worth the insight that could be\n      // gained.\n      durationThreshold: opts.durationThreshold != null ? opts.durationThreshold : DEFAULT_DURATION_THRESHOLD,\n    });\n\n    report = bindReporter(onReport, metric, INPThresholds, opts.reportAllChanges);\n\n    if (po) {\n      // Also observe entries of type `first-input`. This is useful in cases\n      // where the first interaction is less than the `durationThreshold`.\n      po.observe({ type: 'first-input', buffered: true });\n\n      onHidden(() => {\n        handleEntries(po.takeRecords() );\n        report(true);\n      });\n    }\n  });\n};\n\nexport { INPThresholds, onINP };\n//# sourceMappingURL=getINP.js.map\n","import { WINDOW } from '../../types.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { runOnce } from './lib/runOnce.js';\nimport { whenActivated } from './lib/whenActivated.js';\nimport { whenIdle } from './lib/whenIdle.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** Thresholds for LCP. See https://web.dev/articles/lcp#what_is_a_good_lcp_score */\nconst LCPThresholds = [2500, 4000];\n\nconst reportedMetricIDs = {};\n\n/**\n * Calculates the [LCP](https://web.dev/articles/lcp) value for the current page and\n * calls the `callback` function once the value is ready (along with the\n * relevant `largest-contentful-paint` performance entry used to determine the\n * value). The reported value is a `DOMHighResTimeStamp`.\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called any time a new `largest-contentful-paint`\n * performance entry is dispatched, or once the final value of the metric has\n * been determined.\n */\nconst onLCP = (onReport, opts = {}) => {\n  whenActivated(() => {\n    const visibilityWatcher = getVisibilityWatcher();\n    const metric = initMetric('LCP');\n    let report;\n\n    const handleEntries = (entries) => {\n      // If reportAllChanges is set then call this function for each entry,\n      // otherwise only consider the last one.\n      if (!opts.reportAllChanges) {\n        // eslint-disable-next-line no-param-reassign\n        entries = entries.slice(-1);\n      }\n\n      entries.forEach(entry => {\n        // Only report if the page wasn't hidden prior to LCP.\n        if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n          // The startTime attribute returns the value of the renderTime if it is\n          // not 0, and the value of the loadTime otherwise. The activationStart\n          // reference is used because LCP should be relative to page activation\n          // rather than navigation start if the page was pre-rendered. But in cases\n          // where `activationStart` occurs after the LCP, this time should be\n          // clamped at 0.\n          metric.value = Math.max(entry.startTime - getActivationStart(), 0);\n          metric.entries = [entry];\n          report();\n        }\n      });\n    };\n\n    const po = observe('largest-contentful-paint', handleEntries);\n\n    if (po) {\n      report = bindReporter(onReport, metric, LCPThresholds, opts.reportAllChanges);\n\n      const stopListening = runOnce(() => {\n        if (!reportedMetricIDs[metric.id]) {\n          handleEntries(po.takeRecords() );\n          po.disconnect();\n          reportedMetricIDs[metric.id] = true;\n          report(true);\n        }\n      });\n\n      // Stop listening after input. Note: while scrolling is an input that\n      // stops LCP observation, it's unreliable since it can be programmatically\n      // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75\n      ['keydown', 'click'].forEach(type => {\n        // Wrap in a setTimeout so the callback is run in a separate task\n        // to avoid extending the keyboard/click handler to reduce INP impact\n        // https://github.com/GoogleChrome/web-vitals/issues/383\n        if (WINDOW.document) {\n          addEventListener(type, () => whenIdle(stopListening ), {\n            once: true,\n            capture: true,\n          });\n        }\n      });\n\n      onHidden(stopListening);\n    }\n  });\n};\n\nexport { LCPThresholds, onLCP };\n//# sourceMappingURL=getLCP.js.map\n","import { WINDOW } from '../../types.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { getNavigationEntry } from './lib/getNavigationEntry.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { whenActivated } from './lib/whenActivated.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** Thresholds for TTFB. See https://web.dev/articles/ttfb#what_is_a_good_ttfb_score */\nconst TTFBThresholds = [800, 1800];\n\n/**\n * Runs in the next task after the page is done loading and/or prerendering.\n * @param callback\n */\nconst whenReady = (callback) => {\n  if (WINDOW.document?.prerendering) {\n    whenActivated(() => whenReady(callback));\n  } else if (WINDOW.document?.readyState !== 'complete') {\n    addEventListener('load', () => whenReady(callback), true);\n  } else {\n    // Queue a task so the callback runs after `loadEventEnd`.\n    setTimeout(callback, 0);\n  }\n};\n\n/**\n * Calculates the [TTFB](https://web.dev/articles/ttfb) value for the\n * current page and calls the `callback` function once the page has loaded,\n * along with the relevant `navigation` performance entry used to determine the\n * value. The reported value is a `DOMHighResTimeStamp`.\n *\n * Note, this function waits until after the page is loaded to call `callback`\n * in order to ensure all properties of the `navigation` entry are populated.\n * This is useful if you want to report on other metrics exposed by the\n * [Navigation Timing API](https://w3c.github.io/navigation-timing/). For\n * example, the TTFB metric starts from the page's [time\n * origin](https://www.w3.org/TR/hr-time-2/#sec-time-origin), which means it\n * includes time spent on DNS lookup, connection negotiation, network latency,\n * and server processing time.\n */\nconst onTTFB = (onReport, opts = {}) => {\n  const metric = initMetric('TTFB');\n  const report = bindReporter(onReport, metric, TTFBThresholds, opts.reportAllChanges);\n\n  whenReady(() => {\n    const navigationEntry = getNavigationEntry();\n\n    if (navigationEntry) {\n      // The activationStart reference is used because TTFB should be\n      // relative to page activation rather than navigation start if the\n      // page was prerendered. But in cases where `activationStart` occurs\n      // after the first byte is received, this time should be clamped at 0.\n      metric.value = Math.max(navigationEntry.responseStart - getActivationStart(), 0);\n\n      metric.entries = [navigationEntry];\n      report(true);\n    }\n  });\n};\n\nexport { TTFBThresholds, onTTFB };\n//# sourceMappingURL=onTTFB.js.map\n","import { logger, getFunctionName } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { onCLS } from './web-vitals/getCLS.js';\nimport { onFID } from './web-vitals/getFID.js';\nimport { onINP } from './web-vitals/getINP.js';\nimport { onLCP } from './web-vitals/getLCP.js';\nimport { observe } from './web-vitals/lib/observe.js';\nimport { onTTFB } from './web-vitals/onTTFB.js';\n\nconst handlers = {};\nconst instrumented = {};\n\nlet _previousCls;\nlet _previousFid;\nlet _previousLcp;\nlet _previousTtfb;\nlet _previousInp;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nfunction addClsInstrumentationHandler(\n  callback,\n  stopOnCallback = false,\n) {\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nfunction addLcpInstrumentationHandler(\n  callback,\n  stopOnCallback = false,\n) {\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addFidInstrumentationHandler(callback) {\n  return addMetricObserver('fid', callback, instrumentFid, _previousFid);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n */\nfunction addTtfbInstrumentationHandler(callback) {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addInpInstrumentationHandler(\n  callback,\n) {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addPerformanceInstrumentationHandler(\n  type,\n  callback,\n) {\n  addHandler(type, callback);\n\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type, data) {\n  const typeHandlers = handlers[type];\n\n  if (!typeHandlers?.length) {\n    return;\n  }\n\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\nfunction instrumentCls() {\n  return onCLS(\n    metric => {\n      triggerHandlers('cls', {\n        metric,\n      });\n      _previousCls = metric;\n    },\n    // We want the callback to be called whenever the CLS value updates.\n    // By default, the callback is only called when the tab goes to the background.\n    { reportAllChanges: true },\n  );\n}\n\nfunction instrumentFid() {\n  return onFID(metric => {\n    triggerHandlers('fid', {\n      metric,\n    });\n    _previousFid = metric;\n  });\n}\n\nfunction instrumentLcp() {\n  return onLCP(\n    metric => {\n      triggerHandlers('lcp', {\n        metric,\n      });\n      _previousLcp = metric;\n    },\n    // We want the callback to be called whenever the LCP value updates.\n    // By default, the callback is only called when the tab goes to the background.\n    { reportAllChanges: true },\n  );\n}\n\nfunction instrumentTtfb() {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric,\n    });\n    _previousTtfb = metric;\n  });\n}\n\nfunction instrumentInp() {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric,\n    });\n    _previousInp = metric;\n  });\n}\n\nfunction addMetricObserver(\n  type,\n  callback,\n  instrumentFn,\n  previousValue,\n  stopOnCallback = false,\n) {\n  addHandler(type, callback);\n\n  let stopListening;\n\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n\n  if (previousValue) {\n    callback({ metric: previousValue });\n  }\n\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\n\nfunction instrumentPerformanceObserver(type) {\n  const options = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n\n  observe(\n    type,\n    entries => {\n      triggerHandlers(type, { entries });\n    },\n    options,\n  );\n}\n\nfunction addHandler(type, handler) {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] ).push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(\n  type,\n  callback,\n  stopListening,\n) {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n\n    const typeHandlers = handlers[type];\n\n    if (!typeHandlers) {\n      return;\n    }\n\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\n\n/**\n * Check if a PerformanceEntry is a PerformanceEventTiming by checking for the `duration` property.\n */\nfunction isPerformanceEventTiming(entry) {\n  return 'duration' in entry;\n}\n\nexport { addClsInstrumentationHandler, addFidInstrumentationHandler, addInpInstrumentationHandler, addLcpInstrumentationHandler, addPerformanceInstrumentationHandler, addTtfbInstrumentationHandler, isPerformanceEventTiming };\n//# sourceMappingURL=instrument.js.map\n","import { spanToJSON, withActiveSpan, startInactiveSpan, getClient, getCurrentScope } from '@sentry/core';\nimport { WINDOW } from '../types.js';\n\n/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nfunction startAndEndSpan(\n  parentSpan,\n  startTimeInSeconds,\n  endTime,\n  { ...ctx },\n) {\n  const parentStartTime = spanToJSON(parentSpan).start_timestamp;\n  if (parentStartTime && parentStartTime > startTimeInSeconds) {\n    // We can only do this for SentrySpans...\n    if (typeof (parentSpan ).updateStartTime === 'function') {\n      (parentSpan ).updateStartTime(startTimeInSeconds);\n    }\n  }\n\n  // The return value only exists for tests\n  return withActiveSpan(parentSpan, () => {\n    const span = startInactiveSpan({\n      startTime: startTimeInSeconds,\n      ...ctx,\n    });\n\n    if (span) {\n      span.end(endTime);\n    }\n\n    return span;\n  });\n}\n\n/**\n * Starts an inactive, standalone span used to send web vital values to Sentry.\n * DO NOT use this for arbitrary spans, as these spans require special handling\n * during ingestion to extract metrics.\n *\n * This function adds a bunch of attributes and data to the span that's shared\n * by all web vital standalone spans. However, you need to take care of adding\n * the actual web vital value as an event to the span. Also, you need to assign\n * a transaction name and some other values that are specific to the web vital.\n *\n * Ultimately, you also need to take care of ending the span to send it off.\n *\n * @param options\n *\n * @returns an inactive, standalone and NOT YET ended span\n */\nfunction startStandaloneWebVitalSpan(options) {\n  const client = getClient();\n  if (!client) {\n    return;\n  }\n\n  const { name, transaction, attributes: passedAttributes, startTime } = options;\n\n  const { release, environment, sendDefaultPii } = client.getOptions();\n  // We need to get the replay, user, and activeTransaction from the current scope\n  // so that we can associate replay id, profile id, and a user display to the span\n  const replay = client.getIntegrationByName('Replay');\n  const replayId = replay?.getReplayId();\n\n  const scope = getCurrentScope();\n\n  const user = scope.getUser();\n  const userDisplay = user !== undefined ? user.email || user.id || user.ip_address : undefined;\n\n  let profileId;\n  try {\n    // @ts-expect-error skip optional chaining to save bundle size with try catch\n    profileId = scope.getScopeData().contexts.profile.profile_id;\n  } catch {\n    // do nothing\n  }\n\n  const attributes = {\n    release,\n    environment,\n\n    user: userDisplay || undefined,\n    profile_id: profileId || undefined,\n    replay_id: replayId || undefined,\n\n    transaction,\n\n    // Web vital score calculation relies on the user agent to account for different\n    // browsers setting different thresholds for what is considered a good/meh/bad value.\n    // For example: Chrome vs. Chrome Mobile\n    'user_agent.original': WINDOW.navigator?.userAgent,\n\n    // This tells Sentry to infer the IP address from the request\n    'client.address': sendDefaultPii ? '{{auto}}' : undefined,\n\n    ...passedAttributes,\n  };\n\n  return startInactiveSpan({\n    name,\n    attributes,\n    startTime,\n    experimental: {\n      standalone: true,\n    },\n  });\n}\n\n/** Get the browser performance API. */\nfunction getBrowserPerformanceAPI() {\n  // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n  return WINDOW.addEventListener && WINDOW.performance;\n}\n\n/**\n * Converts from milliseconds to seconds\n * @param time time in ms\n */\nfunction msToSec(time) {\n  return time / 1000;\n}\n\n/**\n * Converts ALPN protocol ids to name and version.\n *\n * (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)\n * @param nextHopProtocol PerformanceResourceTiming.nextHopProtocol\n */\nfunction extractNetworkProtocol(nextHopProtocol) {\n  let name = 'unknown';\n  let version = 'unknown';\n  let _name = '';\n  for (const char of nextHopProtocol) {\n    // http/1.1 etc.\n    if (char === '/') {\n      [name, version] = nextHopProtocol.split('/') ;\n      break;\n    }\n    // h2, h3 etc.\n    if (!isNaN(Number(char))) {\n      name = _name === 'h' ? 'http' : _name;\n      version = nextHopProtocol.split(_name)[1] ;\n      break;\n    }\n    _name += char;\n  }\n  if (_name === nextHopProtocol) {\n    // webrtc, ftp, etc.\n    name = _name;\n  }\n  return { name, version };\n}\n\nexport { extractNetworkProtocol, getBrowserPerformanceAPI, isMeasurementValue, msToSec, startAndEndSpan, startStandaloneWebVitalSpan };\n//# sourceMappingURL=utils.js.map\n","import { getClient, getActiveSpan, getRootSpan, spanToJSON, logger, browserPerformanceTimeOrigin, getCurrentScope, htmlTreeAsString, SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { addClsInstrumentationHandler } from './instrument.js';\nimport { msToSec, startStandaloneWebVitalSpan } from './utils.js';\nimport { onHidden } from './web-vitals/lib/onHidden.js';\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value once\n *\n * - the page visibility is hidden\n * - a navigation span is started (to stop CLS measurement for SPA soft navigations)\n *\n * Once either of these events triggers, the CLS value is sent as a standalone span and we stop\n * measuring CLS.\n */\nfunction trackClsAsStandaloneSpan() {\n  let standaloneCLsValue = 0;\n  let standaloneClsEntry;\n  let pageloadSpanId;\n\n  if (!supportsLayoutShift()) {\n    return;\n  }\n\n  let sentSpan = false;\n  function _collectClsOnce() {\n    if (sentSpan) {\n      return;\n    }\n    sentSpan = true;\n    if (pageloadSpanId) {\n      sendStandaloneClsSpan(standaloneCLsValue, standaloneClsEntry, pageloadSpanId);\n    }\n    cleanupClsHandler();\n  }\n\n  const cleanupClsHandler = addClsInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1] ;\n    if (!entry) {\n      return;\n    }\n    standaloneCLsValue = metric.value;\n    standaloneClsEntry = entry;\n  }, true);\n\n  // use pagehide event from web-vitals\n  onHidden(() => {\n    _collectClsOnce();\n  });\n\n  // Since the call chain of this function is synchronous and evaluates before the SDK client is created,\n  // we need to wait with subscribing to a client hook until the client is created. Therefore, we defer\n  // to the next tick after the SDK setup.\n  setTimeout(() => {\n    const client = getClient();\n\n    if (!client) {\n      return;\n    }\n\n    const unsubscribeStartNavigation = client.on('startNavigationSpan', () => {\n      _collectClsOnce();\n      unsubscribeStartNavigation?.();\n    });\n\n    const activeSpan = getActiveSpan();\n    if (activeSpan) {\n      const rootSpan = getRootSpan(activeSpan);\n      const spanJSON = spanToJSON(rootSpan);\n      if (spanJSON.op === 'pageload') {\n        pageloadSpanId = rootSpan.spanContext().spanId;\n      }\n    }\n  }, 0);\n}\n\nfunction sendStandaloneClsSpan(clsValue, entry, pageloadSpanId) {\n  DEBUG_BUILD && logger.log(`Sending CLS span (${clsValue})`);\n\n  const startTime = msToSec((browserPerformanceTimeOrigin() || 0) + (entry?.startTime || 0));\n  const routeName = getCurrentScope().getScopeData().transactionName;\n\n  const name = entry ? htmlTreeAsString(entry.sources[0]?.node) : 'Layout shift';\n\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser.cls',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'ui.webvital.cls',\n    [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: entry?.duration || 0,\n    // attach the pageload span id to the CLS span so that we can link them in the UI\n    'sentry.pageload.span_id': pageloadSpanId,\n  };\n\n  const span = startStandaloneWebVitalSpan({\n    name,\n    transaction: routeName,\n    attributes,\n    startTime,\n  });\n\n  if (span) {\n    span.addEvent('cls', {\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: '',\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: clsValue,\n    });\n\n    // LayoutShift performance entries always have a duration of 0, so we don't need to add `entry.duration` here\n    // see: https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/duration\n    span.end(startTime);\n  }\n}\n\nfunction supportsLayoutShift() {\n  try {\n    return PerformanceObserver.supportedEntryTypes.includes('layout-shift');\n  } catch {\n    return false;\n  }\n}\n\nexport { trackClsAsStandaloneSpan };\n//# sourceMappingURL=cls.js.map\n","import { browserPerformanceTimeOrigin, spanToJSON, setMeasurement, getActiveSpan, parseUrl, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, htmlTreeAsString, getComponentName } from '@sentry/core';\nimport { WINDOW } from '../types.js';\nimport { trackClsAsStandaloneSpan } from './cls.js';\nimport { addPerformanceInstrumentationHandler, addFidInstrumentationHandler, addLcpInstrumentationHandler, addTtfbInstrumentationHandler, addClsInstrumentationHandler } from './instrument.js';\nimport { getBrowserPerformanceAPI, msToSec, startAndEndSpan, extractNetworkProtocol, isMeasurementValue } from './utils.js';\nimport { getActivationStart } from './web-vitals/lib/getActivationStart.js';\nimport { getNavigationEntry } from './web-vitals/lib/getNavigationEntry.js';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher.js';\n\nconst MAX_INT_AS_BYTES = 2147483647;\n\nlet _performanceCursor = 0;\n\nlet _measurements = {};\nlet _lcpEntry;\nlet _clsEntry;\n\n/**\n * Start tracking web vitals.\n * The callback returned by this function can be used to stop tracking & ensure all measurements are final & captured.\n *\n * @returns A function that forces web vitals collection\n */\nfunction startTrackingWebVitals({ recordClsStandaloneSpans }) {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n    if (performance.mark) {\n      WINDOW.performance.mark('sentry-tracing-init');\n    }\n    const fidCleanupCallback = _trackFID();\n    const lcpCleanupCallback = _trackLCP();\n    const ttfbCleanupCallback = _trackTtfb();\n    const clsCleanupCallback = recordClsStandaloneSpans ? trackClsAsStandaloneSpan() : _trackCLS();\n\n    return () => {\n      fidCleanupCallback();\n      lcpCleanupCallback();\n      ttfbCleanupCallback();\n      clsCleanupCallback?.();\n    };\n  }\n\n  return () => undefined;\n}\n\n/**\n * Start tracking long tasks.\n */\nfunction startTrackingLongTasks() {\n  addPerformanceInstrumentationHandler('longtask', ({ entries }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n\n    const { op: parentOp, start_timestamp: parentStartTimestamp } = spanToJSON(parent);\n\n    for (const entry of entries) {\n      const startTime = msToSec((browserPerformanceTimeOrigin() ) + entry.startTime);\n      const duration = msToSec(entry.duration);\n\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding a span if the long task started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-task',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n        },\n      });\n    }\n  });\n}\n\n/**\n * Start tracking long animation frames.\n */\nfunction startTrackingLongAnimationFrames() {\n  // NOTE: the current web-vitals version (3.5.2) does not support long-animation-frame, so\n  // we directly observe `long-animation-frame` events instead of through the web-vitals\n  // `observe` helper function.\n  const observer = new PerformanceObserver(list => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of list.getEntries() ) {\n      if (!entry.scripts[0]) {\n        continue;\n      }\n\n      const startTime = msToSec((browserPerformanceTimeOrigin() ) + entry.startTime);\n\n      const { start_timestamp: parentStartTimestamp, op: parentOp } = spanToJSON(parent);\n\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding the span if the long animation frame started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      const duration = msToSec(entry.duration);\n\n      const attributes = {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      };\n\n      const initialScript = entry.scripts[0];\n      const { invoker, invokerType, sourceURL, sourceFunctionName, sourceCharPosition } = initialScript;\n      attributes['browser.script.invoker'] = invoker;\n      attributes['browser.script.invoker_type'] = invokerType;\n      if (sourceURL) {\n        attributes['code.filepath'] = sourceURL;\n      }\n      if (sourceFunctionName) {\n        attributes['code.function'] = sourceFunctionName;\n      }\n      if (sourceCharPosition !== -1) {\n        attributes['browser.script.source_char_position'] = sourceCharPosition;\n      }\n\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-animation-frame',\n        attributes,\n      });\n    }\n  });\n\n  observer.observe({ type: 'long-animation-frame', buffered: true });\n}\n\n/**\n * Start tracking interaction events.\n */\nfunction startTrackingInteractions() {\n  addPerformanceInstrumentationHandler('event', ({ entries }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of entries) {\n      if (entry.name === 'click') {\n        const startTime = msToSec((browserPerformanceTimeOrigin() ) + entry.startTime);\n        const duration = msToSec(entry.duration);\n\n        const spanOptions = {\n          name: htmlTreeAsString(entry.target),\n          op: `ui.interaction.${entry.name}`,\n          startTime: startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n          },\n        };\n\n        const componentName = getComponentName(entry.target);\n        if (componentName) {\n          spanOptions.attributes['ui.component_name'] = componentName;\n        }\n\n        startAndEndSpan(parent, startTime, startTime + duration, spanOptions);\n      }\n    }\n  });\n}\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value and last entry\n * to the `_measurements` object which ultimately is applied to the pageload span's measurements.\n */\nfunction _trackCLS() {\n  return addClsInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1] ;\n    if (!entry) {\n      return;\n    }\n    _measurements['cls'] = { value: metric.value, unit: '' };\n    _clsEntry = entry;\n  }, true);\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP() {\n  return addLcpInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    _measurements['lcp'] = { value: metric.value, unit: 'millisecond' };\n    _lcpEntry = entry ;\n  }, true);\n}\n\n/** Starts tracking the First Input Delay on the current page. */\nfunction _trackFID() {\n  return addFidInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin() );\n    const startTime = msToSec(entry.startTime);\n    _measurements['fid'] = { value: metric.value, unit: 'millisecond' };\n    _measurements['mark.fid'] = { value: timeOrigin + startTime, unit: 'second' };\n  });\n}\n\nfunction _trackTtfb() {\n  return addTtfbInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    _measurements['ttfb'] = { value: metric.value, unit: 'millisecond' };\n  });\n}\n\n/** Add performance related spans to a transaction */\nfunction addPerformanceEntries(span, options) {\n  const performance = getBrowserPerformanceAPI();\n  const origin = browserPerformanceTimeOrigin();\n  if (!performance?.getEntries || !origin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n\n  const timeOrigin = msToSec(origin);\n\n  const performanceEntries = performance.getEntries();\n\n  const { op, start_timestamp: transactionStartTime } = spanToJSON(span);\n\n  performanceEntries.slice(_performanceCursor).forEach(entry => {\n    const startTime = msToSec(entry.startTime);\n    const duration = msToSec(\n      // Inexplicably, Chrome sometimes emits a negative duration. We need to work around this.\n      // There is a SO post attempting to explain this, but it leaves one with open questions: https://stackoverflow.com/questions/23191918/peformance-getentries-and-negative-duration-display\n      // The way we clamp the value is probably not accurate, since we have observed this happen for things that may take a while to load, like for example the replay worker.\n      // TODO: Investigate why this happens and how to properly mitigate. For now, this is a workaround to prevent transactions being dropped due to negative duration spans.\n      Math.max(0, entry.duration),\n    );\n\n    if (op === 'navigation' && transactionStartTime && timeOrigin + startTime < transactionStartTime) {\n      return;\n    }\n\n    switch (entry.entryType) {\n      case 'navigation': {\n        _addNavigationSpans(span, entry , timeOrigin);\n        break;\n      }\n      case 'mark':\n      case 'paint':\n      case 'measure': {\n        _addMeasureSpans(span, entry, startTime, duration, timeOrigin);\n\n        // capture web vitals\n        const firstHidden = getVisibilityWatcher();\n        // Only report if the page wasn't hidden prior to the web vital.\n        const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n        if (entry.name === 'first-paint' && shouldRecord) {\n          _measurements['fp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        if (entry.name === 'first-contentful-paint' && shouldRecord) {\n          _measurements['fcp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        break;\n      }\n      case 'resource': {\n        _addResourceSpans(span, entry , entry.name, startTime, duration, timeOrigin);\n        break;\n      }\n      // Ignore other entry types.\n    }\n  });\n\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n\n  _trackNavigator(span);\n\n  // Measurements are only available for pageload transactions\n  if (op === 'pageload') {\n    _addTtfbRequestTimeToMeasurements(_measurements);\n\n    const fidMark = _measurements['mark.fid'];\n    if (fidMark && _measurements['fid']) {\n      // create span for FID\n      startAndEndSpan(span, fidMark.value, fidMark.value + msToSec(_measurements['fid'].value), {\n        name: 'first input delay',\n        op: 'ui.action',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n        },\n      });\n\n      // Delete mark.fid as we don't want it to be part of final payload\n      delete _measurements['mark.fid'];\n    }\n\n    // If FCP is not recorded we should not record the cls value\n    // according to the new definition of CLS.\n    // TODO: Check if the first condition is still necessary: `onCLS` already only fires once `onFCP` was called.\n    if (!('fcp' in _measurements) || !options.recordClsOnPageloadSpan) {\n      delete _measurements.cls;\n    }\n\n    Object.entries(_measurements).forEach(([measurementName, measurement]) => {\n      setMeasurement(measurementName, measurement.value, measurement.unit);\n    });\n\n    // Set timeOrigin which denotes the timestamp which to base the LCP/FCP/FP/TTFB measurements on\n    span.setAttribute('performance.timeOrigin', timeOrigin);\n\n    // In prerendering scenarios, where a page might be prefetched and pre-rendered before the user clicks the link,\n    // the navigation starts earlier than when the user clicks it. Web Vitals should always be based on the\n    // user-perceived time, so they are not reported from the actual start of the navigation, but rather from the\n    // time where the user actively started the navigation, for example by clicking a link.\n    // This is user action is called \"activation\" and the time between navigation and activation is stored in\n    // the `activationStart` attribute of the \"navigation\" PerformanceEntry.\n    span.setAttribute('performance.activationStart', getActivationStart());\n\n    _setWebVitalAttributes(span);\n  }\n\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/**\n * Create measure related spans.\n * Exported only for tests.\n */\nfunction _addMeasureSpans(\n  span,\n  entry,\n  startTime,\n  duration,\n  timeOrigin,\n) {\n  const navEntry = getNavigationEntry(false);\n  const requestTime = msToSec(navEntry ? navEntry.requestStart : 0);\n  // Because performance.measure accepts arbitrary timestamps it can produce\n  // spans that happen before the browser even makes a request for the page.\n  //\n  // An example of this is the automatically generated Next.js-before-hydration\n  // spans created by the Next.js framework.\n  //\n  // To prevent this we will pin the start timestamp to the request start time\n  // This does make duration inaccurate, so if this does happen, we will add\n  // an attribute to the span\n  const measureStartTimestamp = timeOrigin + Math.max(startTime, requestTime);\n  const startTimeStamp = timeOrigin + startTime;\n  const measureEndTimestamp = startTimeStamp + duration;\n\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics',\n  };\n\n  if (measureStartTimestamp !== startTimeStamp) {\n    attributes['sentry.browser.measure_happened_before_request'] = true;\n    attributes['sentry.browser.measure_start_time'] = measureStartTimestamp;\n  }\n\n  // Measurements from third parties can be off, which would create invalid spans, dropping transactions in the process.\n  if (measureStartTimestamp <= measureEndTimestamp) {\n    startAndEndSpan(span, measureStartTimestamp, measureEndTimestamp, {\n      name: entry.name ,\n      op: entry.entryType ,\n      attributes,\n    });\n  }\n}\n\n/**\n * Instrument navigation entries\n * exported only for tests\n */\nfunction _addNavigationSpans(span, entry, timeOrigin) {\n  (['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'] ).forEach(event => {\n    _addPerformanceNavigationTiming(span, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(span, entry, 'secureConnection', timeOrigin, 'TLS/SSL');\n  _addPerformanceNavigationTiming(span, entry, 'fetch', timeOrigin, 'cache');\n  _addPerformanceNavigationTiming(span, entry, 'domainLookup', timeOrigin, 'DNS');\n\n  _addRequest(span, entry, timeOrigin);\n}\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(\n  span,\n  entry,\n  event,\n  timeOrigin,\n  name = event,\n) {\n  const eventEnd = _getEndPropertyNameForNavigationTiming(event) ;\n  const end = entry[eventEnd];\n  const start = entry[`${event}Start`];\n  if (!start || !end) {\n    return;\n  }\n  startAndEndSpan(span, timeOrigin + msToSec(start), timeOrigin + msToSec(end), {\n    op: `browser.${name}`,\n    name: entry.name,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      ...(event === 'redirect' && entry.redirectCount != null ? { 'http.redirect_count': entry.redirectCount } : {}),\n    },\n  });\n}\n\nfunction _getEndPropertyNameForNavigationTiming(event) {\n  if (event === 'secureConnection') {\n    return 'connectEnd';\n  }\n  if (event === 'fetch') {\n    return 'domainLookupStart';\n  }\n  return `${event}End`;\n}\n\n/** Create request and response related spans */\nfunction _addRequest(span, entry, timeOrigin) {\n  const requestStartTimestamp = timeOrigin + msToSec(entry.requestStart );\n  const responseEndTimestamp = timeOrigin + msToSec(entry.responseEnd );\n  const responseStartTimestamp = timeOrigin + msToSec(entry.responseStart );\n  if (entry.responseEnd) {\n    // It is possible that we are collecting these metrics when the page hasn't finished loading yet, for example when the HTML slowly streams in.\n    // In this case, ie. when the document request hasn't finished yet, `entry.responseEnd` will be 0.\n    // In order not to produce faulty spans, where the end timestamp is before the start timestamp, we will only collect\n    // these spans when the responseEnd value is available. The backend (Relay) would drop the entire span if it contained faulty spans.\n    startAndEndSpan(span, requestStartTimestamp, responseEndTimestamp, {\n      op: 'browser.request',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      },\n    });\n\n    startAndEndSpan(span, responseStartTimestamp, responseEndTimestamp, {\n      op: 'browser.response',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      },\n    });\n  }\n}\n\n/**\n * Create resource-related spans.\n * Exported only for tests.\n */\nfunction _addResourceSpans(\n  span,\n  entry,\n  resourceUrl,\n  startTime,\n  duration,\n  timeOrigin,\n) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n\n  const parsedUrl = parseUrl(resourceUrl);\n\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics',\n  };\n  setResourceEntrySizeData(attributes, entry, 'transferSize', 'http.response_transfer_size');\n  setResourceEntrySizeData(attributes, entry, 'encodedBodySize', 'http.response_content_length');\n  setResourceEntrySizeData(attributes, entry, 'decodedBodySize', 'http.decoded_response_content_length');\n\n  // `deliveryType` is experimental and does not exist everywhere\n  const deliveryType = (entry ).deliveryType;\n  if (deliveryType != null) {\n    attributes['http.response_delivery_type'] = deliveryType;\n  }\n\n  // Types do not reflect this property yet\n  const renderBlockingStatus = (entry )\n    .renderBlockingStatus;\n  if (renderBlockingStatus) {\n    attributes['resource.render_blocking_status'] = renderBlockingStatus;\n  }\n\n  if (parsedUrl.protocol) {\n    attributes['url.scheme'] = parsedUrl.protocol.split(':').pop(); // the protocol returned by parseUrl includes a :, but OTEL spec does not, so we remove it.\n  }\n\n  if (parsedUrl.host) {\n    attributes['server.address'] = parsedUrl.host;\n  }\n\n  attributes['url.same_origin'] = resourceUrl.includes(WINDOW.location.origin);\n\n  const { name, version } = extractNetworkProtocol(entry.nextHopProtocol);\n  attributes['network.protocol.name'] = name;\n  attributes['network.protocol.version'] = version;\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  startAndEndSpan(span, startTimestamp, endTimestamp, {\n    name: resourceUrl.replace(WINDOW.location.origin, ''),\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource.other',\n    attributes,\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(span) {\n  const navigator = WINDOW.navigator ;\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  const connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      span.setAttribute('effectiveConnectionType', connection.effectiveType);\n    }\n\n    if (connection.type) {\n      span.setAttribute('connectionType', connection.type);\n    }\n\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = { value: connection.rtt, unit: 'millisecond' };\n    }\n  }\n\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    span.setAttribute('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    span.setAttribute('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to span to allow debugging */\nfunction _setWebVitalAttributes(span) {\n  if (_lcpEntry) {\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      span.setAttribute('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n\n    if (_lcpEntry.id) {\n      span.setAttribute('lcp.id', _lcpEntry.id);\n    }\n\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      span.setAttribute('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n\n    if (_lcpEntry.loadTime != null) {\n      // loadTime is the time of LCP that's related to receiving the LCP element response..\n      span.setAttribute('lcp.loadTime', _lcpEntry.loadTime);\n    }\n\n    if (_lcpEntry.renderTime != null) {\n      // renderTime is loadTime + rendering time\n      // it's 0 if the LCP element is loaded from a 3rd party origin that doesn't send the\n      // `Timing-Allow-Origin` header.\n      span.setAttribute('lcp.renderTime', _lcpEntry.renderTime);\n    }\n\n    span.setAttribute('lcp.size', _lcpEntry.size);\n  }\n\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n  if (_clsEntry?.sources) {\n    _clsEntry.sources.forEach((source, index) =>\n      span.setAttribute(`cls.source.${index + 1}`, htmlTreeAsString(source.node)),\n    );\n  }\n}\n\nfunction setResourceEntrySizeData(\n  attributes,\n  entry,\n  key,\n  dataKey,\n) {\n  const entryVal = entry[key];\n  if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {\n    attributes[dataKey] = entryVal;\n  }\n}\n\n/**\n * Add ttfb request time information to measurements.\n *\n * ttfb information is added via vendored web vitals library.\n */\nfunction _addTtfbRequestTimeToMeasurements(_measurements) {\n  const navEntry = getNavigationEntry(false);\n  if (!navEntry) {\n    return;\n  }\n\n  const { responseStart, requestStart } = navEntry;\n\n  if (requestStart <= responseStart) {\n    _measurements['ttfb.requestTime'] = {\n      value: responseStart - requestStart,\n      unit: 'millisecond',\n    };\n  }\n}\n\nexport { _addMeasureSpans, _addNavigationSpans, _addResourceSpans, addPerformanceEntries, startTrackingInteractions, startTrackingLongAnimationFrames, startTrackingLongTasks, startTrackingWebVitals };\n//# sourceMappingURL=browserMetrics.js.map\n","import { addHandler, maybeInstrument, triggerHandlers, fill, addNonEnumerableProperty, uuid4 } from '@sentry/core';\nimport { WINDOW } from '../types.js';\n\nconst DEBOUNCE_DURATION = 1000;\n\nlet debounceTimerID;\nlet lastCapturedEventType;\nlet lastCapturedEventTargetId;\n\n/**\n * Add an instrumentation handler for when a click or a keypress happens.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addClickKeypressInstrumentationHandler(handler) {\n  const type = 'dom';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentDOM);\n}\n\n/** Exported for tests only. */\nfunction instrumentDOM() {\n  if (!WINDOW.document) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target) => {\n    const globalObject = WINDOW ;\n    const proto = globalObject[target]?.prototype;\n\n    // eslint-disable-next-line no-prototype-builtins\n    if (!proto?.hasOwnProperty?.('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function ( type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const handlers = (this.__sentry_instrumentation_handlers__ =\n              this.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener) {\n        return function ( type, listener, options) {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const handlers = this.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount--;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete this.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\n/**\n * Check whether the event is similar to the last captured one. For example, two click events on the same button.\n */\nfunction isSimilarToLastCapturedEvent(event) {\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (event.type !== lastCapturedEventType) {\n    return false;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (!event.target || (event.target )._sentryId !== lastCapturedEventTargetId) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return true;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(eventType, target) {\n  // We are only interested in filtering `keypress` events for now.\n  if (eventType !== 'keypress') {\n    return false;\n  }\n\n  if (!target?.tagName) {\n    return true;\n  }\n\n  // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n  // e.g.tabbing through elements, hotkeys, etc.\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n */\nfunction makeDOMEventHandler(\n  handler,\n  globalListener = false,\n) {\n  return (event) => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || event['_sentryCaptured']) {\n      return;\n    }\n\n    const target = getEventTarget(event);\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event.type, target)) {\n      return;\n    }\n\n    // Mark event as \"seen\"\n    addNonEnumerableProperty(event, '_sentryCaptured', true);\n\n    if (target && !target._sentryId) {\n      // Add UUID to event target so we can identify if\n      addNonEnumerableProperty(target, '_sentryId', uuid4());\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no last captured event, it means that we can safely capture the new event and store it for future comparisons.\n    // If there is a last captured event, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    if (!isSimilarToLastCapturedEvent(event)) {\n      const handlerData = { event, name, global: globalListener };\n      handler(handlerData);\n      lastCapturedEventType = event.type;\n      lastCapturedEventTargetId = target ? target._sentryId : undefined;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      lastCapturedEventTargetId = undefined;\n      lastCapturedEventType = undefined;\n    }, DEBOUNCE_DURATION);\n  };\n}\n\nfunction getEventTarget(event) {\n  try {\n    return event.target ;\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n    return null;\n  }\n}\n\nexport { addClickKeypressInstrumentationHandler, instrumentDOM };\n//# sourceMappingURL=dom.js.map\n","import { addHandler, maybeInstrument, triggerHandlers, supportsHistory, fill } from '@sentry/core';\nimport { WINDOW } from '../types.js';\n\nlet lastHref;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addHistoryInstrumentationHandler(handler) {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\n\n/**\n * Exported just for testing\n */\nfunction instrumentHistory() {\n  // The `popstate` event may also be triggered on `pushState`, but it may not always reliably be emitted by the browser\n  // Which is why we also monkey-patch methods below, in addition to this\n  WINDOW.addEventListener('popstate', () => {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n\n    if (from === to) {\n      return;\n    }\n\n    const handlerData = { from, to } ;\n    triggerHandlers('history', handlerData);\n  });\n\n  // Just guard against this not being available, in weird environments\n  if (!supportsHistory()) {\n    return;\n  }\n\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function ( ...args) {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        const from = lastHref;\n\n        // Ensure the URL is absolute\n        // this can be either a path, then it is relative to the current origin\n        // or a full URL of the current origin - other origins are not allowed\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#url\n        // coerce to string (this is what pushState does)\n        const to = getAbsoluteUrl(String(url));\n\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n\n        if (from === to) {\n          return originalHistoryFunction.apply(this, args);\n        }\n\n        const handlerData = { from, to } ;\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n\nfunction getAbsoluteUrl(urlOrPath) {\n  try {\n    const url = new URL(urlOrPath, WINDOW.location.origin);\n    return url.toString();\n  } catch {\n    // fallback, just do nothing\n    return urlOrPath;\n  }\n}\n\nexport { addHistoryInstrumentationHandler, instrumentHistory };\n//# sourceMappingURL=history.js.map\n","import { isNativeFunction, logger } from '@sentry/core';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { WINDOW } from './types.js';\n\n/**\n * We generally want to use window.fetch / window.setTimeout.\n * However, in some cases this may be wrapped (e.g. by Zone.js for Angular),\n * so we try to get an unpatched version of this from a sandboxed iframe.\n */\n\nconst cachedImplementations = {};\n\n/**\n * Get the native implementation of a browser function.\n *\n * This can be used to ensure we get an unwrapped version of a function, in cases where a wrapped function can lead to problems.\n *\n * The following methods can be retrieved:\n * - `setTimeout`: This can be wrapped by e.g. Angular, causing change detection to be triggered.\n * - `fetch`: This can be wrapped by e.g. ad-blockers, causing an infinite loop when a request is blocked.\n */\nfunction getNativeImplementation(\n  name,\n) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n\n  let impl = WINDOW[name] ;\n\n  // Fast path to avoid DOM I/O\n  if (isNativeFunction(impl)) {\n    return (cachedImplementations[name] = impl.bind(WINDOW) );\n  }\n\n  const document = WINDOW.document;\n  // eslint-disable-next-line deprecation/deprecation\n  if (document && typeof document.createElement === 'function') {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow?.[name]) {\n        impl = contentWindow[name] ;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      // Could not create sandbox iframe, just use window.xxx\n      DEBUG_BUILD && logger.warn(`Could not create sandbox iframe for ${name} check, bailing to window.${name}: `, e);\n    }\n  }\n\n  // Sanity check: This _should_ not happen, but if it does, we just skip caching...\n  // This can happen e.g. in tests where fetch may not be available in the env, or similar.\n  if (!impl) {\n    return impl;\n  }\n\n  return (cachedImplementations[name] = impl.bind(WINDOW) );\n}\n\n/** Clear a cached implementation. */\nfunction clearCachedImplementation(name) {\n  cachedImplementations[name] = undefined;\n}\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nfunction fetch(...rest) {\n  return getNativeImplementation('fetch')(...rest);\n}\n\n/**\n * Get an unwrapped `setTimeout` method.\n * This ensures that even if e.g. Angular wraps `setTimeout`, we get the native implementation,\n * avoiding triggering change detection.\n */\nfunction setTimeout(...rest) {\n  return getNativeImplementation('setTimeout')(...rest);\n}\n\nexport { clearCachedImplementation, fetch, getNativeImplementation, setTimeout };\n//# sourceMappingURL=getNativeImplementation.js.map\n","import { addHandler, maybeInstrument, timestampInSeconds, isString, triggerHandlers } from '@sentry/core';\nimport { WINDOW } from '../types.js';\n\nconst SENTRY_XHR_DATA_KEY = '__sentry_xhr_v3__';\n\n/**\n * Add an instrumentation handler for when an XHR request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addXhrInstrumentationHandler(handler) {\n  const type = 'xhr';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentXHR);\n}\n\n/** Exported only for tests. */\nfunction instrumentXHR() {\n  if (!(WINDOW ).XMLHttpRequest) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  xhrproto.open = new Proxy(xhrproto.open, {\n    apply(\n      originalOpen,\n      xhrOpenThisArg,\n      xhrOpenArgArray\n\n,\n    ) {\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n      //       it means the error, that was caused by your XHR call did not\n      //       have a stack trace. If you are using HttpClient integration,\n      //       this is the expected behavior, as we are using this virtual error to capture\n      //       the location of your XHR call, and group your HttpClient events accordingly.\n      const virtualError = new Error();\n\n      const startTimestamp = timestampInSeconds() * 1000;\n\n      // open() should always be called with two or more arguments\n      // But to be on the safe side, we actually validate this and bail out if we don't have a method & url\n      const method = isString(xhrOpenArgArray[0]) ? xhrOpenArgArray[0].toUpperCase() : undefined;\n      const url = parseXhrUrlArg(xhrOpenArgArray[1]);\n\n      if (!method || !url) {\n        return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);\n      }\n\n      xhrOpenThisArg[SENTRY_XHR_DATA_KEY] = {\n        method,\n        url,\n        request_headers: {},\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      if (method === 'POST' && url.match(/sentry_key/)) {\n        xhrOpenThisArg.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = xhrOpenThisArg[SENTRY_XHR_DATA_KEY];\n\n        if (!xhrInfo) {\n          return;\n        }\n\n        if (xhrOpenThisArg.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhrOpenThisArg.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          const handlerData = {\n            endTimestamp: timestampInSeconds() * 1000,\n            startTimestamp,\n            xhr: xhrOpenThisArg,\n            virtualError,\n          };\n          triggerHandlers('xhr', handlerData);\n        }\n      };\n\n      if ('onreadystatechange' in xhrOpenThisArg && typeof xhrOpenThisArg.onreadystatechange === 'function') {\n        xhrOpenThisArg.onreadystatechange = new Proxy(xhrOpenThisArg.onreadystatechange, {\n          apply(originalOnreadystatechange, onreadystatechangeThisArg, onreadystatechangeArgArray) {\n            onreadystatechangeHandler();\n            return originalOnreadystatechange.apply(onreadystatechangeThisArg, onreadystatechangeArgArray);\n          },\n        });\n      } else {\n        xhrOpenThisArg.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      xhrOpenThisArg.setRequestHeader = new Proxy(xhrOpenThisArg.setRequestHeader, {\n        apply(\n          originalSetRequestHeader,\n          setRequestHeaderThisArg,\n          setRequestHeaderArgArray,\n        ) {\n          const [header, value] = setRequestHeaderArgArray;\n\n          const xhrInfo = setRequestHeaderThisArg[SENTRY_XHR_DATA_KEY];\n\n          if (xhrInfo && isString(header) && isString(value)) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n\n          return originalSetRequestHeader.apply(setRequestHeaderThisArg, setRequestHeaderArgArray);\n        },\n      });\n\n      return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);\n    },\n  });\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  xhrproto.send = new Proxy(xhrproto.send, {\n    apply(originalSend, sendThisArg, sendArgArray) {\n      const sentryXhrData = sendThisArg[SENTRY_XHR_DATA_KEY];\n\n      if (!sentryXhrData) {\n        return originalSend.apply(sendThisArg, sendArgArray);\n      }\n\n      if (sendArgArray[0] !== undefined) {\n        sentryXhrData.body = sendArgArray[0];\n      }\n\n      const handlerData = {\n        startTimestamp: timestampInSeconds() * 1000,\n        xhr: sendThisArg,\n      };\n      triggerHandlers('xhr', handlerData);\n\n      return originalSend.apply(sendThisArg, sendArgArray);\n    },\n  });\n}\n\n/**\n * Parses the URL argument of a XHR method to a string.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open#url\n * url: A string or any other object with a stringifier — including a URL object — that provides the URL of the resource to send the request to.\n *\n * @param url - The URL argument of an XHR method\n * @returns The parsed URL string or undefined if the URL is invalid\n */\nfunction parseXhrUrlArg(url) {\n  if (isString(url)) {\n    return url;\n  }\n\n  try {\n    // If the passed in argument is not a string, it should have a `toString` method as a stringifier.\n    // If that fails, we just return undefined (like in IE11 where URL is not available)\n    return (url ).toString();\n  } catch {} // eslint-disable-line no-empty\n\n  return undefined;\n}\n\nexport { SENTRY_XHR_DATA_KEY, addXhrInstrumentationHandler, instrumentXHR };\n//# sourceMappingURL=xhr.js.map\n","import { logger } from '@sentry/core';\nimport { DEBUG_BUILD } from './debug-build.js';\n\n/**\n * Serializes FormData.\n *\n * This is a bit simplified, but gives us a decent estimate.\n * This converts e.g. { name: 'Anne Smith', age: 13 } to 'name=Anne+Smith&age=13'.\n *\n */\nfunction serializeFormData(formData) {\n  // @ts-expect-error passing FormData to URLSearchParams actually works\n  return new URLSearchParams(formData).toString();\n}\n\n/** Get the string representation of a body. */\nfunction getBodyString(body, _logger = logger) {\n  try {\n    if (typeof body === 'string') {\n      return [body];\n    }\n\n    if (body instanceof URLSearchParams) {\n      return [body.toString()];\n    }\n\n    if (body instanceof FormData) {\n      return [serializeFormData(body)];\n    }\n\n    if (!body) {\n      return [undefined];\n    }\n  } catch (error) {\n    DEBUG_BUILD && _logger.error(error, 'Failed to serialize body', body);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n\n  DEBUG_BUILD && _logger.info('Skipping network body because of body type', body);\n\n  return [undefined, 'UNPARSEABLE_BODY_TYPE'];\n}\n\n/**\n * Parses the fetch arguments to extract the request payload.\n *\n * We only support getting the body from the fetch options.\n */\nfunction getFetchRequestArgBody(fetchArgs = []) {\n  if (fetchArgs.length !== 2 || typeof fetchArgs[1] !== 'object') {\n    return undefined;\n  }\n\n  return (fetchArgs[1] ).body;\n}\n\nexport { getBodyString, getFetchRequestArgBody, serializeFormData };\n//# sourceMappingURL=networkUtils.js.map\n","import { browserPerformanceTimeOrigin, getActiveSpan, getRootSpan, spanToJSON, getCurrentScope, htmlTreeAsString, SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';\nimport { addPerformanceInstrumentationHandler, addInpInstrumentationHandler, isPerformanceEventTiming } from './instrument.js';\nimport { getBrowserPerformanceAPI, msToSec, startStandaloneWebVitalSpan } from './utils.js';\n\nconst LAST_INTERACTIONS = [];\nconst INTERACTIONS_SPAN_MAP = new Map();\n\n/**\n * Start tracking INP webvital events.\n */\nfunction startTrackingINP() {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    const inpCallback = _trackINP();\n\n    return () => {\n      inpCallback();\n    };\n  }\n\n  return () => undefined;\n}\n\nconst INP_ENTRY_MAP = {\n  click: 'click',\n  pointerdown: 'click',\n  pointerup: 'click',\n  mousedown: 'click',\n  mouseup: 'click',\n  touchstart: 'click',\n  touchend: 'click',\n  mouseover: 'hover',\n  mouseout: 'hover',\n  mouseenter: 'hover',\n  mouseleave: 'hover',\n  pointerover: 'hover',\n  pointerout: 'hover',\n  pointerenter: 'hover',\n  pointerleave: 'hover',\n  dragstart: 'drag',\n  dragend: 'drag',\n  drag: 'drag',\n  dragenter: 'drag',\n  dragleave: 'drag',\n  dragover: 'drag',\n  drop: 'drag',\n  keydown: 'press',\n  keyup: 'press',\n  keypress: 'press',\n  input: 'press',\n};\n\n/** Starts tracking the Interaction to Next Paint on the current page. */\nfunction _trackINP() {\n  return addInpInstrumentationHandler(({ metric }) => {\n    if (metric.value == undefined) {\n      return;\n    }\n\n    const entry = metric.entries.find(entry => entry.duration === metric.value && INP_ENTRY_MAP[entry.name]);\n\n    if (!entry) {\n      return;\n    }\n\n    const { interactionId } = entry;\n    const interactionType = INP_ENTRY_MAP[entry.name];\n\n    /** Build the INP span, create an envelope from the span, and then send the envelope */\n    const startTime = msToSec((browserPerformanceTimeOrigin() ) + entry.startTime);\n    const duration = msToSec(metric.value);\n    const activeSpan = getActiveSpan();\n    const rootSpan = activeSpan ? getRootSpan(activeSpan) : undefined;\n\n    // We first try to lookup the span from our INTERACTIONS_SPAN_MAP,\n    // where we cache the route per interactionId\n    const cachedSpan = interactionId != null ? INTERACTIONS_SPAN_MAP.get(interactionId) : undefined;\n\n    const spanToUse = cachedSpan || rootSpan;\n\n    // Else, we try to use the active span.\n    // Finally, we fall back to look at the transactionName on the scope\n    const routeName = spanToUse ? spanToJSON(spanToUse).description : getCurrentScope().getScopeData().transactionName;\n\n    const name = htmlTreeAsString(entry.target);\n    const attributes = {\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser.inp',\n      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `ui.interaction.${interactionType}`,\n      [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: entry.duration,\n    };\n\n    const span = startStandaloneWebVitalSpan({\n      name,\n      transaction: routeName,\n      attributes,\n      startTime,\n    });\n\n    if (span) {\n      span.addEvent('inp', {\n        [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: 'millisecond',\n        [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: metric.value,\n      });\n\n      span.end(startTime + duration);\n    }\n  });\n}\n\n/**\n * Register a listener to cache route information for INP interactions.\n */\nfunction registerInpInteractionListener() {\n  const handleEntries = ({ entries }) => {\n    const activeSpan = getActiveSpan();\n    const activeRootSpan = activeSpan && getRootSpan(activeSpan);\n\n    entries.forEach(entry => {\n      if (!isPerformanceEventTiming(entry) || !activeRootSpan) {\n        return;\n      }\n\n      const interactionId = entry.interactionId;\n      if (interactionId == null) {\n        return;\n      }\n\n      // If the interaction was already recorded before, nothing more to do\n      if (INTERACTIONS_SPAN_MAP.has(interactionId)) {\n        return;\n      }\n\n      // We keep max. 10 interactions in the list, then remove the oldest one & clean up\n      if (LAST_INTERACTIONS.length > 10) {\n        const last = LAST_INTERACTIONS.shift() ;\n        INTERACTIONS_SPAN_MAP.delete(last);\n      }\n\n      // We add the interaction to the list of recorded interactions\n      // and store the span for this interaction\n      LAST_INTERACTIONS.push(interactionId);\n      INTERACTIONS_SPAN_MAP.set(interactionId, activeRootSpan);\n    });\n  };\n\n  addPerformanceInstrumentationHandler('event', handleEntries);\n  addPerformanceInstrumentationHandler('first-input', handleEntries);\n}\n\nexport { registerInpInteractionListener, startTrackingINP };\n//# sourceMappingURL=inp.js.map\n"],"names":["DEBUG_BUILD","__SENTRY_DEBUG__","bindReporter","callback","metric","thresholds","reportAllChanges","prevValue","delta","forceReport","value","rating","getRating","WINDOW","GLOBAL_OBJ","getNavigationEntry","checkResponseStart","navigationEntry","_b","_a","performance","getEntriesByType","responseStart","now","getActivationStart","navEntry","activationStart","initMetric","name","navigationType","document","prerendering","wasDiscarded","type","replace","entries","id","Date","Math","floor","random","observe","opts","PerformanceObserver","supportedEntryTypes","includes","po","list","Promise","resolve","then","getEntries","Object","assign","buffered","e","onHidden","cb","onHiddenOrPageHide","event","visibilityState","addEventListener","runOnce","called","firstHiddenTime","onVisibilityUpdate","timeStamp","removeChangeListeners","removeEventListener","getVisibilityWatcher","Infinity","whenActivated","FCPThresholds","CLSThresholds","onCLS","onReport","visibilityWatcher","report","forEach","entry","disconnect","startTime","max","push","onFCP","sessionValue","sessionEntries","handleEntries","hadRecentInput","firstSessionEntry","lastSessionEntry","length","takeRecords","setTimeout","FIDThresholds","interactionCountEstimate","minKnownInteractionId","maxKnownInteractionId","updateEstimate","interactionId","min","longestInteractionList","longestInteractionMap","Map","getInteractionCountForNavigation","interactionCount","entryPreProcessingCallbacks","processInteractionEntry","entryType","minLongestInteraction","existingInteraction","get","duration","latency","interaction","set","sort","a","b","splice","delete","i","whenIdle","rIC","requestIdleCallback","handle","INPThresholds","onINP","PerformanceEventTiming","prototype","durationThreshold","inp","candidateInteractionIndex","estimateP98LongestInteraction","LCPThresholds","reportedMetricIDs","TTFBThresholds","whenReady","readyState","handlers","instrumented","_previousCls","_previousFid","_previousLcp","_previousTtfb","_previousInp","addClsInstrumentationHandler","stopOnCallback","addMetricObserver","instrumentCls","addLcpInstrumentationHandler","instrumentLcp","addFidInstrumentationHandler","instrumentFid","addInpInstrumentationHandler","instrumentInp","addPerformanceInstrumentationHandler","addHandler","options","triggerHandlers","instrumentPerformanceObserver","getCleanupCallback","data","typeHandlers","handler","logger","error","getFunctionName","handleEntry","processingStart","onFID","slice","stopListening","once","capture","onLCP","instrumentTtfb","onTTFB","instrumentFn","previousValue","index","indexOf","isMeasurementValue","isFinite","startAndEndSpan","parentSpan","startTimeInSeconds","endTime","ctx","parentStartTime","spanToJSON","start_timestamp","updateStartTime","withActiveSpan","span","startInactiveSpan","end","startStandaloneWebVitalSpan","client","getClient","transaction","attributes","passedAttributes","release","environment","sendDefaultPii","getOptions","replay","getIntegrationByName","replayId","getReplayId","scope","getCurrentScope","user","getUser","userDisplay","email","ip_address","profileId","getScopeData","contexts","profile","profile_id","replay_id","navigator","userAgent","experimental","standalone","getBrowserPerformanceAPI","msToSec","time","extractNetworkProtocol","nextHopProtocol","version","_name","char","split","isNaN","Number","trackClsAsStandaloneSpan","standaloneClsEntry","pageloadSpanId","standaloneCLsValue","supportsLayoutShift","sentSpan","_collectClsOnce","clsValue","log","browserPerformanceTimeOrigin","routeName","transactionName","htmlTreeAsString","sources","node","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME","addEvent","SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT","SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE","sendStandaloneClsSpan","cleanupClsHandler","unsubscribeStartNavigation","on","activeSpan","getActiveSpan","rootSpan","getRootSpan","op","spanContext","spanId","_lcpEntry","_clsEntry","_performanceCursor","_measurements","startTrackingWebVitals","recordClsStandaloneSpans","mark","fidCleanupCallback","timeOrigin","unit","lcpCleanupCallback","ttfbCleanupCallback","clsCleanupCallback","startTrackingLongTasks","parent","parentOp","parentStartTimestamp","startTrackingLongAnimationFrames","scripts","initialScript","invoker","invokerType","sourceURL","sourceFunctionName","sourceCharPosition","startTrackingInteractions","spanOptions","target","componentName","getComponentName","addPerformanceEntries","origin","performanceEntries","transactionStartTime","_addPerformanceNavigationTiming","requestStartTimestamp","requestStart","responseEndTimestamp","responseEnd","responseStartTimestamp","_addRequest","_addNavigationSpans","requestTime","measureStartTimestamp","startTimeStamp","measureEndTimestamp","_addMeasureSpans","firstHidden","shouldRecord","resourceUrl","initiatorType","parsedUrl","parseUrl","setResourceEntrySizeData","deliveryType","renderBlockingStatus","protocol","pop","host","location","startTimestamp","endTimestamp","_addResourceSpans","connection","effectiveType","setAttribute","rtt","deviceMemory","hardwareConcurrency","String","_trackNavigator","_addTtfbRequestTimeToMeasurements","fidMark","recordClsOnPageloadSpan","cls","measurementName","measurement","setMeasurement","element","url","trim","loadTime","renderTime","size","source","_setWebVitalAttributes","eventEnd","_getEndPropertyNameForNavigationTiming","start","redirectCount","key","dataKey","entryVal","debounceTimerID","lastCapturedEventType","lastCapturedEventTargetId","lastHref","addClickKeypressInstrumentationHandler","maybeInstrument","instrumentDOM","triggerDOMHandler","bind","globalDOMEventHandler","makeDOMEventHandler","proto","hasOwnProperty","call","fill","originalAddEventListener","listener","this","__sentry_instrumentation_handlers__","handlerForType","refCount","originalRemoveEventListener","keys","globalListener","getEventTarget","eventType","tagName","isContentEditable","shouldSkipDOMEvent","addNonEnumerableProperty","_sentryId","uuid4","isSimilarToLastCapturedEvent","global","clearTimeout","addHistoryInstrumentationHandler","instrumentHistory","historyReplacementFunction","originalHistoryFunction","args","from","to","urlOrPath","URL","toString","getAbsoluteUrl","apply","href","supportsHistory","history","cachedImplementations","getNativeImplementation","cached","impl","isNativeFunction","createElement","sandbox","hidden","head","appendChild","contentWindow","removeChild","warn","clearCachedImplementation","rest","SENTRY_XHR_DATA_KEY","addXhrInstrumentationHandler","instrumentXHR","XMLHttpRequest","xhrproto","open","Proxy","originalOpen","xhrOpenThisArg","xhrOpenArgArray","virtualError","Error","timestampInSeconds","method","isString","toUpperCase","parseXhrUrlArg","request_headers","match","__sentry_own_request__","onreadystatechangeHandler","xhrInfo","status_code","status","handlerData","xhr","onreadystatechange","originalOnreadystatechange","onreadystatechangeThisArg","onreadystatechangeArgArray","setRequestHeader","originalSetRequestHeader","setRequestHeaderThisArg","setRequestHeaderArgArray","header","toLowerCase","send","originalSend","sendThisArg","sendArgArray","sentryXhrData","body","serializeFormData","formData","URLSearchParams","getBodyString","_logger","FormData","info","getFetchRequestArgBody","fetchArgs","LAST_INTERACTIONS","INTERACTIONS_SPAN_MAP","startTrackingINP","inpCallback","find","INP_ENTRY_MAP","interactionType","spanToUse","description","click","pointerdown","pointerup","mousedown","mouseup","touchstart","touchend","mouseover","mouseout","mouseenter","mouseleave","pointerover","pointerout","pointerenter","pointerleave","dragstart","dragend","drag","dragenter","dragleave","dragover","drop","keydown","keyup","keypress","input","registerInpInteractionListener","activeRootSpan","isPerformanceEventTiming","has","last","shift"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]}